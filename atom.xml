<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Biu&#39;s Blog</title>
  
  
  <link href="http://blog.heyb.top/atom.xml" rel="self"/>
  
  <link href="http://blog.heyb.top/"/>
  <updated>2022-12-31T16:03:24.453Z</updated>
  <id>http://blog.heyb.top/</id>
  
  <author>
    <name>He Yongbiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022年总结</title>
    <link href="http://blog.heyb.top/2022/12/31/2022-summary.html"/>
    <id>http://blog.heyb.top/2022/12/31/2022-summary.html</id>
    <published>2022-12-31T15:59:59.000Z</published>
    <updated>2022-12-31T16:03:24.453Z</updated>
    
    <content type="html"><![CDATA[<p>在一声声咳嗽中，就要迎来了新的一年。</p><p>我以为不出门我可以苟进新冠决赛圈，没想到在却是在冬至的时候发了烧，一连着圣诞节都睡了过去。</p><p>这一年所拥有、失去、遗憾、成长。以前总希望时间能够过得快些，希望自己快点长大，现在却总想着能够慢一些，好多事情都似乎没来得及做，却已经结结实实地完结了一年。</p><h2 id="学习"><a class="markdownIt-Anchor" href="#学习"></a> 学习</h2><p>今年在技术上进展缓慢，工作中用到的框架并不是主流的，多是做配置文件串联API 的工作，多是基于 MuleSoft 框架做的，现在也逐渐向 Springboot 迁移。所以更多学习的重心还是放在业余自学上。</p><p>今年就着个项目倒腾了一下vue3、typeScript和vite ，不得不说，换了vite之后，速度是真的快，调试服务和打包的速度都比用webpack快了太多了。同一项目下调试从平均需要 35-40 秒缩短到了 2 秒左右，对于开发的体验来说真的太舒服了。</p><p>此外今年主要学习的新语言是 go，对比Java来说，我感觉更轻便更灵活，学习了一些基础语法之后就可以上手开发一个应用。感觉可以适用于一些更中小型的应用如文件系统，小工具等。新的一年我期望会投入go的精力会更多一些，同时也希望能在容器化的内容多学习一些。期望能够持续地构建自己的知识框架，形成一些可复用的、较优的、结构化的方法论，避免遇到同样的问题不断重复的踩坑。</p><h2 id="感情"><a class="markdownIt-Anchor" href="#感情"></a> 感情</h2><p>今年的身份又多了一层，变成了从柳小姐的男朋友转变成了柳小姐的丈夫，和别人介绍的时候还没适应过来，还是「这是我的男/女朋友」，只是我们的关系更安定了一些。小环说，我跟她在一起之后似乎没有失眠过了，都是一躺下没多久就开始打呼噜了。想想我们的关系的确变得更「简单」了，有什么事情都可以直接和对方坦诚布公。在这段感情中我学习到了很多，开始以长远关系和长期价值去思考婚姻和家庭，争取从一个不错的男朋友成为一个优秀的丈夫。新的一年也期待能够再加一层身份，能够带着一个迷你的小环。</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><p>今年的时间多了，听的歌反而比去年少了很多（可能是因为在路上交通的时间少了），这里推荐三首我经常听的歌给大家：Bahamas - All The Time，JVKE - golden hour，伍佰 - 泪桥。</p><p>总觉得没有听到很抓耳的歌，刷了B站的 00-09 年百大华语金曲感慨以前的歌还是能打，也很庆幸自己经历过华语乐坛群星璀璨的年代。</p><p>今年和小环一起看了 55 部电影电视剧（加上我没跟她一起看的估计有 60+了）</p><p>大多时候我们都是刷了一些老剧，比较高分的有：</p><p>电影：无名之辈、我不是药神、Hello 树先生、让子弹飞、夏洛特烦恼，看不见的客人。</p><p>电视剧：庆余年、琅琊榜、国王:永远的君主、甄嬛传、寻秦记。</p><p>动漫：罗小黑、罗小黑战记。</p><p>这里我就不再做推荐了。</p><p>新的剧集有梦华录、风吹半夏，电影隐入尘烟都是今年值得一看的。</p><p>隐入尘烟看完，总感觉一口气郁结在心头，长叹一口气却也不能纾解。不由想起史铁生说的：“其实每时每刻我们都是幸运的，因为任何灾难的前面，都可能再加一个“更”字。”</p><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>当下总是最好的时候，纵然有许多事情，我们唯有接受，努力，好好生活。</p><p>新的一年期望大家身体健康，平安喜乐，万事顺意。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一声声咳嗽中，就要迎来了新的一年。&lt;/p&gt;
&lt;p&gt;我以为不出门我可以苟进新冠决赛圈，没想到在却是在冬至的时候发了烧，一连着圣诞节都睡了过去。&lt;/p&gt;
&lt;p&gt;这一年所拥有、失去、遗憾、成长。以前总希望时间能够过得快些，希望自己快点长大，现在却总想着能够慢一些，好多事情都似乎</summary>
      
    
    
    
    <category term="个人" scheme="http://blog.heyb.top/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
    <category term="个人" scheme="http://blog.heyb.top/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>「Docker」Docker 系列文章2 - Dockerfile</title>
    <link href="http://blog.heyb.top/2022/12/15/docker-docker-series-2---dockerfile.html"/>
    <id>http://blog.heyb.top/2022/12/15/docker-docker-series-2---dockerfile.html</id>
    <published>2022-12-15T15:35:33.000Z</published>
    <updated>2022-12-25T14:32:51.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Dockerfile是一个文本文件，其中包含创建 Docker 镜像所需的步骤和指令。主要分为<strong>基础镜像信息、维护者信息、镜像操作指令和容器启动时指令</strong>四个部分，并支持以 <code>#</code> 开头的注释行。这些指令告诉 Docker 如何设置应用程序的运行环境，通常包括安装软件包、复制文件和设置环境变量的命令。</p><p>用户可以使用 Dockerfile 与 <code>docker build</code> 命令一起使用，用于创建 Docker 自定义镜像，然后可以用该镜像创建 Docker 容器。</p><h2 id="构建镜像"><a class="markdownIt-Anchor" href="#构建镜像"></a> 构建镜像</h2><p>例如，假设我们想要创建一个基于 go-gin 的应用程序，并使用 Docker 运行它。可以使用 Dockerfile 来指定应用程序所需的依赖项、工作目录和启动命令。</p><p>以下是执行步骤</p><ol><li><p>初始化 go 项目：在 Go 项目目录中初始化 <code>go.mod</code> 文件。在终端中输入 <code>go mod init</code> 并回车，这将创建 <code>go.mod</code> 文件。</p></li><li><p>安装 go-gin 框架：在项目中安装 Gin 框架。在终端中输入 <code>go get github.com/gin-gonic/gin</code> 并回车，这将安装 Gin 框架。</p></li><li><p>编写使用 Gin 框架的 Go 代码，<code>gin.go</code> 文件代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 http 框架 https://github.com/gin-gonic/gin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 默认返回一个已连接日志记录器和恢复中间件的引擎实例。</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 绑定路由 /ping，访问后执行func的方法</span></span><br><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 返回一个 json， 状态值为 200， H的内容为 map[string]</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在0.0.0.0：8080上侦听和服务(对于Windows“为 localhost：8080”)</span></span><br><span class="line">err := r.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;启动服务异常：&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建一个 <code>Dockerfile</code> 文件，并编写文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用安装了Go的基本映像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> docker_user wsxc_0617@sina.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像的操作指令</span></span><br><span class="line"><span class="comment"># 将工作目录设置为项目根目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将Go代码复制到容器的工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 go module 模式，并设置代理服务</span></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on</span><br><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建Go代码</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">env</span> GOOS=linux GOARCH=amd64  go build -o go-gin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用程序的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当容器启动时运行Go代码</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;./go-gin&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>在这个文件中，第一行必须需要使用 <code>FROM</code> 命令来指定要使用的基础镜像</li><li>使用 <code>COPY</code> 命令将 Go 代码复制到镜像中</li><li>使用 <code>ENV</code> 设置环境变量，这里设置 <code>go module</code> 的代理服务，避免 Go 依赖包下载失败</li><li>使用 <code>RUN go build</code> 命令来构建 Go 代码，<code>-o</code> 表示指定打包后输出的文件名称</li><li>在 <code>Dockerfile</code> 中运行的 Go 代码。可以使用 <code>CMD</code> 或 <code>ENTRYPOINT</code> 命令来运行 Go 代码，一般是执行 <code>go build</code> 构建好的程序名</li></ul></li><li><p>使用 <code>docker build</code> 命令来构建你的 Docker 镜像。在终端中输入 <code>docker build -t &lt;image-name&gt; .</code> 并回车，其中 <code>&lt;image-name&gt;</code> 是我们要为镜像指定的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t go-gin .</span><br></pre></td></tr></table></figure><ul><li><p>在命令中 <code>-t</code> 指定镜像的名称和标记， 格式为 <code>name:tag</code>，如 <code>go-gin:latest</code></p></li><li><p>命令末尾的 <code>.</code> 表示构建上下文，即 Dockerfile 和需要包含在镜像中的文件的位置。也可以通过将 <code>.</code> 替换为包含Dockerfile的目录路径来指定不同的目录作为上下文。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myimage:latest /path/to/dir</span><br></pre></td></tr></table></figure><p>这将使用 <code>/path/to/dir</code> 目录中的 Dockerfile 和所需文件构建镜像。</p><p>重要的是，上下文必须包括 Dockerfile 和构建镜像所需的所有文件。Docker 守护程序将使用上下文构建镜像，并为 Dockerfile 中的每条指令创建一个新层。<br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p></li></ul><p>构建完成后，我们可以通过 <code>docker images</code> 查看构建好的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>可以看到如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                       TAG           IMAGE ID       CREATED          SIZE</span><br><span class="line">go-gin                           latest        d82303fc77be   34 seconds ago   1.13GB</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>docker run</code> 命令来运行你的 Docker 镜像。在终端中输入 <code>docker run -p 8080:8080 &lt;image-name&gt;</code> 并回车，其中 <code>8080</code> 是你希望运行应用程序的端口。<br>我们运行 <code>docker run -p 8080:8080 go-gin</code> 来运行镜像。可以看到如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class="line"> - using env:export GIN_MODE=release</span><br><span class="line"> - using code:gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /ping                     --&gt; main.main.func1 (3 handlers)</span><br><span class="line">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.</span><br><span class="line">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.</span><br><span class="line">[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure><p>命令参考文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p><p>通过浏览器访问 <code>http://localhost:8080/ping</code>  可以看到返回了信息 <code>&#123;&quot;message&quot;:&quot;pong&quot;&#125;</code></p></li></ol><h2 id="分段构建"><a class="markdownIt-Anchor" href="#分段构建"></a> 分段构建</h2><p>「Dockerfile 构建镜像太大了怎么处理」</p><p>在 Dockerfile 中，可以使用多个构建阶段来进行分段构建。分段构建的目的是为了在构建 Docker 镜像的过程中，更加高效地使用资源。</p><p>在 Dockerfile 中，每个构建阶段都是一个单独的上下文，在每个构建阶段中执行的操作都是独立的。在每个构建阶段结束时，Docker 会将其上下文打包成一个新的镜像层，并将其与前面的镜像层合并。</p><p>我们在上一步操作中可以看到我们的代码量很小，但是构建出来的镜像却有 1GB 大小。主要是因为依赖包等内容也一并打包到构建的镜像中去了，实际上我们仅需编译好 Go 的二进制文件即可运行。因此可以通过 Dockerfile 的分段构建来进行镜像的瘦身。</p><p>代码如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 构建 ---------- #</span></span><br><span class="line"><span class="comment"># 使用安装了Go的基本映像【并且设置别名】</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest as go_app_build</span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> docker_user wsxc_0617@sina.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像的操作指令</span></span><br><span class="line"><span class="comment"># 将工作目录设置为项目根目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将Go代码复制到容器</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 go module的代理服务</span></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on</span><br><span class="line"><span class="keyword">ENV</span> GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建Go代码</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">env</span> GOOS=linux GOARCH=amd64 go build -o go-gin .</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 运行 ---------- #</span></span><br><span class="line"><span class="comment"># 运行环境设置为 alpine</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as go_app_run</span><br><span class="line"><span class="comment"># 【采用相同的目录为工作目录】</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 【将构建镜像中编译好的二进制文件复制到运行镜像中】</span></span><br><span class="line"><span class="comment">#COPY --from=go_app_build /app .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /app .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示应用程序的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当容器启动时运行Go代码</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;./go-gin&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>在修改后的 Dockerfile 中，我们可以看到有两个构建阶段：“go_app_build” 和 “go_app_run”。</p><p>在 “go_app_build” 构建阶段中，我们执行了将 Go 代码复制到容器、设置 Go module 的代理服务以及构建 Go 代码的操作。</p><p>在 “go_app_run” 构建阶段中，我们执行了将编译好的二进制文件复制到运行镜像中的操作。</p><p>COPY 指令的 --from 选项允许你从其他构建阶段复制文件。可以使用 FROM 指令的名称来标识构建阶段，也可以使用数字来标识构建阶段。当使用数字标识构建阶段时，0 表示第一个构建阶段，1 表示第二个构建阶段，以此类推。</p><p>例如，在本例中，0 表示名为 “go_app_build” 的构建阶段，即在修改后的 Dockerfile 中的第一个构建阶段。</p><p>使用数字标识构建阶段的好处是，当我们添加、删除或重新排制构建阶段时，只需要更新相应的数字即可，而不需要更新所有的构建阶段名称。</p><p>例如，假设你在修改后的 Dockerfile 中再添加了一个构建阶段，那么只需要将这个新的构建阶段的标识符设置为 2，其他的构建阶段的标识符都不需要更改。这样可以避免出现因为构建阶段名称的更改而导致的潜在问题</p><p>我们使用 <code>docker build -t go-gin2 .</code> 命令，来构建名为 <code>go-gin2</code> 的镜像，并通过 <code>docker images</code> 查看构建好的镜像，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                       TAG           IMAGE ID       CREATED          SIZE</span><br><span class="line">go-gin2                          latest        ddbe692c0268   56 minutes ago   36.1MB</span><br></pre></td></tr></table></figure><p>可以看到我们构建出来的镜像比之前小了很多，主要因为</p><blockquote><ol><li><p>同一个 Dockerfile 文件的多个 FROM 是多个不同的image，不同的 image 之间数据隔离，包括环境变量，但是不同的 image 之间可以通过 <code>--from</code> 来传递数据</p></li><li><p>同一个 Dockerfile 的多个 FROM 只有最后一个FROM 才会生成最终的镜像，因此编译阶段的环境没有在第二阶段中，第二阶段只是引用了第一阶段的生成物：二进制文件，所以最终生成的镜像文件比写一个 FROM 要小得多</p></li></ol></blockquote><p>分段构建的优点是，当构建过程中的某个操作失败时，Docker 只需要重新构建失败的构建阶段，而不需要重新构建整个镜像。这样可以提高构建效率，并减少构建失败的风险。</p><p>总的来说，分段构建是一种非常有用的技术，可以帮助我们提高 Docker 镜像的构建效率，并减少构建失败的风险。建议在编写 Dockerfile 时尽量使用分段构建，以便更好地利用 Docker 的构建功能。</p><h2 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h2><p>Dockerfile 指令的一般格式为<code>INSTRUCTION &lt;arguments&gt;</code>，下面分别做详细介绍。</p><h3 id="from"><a class="markdownIt-Anchor" href="#from"></a> FROM</h3><p>格式为<code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code>。第一条指令必须为<code>FROM</code>指令，在同一个Dockerfile中创建多个镜像时可以使用多个<code>FROM</code>指令（每个镜像一次）。</p><h3 id="maintainer"><a class="markdownIt-Anchor" href="#maintainer"></a> MAINTAINER</h3><p>格式为<code>MAINTAINER &lt;name&gt;</code>，指定维护者信息。</p><h3 id="run"><a class="markdownIt-Anchor" href="#run"></a> RUN</h3><p>格式为<code>RUN &lt;command&gt;</code>或<code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>。前者将在shell终端中运行命令，即<code>/bin/sh -c</code>；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</span><br></pre></td></tr></table></figure><p>每条<code>RUN</code>指令将在当前镜像基础上执行指定命令，并提交为新的镜像，当命令较长时可使用<code>\</code>来换行。</p><h3 id="cmd"><a class="markdownIt-Anchor" href="#cmd"></a> CMD</h3><p>支持三种格式：</p><ul><li><code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>，使用<code>exec</code>执行，推荐方式。</li><li><code>CMD command param1 param2</code>，在<code>/bin/sh</code>中执行，提供给需要交互的应用。</li><li><code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code>，提供给<code>ENTRYPOINT</code>的默认参数</li></ul><p>指定启动容器时执行的命令，每个Dockerfile只能有一条<code>CMD</code>命令，如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时指定了运行的命令则会覆盖掉<code>CMD</code>指定的命令。</p><h3 id="expose"><a class="markdownIt-Anchor" href="#expose"></a> EXPOSE</h3><p>格式为<code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>，告诉Docker服务端容器暴露的端口号，供互联系统使用。</p><p>在启动容器时需要通过<code>-P</code>，Docker主机会自动分配一个端口转发到指定的端口；使用<code>-p</code>则可以具体指定哪个本地端口映射过来。</p><h3 id="env"><a class="markdownIt-Anchor" href="#env"></a> ENV</h3><p>格式<code>ENV &lt;key&gt; &lt;value&gt;</code>，指定一个环境变量，会被后续<code>RUN</code>指令使用，并在容器运行时保持。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV PG_MAJOR    9.3</span><br><span class="line">ENV PG_VERSION  9.3.4</span><br><span class="line">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgres &amp;&amp; ...</span><br><span class="line">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="add"><a class="markdownIt-Anchor" href="#add"></a> ADD</h3><p>格式<code>ADD &lt;src&gt; &lt;dest&gt;</code>，复制指定的<code>&lt;src&gt;</code>到容器中的<code>&lt;dest&gt;</code>，其中<code>&lt;src&gt;</code>可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。</p><h3 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> COPY</h3><p>格式<code>COPY &lt;src&gt; &lt;dest&gt;</code>，复制本地主机的<code>&lt;src&gt;</code>（为Dockerfile所在目录的相对路径，文件或目录）为容器中的<code>&lt;dest&gt;</code>，目标路径不存在时会自动创建。</p><h3 id="entrypoint"><a class="markdownIt-Anchor" href="#entrypoint"></a> ENTRYPOINT</h3><p>配置容器启动后执行的命令，且不可被<code>docker run</code>提供的参数覆盖。有两种格式：</p><ul><li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li><li><code>ENTRYPOINT command param1 param2</code>，shell中执行。</li></ul><p>每个Dockerfile中只能有一个<code>ENTRYPOINT</code>，当指定多个<code>ENTRYPOINT时</code>，只有最后一个生效。</p><h3 id="volume"><a class="markdownIt-Anchor" href="#volume"></a> VOLUME</h3><p>格式<code>VOLUME [&quot;/data&quot;]</code>，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p><h3 id="user"><a class="markdownIt-Anchor" href="#user"></a> USER</h3><p>格式<code>USER daemon</code>，指定运行容器时的用户名或UID，后续的<code>RUN</code>也会使用指定用户。</p><p>当服务不需要管理员权限时，可通过该命令指定运行用户，并可在之前创建所需要的用户。要临时获取管理员权限可使用<code>gosu</code>，而不推荐<code>sudo</code>。</p><h3 id="workdir"><a class="markdownIt-Anchor" href="#workdir"></a> WORKDIR</h3><p>格式<code>WORKDIR /path/to/workdir</code>，为后续的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>指令配置工作目录。</p><p>可以使用多个<code>WORKDIR</code>指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最终路径为/a/b/c</span></span><br></pre></td></tr></table></figure><h3 id="onbuild"><a class="markdownIt-Anchor" href="#onbuild"></a> ONBUILD</h3><p>格式<code>ONBUILD [INSTRUCTION]</code>，配置当前所创建的镜像作为其他新创建的基础镜像时所执行的操作指令。</p><p>镜像image-A Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>基于image-A创建新镜像，新的Dockerfile中使用<code>FROM images-A</code>指定基础镜像时，会自动执行<code>ONBUILD</code>指令内容，等价于在后面添加了两条指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM images-A</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Automatically run the following 等价于自动运行以下命令</span></span><br><span class="line">ADD . /app/src</span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure><p>使用<code>ONBUILD</code>指令的镜像推荐在标签中注明。例如<code>ruby:1.9-onbuild</code>。</p><blockquote><p>实用技巧：</p><p>如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。</p><p>例如上面的底是<code>golang:latest</code>，我们可以运行<code>docker run -it -d golang:latest bash</code>，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。</p><p>掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。</p></blockquote><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><p>怎样上传到阿里云私有仓库？</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p><a href="https://docs.docker.com/engine/reference/builder/#run">官方文档</a></p><p><a href="https://www.jianshu.com/p/f272726db9c5">Docker安装与基本操作</a></p><p><a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/N9VtYIIi">Docker 快速入门-制作自己的镜像</a></p><p><a href="https://www.jianshu.com/p/678b751d14ae">go 构建最小的镜像</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;Dockerfile是一个文本文件，其中包含创建 Docker 镜像所需的步骤和指令。主要分为&lt;strong&gt;基础镜像信息、维护者信息、镜像操作</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="容器" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="容器" scheme="http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://blog.heyb.top/tags/Docker/"/>
    
    <category term="Dockerfile" scheme="http://blog.heyb.top/tags/Dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>「ChatGPT」OpenAI ChatGPT注册攻略</title>
    <link href="http://blog.heyb.top/2022/12/08/chatgpt-openai-chatgpt-registration-strategy.html"/>
    <id>http://blog.heyb.top/2022/12/08/chatgpt-openai-chatgpt-registration-strategy.html</id>
    <published>2022-12-08T09:22:20.000Z</published>
    <updated>2022-12-25T14:31:59.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>ChatGPT 是一种大型语言模型，由OpenAI训练而成。它的目的是通过对大量语言数据的学习，能够帮助人们更好地理解和生成自然语言。它可以用来完成各种自然语言处理任务，比如机器翻译 —— 将一段文本从一种语言翻译到另外一种语言，问答系统 —— 回答日常生活的常见问题、学术问题，文本生成 —— 生成文章、邮件，解释语言语法、语义等等。</p><p>以下是 chatGPT的使用案例，可以自己参考使用或摸索合适自己的方式</p><table><thead><tr><th>案例序号</th><th>案例名称</th><th>案例来源</th></tr></thead><tbody><tr><td>1</td><td>生成AI Prompt</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/GuyP/status/1598020781065527296">https://twitter.com/GuyP/status/1598020781065527296</a></td></tr><tr><td>2</td><td>编写iOS SwiftUI APP</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/avielgr/status/1598895550392197121">https://twitter.com/avielgr/status/1598895550392197121</a></td></tr><tr><td>3</td><td>学习技术</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/HamelHusain/status/1598834924848836609">https://twitter.com/HamelHusain/status/1598834924848836609</a></td></tr><tr><td>4</td><td>写出一个可以生成小鸟图片的Python脚本</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/bgavran3/status/1598857248536956928">https://twitter.com/bgavran3/status/1598857248536956928</a></td></tr><tr><td>5</td><td>写Javascript脚本</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/vertinski/status/1599099368472137729">https://twitter.com/vertinski/status/1599099368472137729</a></td></tr><tr><td>6</td><td>参与SAT考试</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/davidtsong/status/1598767389390573569">https://twitter.com/davidtsong/status/1598767389390573569</a></td></tr><tr><td>7</td><td>自然语言转成Latex</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/jdjkelly/status/1598021488795586561">https://twitter.com/jdjkelly/status/1598021488795586561</a></td></tr><tr><td>8</td><td>解释代码</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/goodside/status/1598129631609380864">https://twitter.com/goodside/status/1598129631609380864</a></td></tr><tr><td>9</td><td>改写故事</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/raphaelmilliere/status/1598469100535259136">https://twitter.com/raphaelmilliere/status/1598469100535259136</a></td></tr><tr><td>10</td><td>debugging代码</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/amasad/status/1598042665375105024">https://twitter.com/amasad/status/1598042665375105024</a></td></tr><tr><td>11</td><td>写计算机网络家庭作业</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/abhnvx/status/1598258353196929024">https://twitter.com/abhnvx/status/1598258353196929024</a></td></tr><tr><td>12</td><td>替代搜索引擎</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/RajJohri2019/status/1598492953764315137">https://twitter.com/RajJohri2019/status/1598492953764315137</a></td></tr><tr><td>13</td><td>创作短剧</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/rgodfrey/status/1598162900140445697">https://twitter.com/rgodfrey/status/1598162900140445697</a></td></tr><tr><td>14</td><td>创作食谱</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/stephsmithio/status/1598920887029628928">https://twitter.com/stephsmithio/status/1598920887029628928</a></td></tr><tr><td>15</td><td>反编译汇编代码</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/mahal0z/status/1598536939942006784">https://twitter.com/mahal0z/status/1598536939942006784</a></td></tr><tr><td>16</td><td>代写办公邮件</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/CubicleApril/status/1598753388895797282">https://twitter.com/CubicleApril/status/1598753388895797282</a></td></tr><tr><td>17</td><td>写年度总结报告</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/shanselman/status/1599073011050872832">https://twitter.com/shanselman/status/1599073011050872832</a></td></tr><tr><td>18</td><td>闲聊</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/t3dotgg/status/1598954493680713729">https://twitter.com/t3dotgg/status/1598954493680713729</a></td></tr><tr><td>19</td><td>撰写技术博客</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/goodside/status/1598235521675038722">https://twitter.com/goodside/status/1598235521675038722</a></td></tr><tr><td>20</td><td>逻辑推理问题</td><td><a href="https://link.zhihu.com/?target=https%3A//twitter.com/Robdeprop/status/1598285166971351040">https://twitter.com/Robdeprop/status/1598285166971351040</a></td></tr></tbody></table><h2 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h2><ul><li><p>留学代理，要求是非中国（及地区）的地址，如日韩、印度、新加坡、美国等</p></li><li><p>准备一个国外手机号或者用<a href="https://sms-activate.org/">接码平台 sms-activate</a></p></li></ul><h2 id="开始"><a class="markdownIt-Anchor" href="#开始"></a> 开始</h2><h3 id="接码平台"><a class="markdownIt-Anchor" href="#接码平台"></a> 接码平台</h3><p>打开接码平台 <a href="https://sms-activate.org/?ref=2684538">sms-activate.org</a>，注册一个账号。注册后在右上角个人信息中进行充值，这里单位是卢布</p><p>接码OpenAi的一次费用是大概10卢布（约 1 块多人民币），不过只能充美金，充值0.2美元即可，充值时下滑可以选择支付宝进行支付。</p><p>充值完成后我们去注册openAI的账号</p><h3 id="注册openai账号"><a class="markdownIt-Anchor" href="#注册openai账号"></a> 注册OpenAI账号</h3><p>首先是打开<a href="https://beta.openai.com/signup">ChatGPT的账户注册页面</a>。谷歌注册或者邮箱注册都可以，这里用邮箱注册作为例子。</p><p>用邮箱注册后有个验证邮件，进去邮箱，点开链接。（如果无法打开链接的话要注意邮件中是否允许了可执行脚本）</p><p>如果出现提示说不能在当前国家服务： <code>Not available OpenAI's services are not available in your country.</code></p><p>就是因为代理没有设置为全局，或者地区不对。</p><p>如果出现了这个提示，那么接下来怎么切换代理，都是没用的，可以在浏览器控制台清空状态</p><h3 id="解决地区问题"><a class="markdownIt-Anchor" href="#解决地区问题"></a> 解决地区问题</h3><p>首先要将代理地址切换到不是国内地区的代理（如港澳台）</p><p>然后，先复制下面这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">javascript</span>:<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">removeItem</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">window</span>.<span class="property">localStorage</span>).<span class="title function_">find</span>(<span class="function"><span class="params">i</span>=&gt;</span>i.<span class="title function_">startsWith</span>(<span class="string">&#x27;@@auth0spajs&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>打开浏览器控制台粘贴进去，然后按下回车键，接着刷新页面，如果代理没问题，就可以正常看到注册页面了。</p><h3 id="填写手机验证码"><a class="markdownIt-Anchor" href="#填写手机验证码"></a> 填写手机验证码</h3><p>到我们的接码网站上去，在左侧菜单栏搜索OpenAi，然后选择巴西（经测试可用）或印度（更实惠但未经测试），点击小黄车购买。</p><p>然后在右侧主页面会出现购买好的手机号，点击复制后回到 openAI的验证界面-verify your phone number，选择了对应国家地区然后粘贴手机号选send code。</p><p>回到接码平台的手机号界面，等待一会儿网站会提示验证码，我们复制粘贴即可。</p><p>如果申请Send code发送短信时，总是出现发送短信请求次数过多，无法发送的问题。</p><p>这个应该是ChatGPT的用户突然暴增导致的，官方也给了说明，大家耐心等待一会应该就可以。</p><p>现在我们可以愉快的进行使用了</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><p>需要注意的是</p><ul><li><p>ChatGPT目前是不联网的状态，所以回答的内容也是2021年之前的。</p></li><li><p>ChatGPT的回答不是 100%准确，仅可以作为参考。并且也和提问的技巧有关系：</p><p>如：问它能说一下Java工作中遇到的问题吗？</p><p>它会回答：</p><p>由于我是一个计算机程序，我没有工作，也没有遇到任何 Java 问题。我只能通过对已有信息的学习来回答问题。你可以提供一些关于 Java 的信息，我可以尝试为你解答问题。</p><p>如果问它：假设我是一名 多年经验的高级java开发程序员，你能尝试模拟说我在工作中遇到的问题吗</p><p>它就可以模拟情景来进行回答</p></li><li><p>ChatGPT使用英文提问会比使用中文提问效果会更好</p></li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/589017082">最强AI对话系统ChatGPT不完全使用指南——已发掘功能展览！</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;ChatGPT 是一种大型语言模型，由OpenAI训练而成。它的目的是通过对大量语言数据的学习，能够帮助人们更好地理解和生成自然语言。它可以用来</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="其他" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/"/>
    
    <category term="AI" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/"/>
    
    <category term="ChatGPT" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/ChatGPT/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="ChatGPT" scheme="http://blog.heyb.top/tags/ChatGPT/"/>
    
    <category term="OpenAI" scheme="http://blog.heyb.top/tags/OpenAI/"/>
    
  </entry>
  
  <entry>
    <title>「Docker」Docker 系列文章1 - 入门</title>
    <link href="http://blog.heyb.top/2022/12/04/docker-docker-series-1---getting-started.html"/>
    <id>http://blog.heyb.top/2022/12/04/docker-docker-series-1---getting-started.html</id>
    <published>2022-12-04T08:14:47.000Z</published>
    <updated>2022-12-25T14:32:35.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Docker 是一个开源的容器管理平台，它允许开发人员在轻量级容器中运行应用程序。容器是一种轻量级的虚拟化技术，它允许将应用程序及其依赖项打包在一起，并在任何支持容器的环境中运行。这样，开发人员可以确保应用程序在不同的平台上保持一致，并且能够在任何地方快速部署和运行。</p><p>Docker可以简单理解为轻量级的虚拟机，但它使用独立于底层操作系统的容器来运行应用程序。与虚拟机相比，Docker 可以更快速地启动和运行应用程序，因为它不需要启动一个完整的操作系统来运行应用程序。这也使得 Docker 更容易在多个环境中进行部署，例如开发环境、测试环境和生产环境。</p><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>轻量级：可以通过一行命令完成启动和停止，方便快捷。</li><li>可移植：可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意操作系统，在不同的环境中运行。</li><li>隔离：运行时利用沙箱机制形成隔离容器，各个应用互不干扰，可以有效地管理应用程序之间的依赖关系和资源限制。</li><li>Docker 的生态系统提供了丰富的工具，可以帮助开发人员构建、部署和管理容器化应用程序。</li></ul><h3 id="能做什么"><a class="markdownIt-Anchor" href="#能做什么"></a> 能做什么</h3><ol><li><p>快速部署，解决不同环境中系统差异的问题<br>在使用Docker前，我们在不同环境下（如开发环境、测试环境、生产环境等）需要安装、配置、维护不同的应用程序（如JDK、Tomcat、数据库等），不同应用在每个环境都需要做一遍同样的操作，工作量繁重。使用Docker可以自己创建空镜像从头构建（或使用公共仓库中构建好的镜像），直接能够在不同环境中一步到位搭建部署整套应用环境。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“代码在我机器上没问题啊”的情况。</p></li><li><p>解决依赖问题，多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</p><p>大型项目中依赖关系复杂，依赖的组件非常多，不同组件之间部署时往往会产生依赖兼容性问题。<br>例如：一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项，甚至Node JS的版本都需要不相同，此时便会出现依赖兼容问题。Docker应用运行在容器中，使用沙箱机制可以将环境互相隔离。不同应用需要不同的版本我们就运行在不同的容器中即可。</p></li><li><p>更轻松的扩展和维护<br>基于上面的优点，使得Docker在应用复用更为容易，能够使得应用快速扩展，让服务弹性伸缩变得简单，能够轻松地完成动态管理的工作，根据业务需求实时扩展或拆除应用程序和服务。</p></li><li><p>快速安装测试/学习软件，用完就可以删除，不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK</p></li></ol><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p>镜像（Image）：像是文件模板，可以理解为软件安装包，可以方便的进行传播和安装。一个镜像可以创建多个容器</p><p>容器（Container）：是由镜像创建的运行实例，可以理解为软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><p>仓库（Repository）：集中存放镜像文件的场所，可以理解为 Maven、Git 的仓库，当我们需要镜像文件的时候，可以从远程仓库中拉取。官方镜像仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>桌面版：<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a><br>服务器版：<a href="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></p><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><p>windows 打开桌面版的时候如果出现了如下问题</p><p><code>Hardware assisted virtualization and data execution protection must be enabled in the BIOS.</code></p><p>则需要开启 WSL2 功能</p><p>在控制面板-&gt;程序-&gt;启用或关闭 windows 功能，勾选Windows虚拟机监控程序平台和适用于Linux的Windows子系统，以开启 Windows 虚拟化和 Linux 子系统（WSL2)</p><p>如果出现 WSL 2 installation is incomplete.<br>The WSL2 Linux kernel is now installed using a separate MSI update package. Please click the link and follow the instructions to install the kernel update: xxx</p><p>则需要安装最新版本的 WSL2： <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>镜像加速源</p><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https://&lt;your_code&gt;.mirror.aliyuncs.com</td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><p><img src="https://sjwx.easydoc.xyz/46901064/files/l25jdwrn.png" alt="img"></p><h2 id="安装软件"><a class="markdownIt-Anchor" href="#安装软件"></a> 安装软件</h2><p>传统应用安装，可能需要先安装许多的依赖。例如我们安装WordPress （一个基于 PHP 和 MySQL 的免费和开源内容管理系统（CMS））的话，则需要先安装Apache、Php、MySQL等环境后才可以正常安装WordPress。同一系统下也不方便安装多个版本的软件，有些软件还卸载不干净。</p><p>相对比之下Dokcer安装更简洁，一个命令就可以快速安装和卸载。也没有系统兼容的问题，Linux专享的软件也可以在Windows下使用。</p><h3 id="安装redis"><a class="markdownIt-Anchor" href="#安装redis"></a> 安装Redis</h3><p>在Redis官方网站中并没有提供Docker相关的安装方式。</p><p>可以通过Docker官方镜像仓库查找Redis镜像：<a href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a></p><p>通过命令 <code>docker pull redis</code> 来拉取镜像，也可以通过直接运行 <code>docker run</code> 来创建并运行容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis redis:latest</span><br></pre></td></tr></table></figure><p>然后会返回一串容器id（我这里是1c8f24cddd1d7a4accac19e1ef8f7ab68e70f663c3a8f184bbc732fd50f43abd），</p><p>就表示创建成功。如果有需要，我们也可以设置更多参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always --log-opt max-size=100m --log-opt max-file=2 -p 6379:6379 --name redis -d redis --appendonly yes  --requirepass 123456</span><br></pre></td></tr></table></figure><ul><li><code>--restart=always</code> 为开机启动</li><li><code>-log</code> 为日志方面的设置</li><li><code>-p</code> 为将内部端口映射到外部的端口，将6379端口挂载出去，前面为宿主机端口，后面为镜像内端口</li><li><code>-name</code> 为容器名字</li><li><code>-d redis</code> 表示后台启动redis</li><li><code>-- appendonly yes</code> 开启 redis 持久化</li><li><code>-- requirepass</code> 为设置redis访问密码</li></ul><p>注意：生产环境尽量不要使用 latest 版本，应使用指定版本号</p><h3 id="查看状态"><a class="markdownIt-Anchor" href="#查看状态"></a> 查看状态</h3><p>通过以下命令查看容器运行状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a |grep &lt;容器名&gt;</span><br></pre></td></tr></table></figure><p>运行 <code>docker ps -a |grep redis</code>  得到以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1c8f24cddd1d  redis  &quot;docker-entrypoint.s…&quot;  47 seconds ago  Up 45 seconds  0.0.0.0:6379-&gt;6379/tcp  redis</span><br></pre></td></tr></table></figure><p>或者通过容器 id 来查看状态如：<code>docker ps -a | grep 1c8f</code></p><h3 id="查看容器运行日志"><a class="markdownIt-Anchor" href="#查看容器运行日志"></a> 查看容器运行日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --since 30m &lt;容器名/id&gt;</span><br></pre></td></tr></table></figure><ul><li>–since 30m 是查看此容器30分钟之内的日志情况。</li></ul><p>运行<code>docker logs --since 30m redis</code> 或 <code>docker logs --since 30m 1c8f</code> 得到如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1:C 15 Dec 2022 08:23:37.361 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">1:C 15 Dec 2022 08:23:37.361 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started</span><br><span class="line">1:C 15 Dec 2022 08:23:37.361 # Configuration loaded</span><br><span class="line">1:M 15 Dec 2022 08:23:37.363 * monotonic clock: POSIX clock_gettime</span><br><span class="line">1:M 15 Dec 2022 08:23:37.366 * Running mode=standalone, port=6379.</span><br><span class="line">1:M 15 Dec 2022 08:23:37.366 # Server initialized</span><br><span class="line">1:M 15 Dec 2022 08:23:37.367 * Ready to accept connections</span><br></pre></td></tr></table></figure><h3 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> 进入容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker extc -it &lt;容器&gt; &lt;命令&gt;</span><br></pre></td></tr></table></figure><p>运行 <code>docker exec -it redis redis-cli</code>  或   <code>docker exec -it 1c8f redis-cli</code>  就可以进入到redis 当中，刚才我们设置了密码，因此要用<code>auth</code>命令登录后才可以使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set abc 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get abc</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br></pre></td></tr></table></figure><p>此时我们已经可以操作并查看到redis中的数据了，证明我们已经安装成功，接下来我们学习怎样停止或删除容器</p><h3 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h3><p>我们需要停止运行中的容器才可以删除</p><p>停止命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器名/id&gt;</span><br></pre></td></tr></table></figure><p>运行 <code>docker stop redis</code> 或 <code>docker stop 1c8f</code>停止容器</p><p>删除命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器名/id&gt;</span><br></pre></td></tr></table></figure><p>运行 <code>docker rm redis</code>  或 <code>docker rm 1c8f</code> 删除容器</p><p>通过 <code>docker ps -a</code> 查看 redis 容器已经被删除</p><h3 id="删除镜像"><a class="markdownIt-Anchor" href="#删除镜像"></a> 删除镜像</h3><p>查看全部镜像命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>删除镜像命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi &lt;镜像id&gt;</span><br></pre></td></tr></table></figure><p>运行 <code>docker rmi 7614</code> 删除镜像， 这里的7614是我的redis的镜像id</p><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><h3 id="镜像"><a class="markdownIt-Anchor" href="#镜像"></a> 镜像</h3><h4 id="获取镜像"><a class="markdownIt-Anchor" href="#获取镜像"></a> 获取镜像</h4><p><code>docker pull IMAGE_NAME[:Tag]</code> ：用于从 Docker 仓库下载镜像，如不显式指定TAG，则默认选择latest标签</p><h4 id="查看信息"><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h4><p><code>docker images</code>列出本地主机上已有的镜像信息</p><p><code>docker inspect IMAGE_ID</code>可以获取该镜像的详细信息。</p><h4 id="标签镜像"><a class="markdownIt-Anchor" href="#标签镜像"></a> 标签镜像</h4><p><code>docker tag REPOSITORY:TAG</code>可为本地镜像添加新的标签，例如 <code>docker tag ubuntu:latest latest_ubuntu:latest</code></p><h4 id="搜索镜像"><a class="markdownIt-Anchor" href="#搜索镜像"></a> 搜索镜像</h4><p><code>docker search IMAGE_NAME</code> ：用于在 Docker 仓库中搜索镜像，例如 <code>docker search mysql</code></p><p>可选参数：</p><ul><li><code>--automated=false</code> 仅显示自动创建的镜像</li><li><code>--no-trunc=false</code> 输出信息不截断显示</li><li><code>-s</code>，–starts=0 指定仅显示评价为指定星级以上的镜像</li></ul><h4 id="删除镜像-2"><a class="markdownIt-Anchor" href="#删除镜像-2"></a> 删除镜像</h4><p><code>docker rmi IMAGE[IMAGE...]</code>IMAGE可以为标签或ID。使用镜像ID来删除时，会先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身。</p><blockquote><p>注意：当有该镜像创建的容器存在时，镜像文件默认是无法被删除的。</p></blockquote><p><code>docker ps -a</code>命令可以看到本机上存在的所有容器。</p><p>强制删除镜像用<code>docker rmi -f IMAGE</code>命令。使用<code>-f</code>参数来强制删除一个存在容器依赖的镜像会造成一些遗留问题。正确做法是先删除依赖镜像的所有容器，再来删除镜像。删除容器用<code>docker rm CONTAINER_ID</code>命令。</p><h4 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h4><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]</code> 基于已有镜像的容器创建</p><p>可选参数：</p><ul><li><code>-a</code>，–author=“” 作者信息</li><li><code>-m</code>，–message&quot;&quot; 提交信息</li><li><code>-p</code>，–pause=true 提交时暂停容器运行</li></ul><p>举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               dea1945146b9        6 weeks ago         188MB</span><br><span class="line">[root@localhost test]# docker run -ti ubuntu:14.04 /bin/bash</span><br><span class="line">root@098ab9bc25f8:/# touch test</span><br><span class="line">root@098ab9bc25f8:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost test]# docker commit -m &quot;Added a new file&quot; -a &quot;Docker Test&quot; 098ab9bc25f8 test</span><br><span class="line">sha256:68ceff3107a82641378dee544caeed48e6d544b4d74b525051381b7db7479d35</span><br><span class="line">[root@localhost test]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">test                latest              68ceff3107a8        16 seconds ago      188MB</span><br><span class="line">ubuntu              14.04               dea1945146b9        6 weeks ago         188MB</span><br></pre></td></tr></table></figure><p>基于本地模板导入使用<code>cat 镜像压缩包 | docker import -REPOSITORY:TAG</code>命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls</span><br><span class="line">ubuntu-14.04-x86_64-minimal.tar.gz</span><br><span class="line">[root@localhost test]# cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04-server</span><br><span class="line">sha256:ae63a9e87332075323de0e2cb3e12dd6ea8c6078e006dd937dc0d670c4a8773d</span><br><span class="line">[root@localhost test]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04-server        ae63a9e87332        12 seconds ago      215MB</span><br><span class="line">test                latest              68ceff3107a8        About an hour ago   188MB</span><br><span class="line">ubuntu              14.04               dea1945146b9        6 weeks ago         188MB</span><br></pre></td></tr></table></figure><h4 id="存储镜像"><a class="markdownIt-Anchor" href="#存储镜像"></a> 存储镜像</h4><p><code>docker save -o 压缩包保存名 REPOSITORY:TAG</code> 可存出镜像。</p><p>举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               dea1945146b9        6 weeks ago         188MB</span><br><span class="line">[root@localhost test]# docker save -o ubuntu_server.tar ubuntu:14.04</span><br><span class="line">[root@localhost test]# ls</span><br><span class="line">ubuntu_server.tar</span><br></pre></td></tr></table></figure><h4 id="载入镜像"><a class="markdownIt-Anchor" href="#载入镜像"></a> 载入镜像</h4><p><code>docker load --input 压缩包保存名</code>或者<code>docker load &lt; 压缩包保存名</code>可从导出的文件中重新载入镜像。</p><p>举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls</span><br><span class="line">ubuntu_server.tar</span><br><span class="line">[root@localhost test]# docker load --input ubuntu_server.tar </span><br><span class="line">Loaded image: ubuntu:14.04</span><br><span class="line">[root@localhost test]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               dea1945146b9        6 weeks ago         188MB</span><br></pre></td></tr></table></figure><h4 id="构建镜像"><a class="markdownIt-Anchor" href="#构建镜像"></a> 构建镜像</h4><p><code>docker build</code>：用于从 Dockerfile 创建一个新的镜像</p><h4 id="上传镜像"><a class="markdownIt-Anchor" href="#上传镜像"></a> 上传镜像</h4><p>可以使用<code>docker push NAME[:TAG]</code>上传镜像到仓库，默认上传到DockerHub官方仓库。第一次使用必须要先登录。</p><p>举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04-server        ae63a9e87332        4 minutes ago       215MB</span><br><span class="line">test                latest              68ceff3107a8        About an hour ago   188MB</span><br><span class="line">ubuntu              14.04               dea1945146b9        6 weeks ago         188MB</span><br><span class="line">[root@localhost test]# docker tag test:latest username/test:latest</span><br><span class="line">[root@localhost test]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                14.04-server        ae63a9e87332        7 minutes ago       215MB</span><br><span class="line">username/test         latest              68ceff3107a8        About an hour ago   188MB</span><br><span class="line">test                  latest              68ceff3107a8        About an hour ago   188MB</span><br><span class="line">ubuntu                14.04               dea1945146b9        6 weeks ago         188MB</span><br><span class="line">[root@localhost test]# docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: username</span><br><span class="line">Password: </span><br><span class="line">Login Succeeded</span><br><span class="line">[root@localhost test]# docker push username/test:latest</span><br><span class="line">The push refers to a repository [docker.io/username/test]</span><br><span class="line">786a798121af: Pushed </span><br><span class="line">7fb9ba64f896: Pushed </span><br><span class="line">4e1e6ac5b9d6: Pushed </span><br><span class="line">48daf661d621: Pushed </span><br><span class="line">bf59e7acf5c4: Pushed </span><br><span class="line">c47d9b229ca4: Pushed </span><br><span class="line">latest: digest: sha256:c46955d49b5b7cf15528b94d5c4fb7028b61c52cf00ee4d14073a92379e2237f size: 1566</span><br></pre></td></tr></table></figure><h3 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h3><h4 id="创建容器"><a class="markdownIt-Anchor" href="#创建容器"></a> 创建容器</h4><p><code>docker create CONTAINER_NAME</code> 命令来新建一个容器，新建的容器处于停止状态，可以使用<code>docker start &lt;CONTAINER_ID&gt;</code>命令来启动它。</p><h4 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h4><p>启动容器有两种方式：</p><ul><li>将在终止状态的容器重新启动，命令为  <code>docker start CONTAINER</code></li><li>基于镜像创建并运行一个新的容器，命令为 <code>docker run CONTAINER</code> ， 等价于先执行<code>docker create</code>，再执行<code>docker start</code>。</li></ul><p>可选参数：</p><ul><li><code>-t</code>，让Docker分配一个伪终端并绑定到容器的标准输入上</li><li><code>-i</code>，则让容器的标准输入保持打开</li><li><code>-d</code>，会让Docker容器在后台以守护形式运行，获取容器输出信息</li></ul><p>例如 <code>docker run -t -i ubuntu:14.04 /bin/bash</code> 会启动一个bash终端，允许用户进行交互，举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@eac23878c8bf:/# pwd</span><br><span class="line">/</span><br><span class="line">root@eac23878c8bf:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@eac23878c8bf:/# ps</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">     1 pts/0    00:00:00 bash</span><br><span class="line">    15 pts/0    00:00:00 ps</span><br><span class="line">root@eac23878c8bf:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost test]# docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello word; sleep 1; done&quot;</span><br><span class="line">2105fbb444b3b028a1b26ec5879d8d282ccc2fa7d0a9776a8a86e808d3414843</span><br><span class="line">[root@localhost test]# docker ps -a</span><br><span class="line">CONTAINER ID     IMAGE            COMMAND                  CREATED           STATUS             PORTS     NAMES</span><br><span class="line">2105fbb444b3     ubuntu:14.04     &quot;/bin/sh -c &#x27;while...&quot;   11 seconds ago    Up 10 seconds                confident_payne</span><br><span class="line">eac23878c8bf     ubuntu:14.04     &quot;/bin/bash&quot;              2 minutes ago     Exited (0) 2 minutes ago     adoring_shockley</span><br><span class="line">[root@localhost test]# docker logs 2105fbb444b3</span><br><span class="line">hello word</span><br><span class="line">hello word</span><br><span class="line">hello word</span><br><span class="line">hello word</span><br><span class="line">...</span><br><span class="line">[root@localhost test]# docker stop 2105</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a class="markdownIt-Anchor" href="#停止容器"></a> 停止容器</h4><p><code>docker stop  </code>命令用于停止一个正在运行的容器</p><p>可选参数：</p><ul><li><code>-t</code>， 指定停止容器前等待的秒数。默认值是10秒</li></ul><p>扩展：</p><p><code>docker ps -a -q</code> 命令为查看所有(<code>-a</code>)的容器ID(<code>-q</code>)，这条命令也可以提供给另外的命令组合使用，如下：</p><p><code>docker stop $(docker ps -a -q)</code> ，命令为停止所有容器</p><p><code>docker restart</code> 将一个运行态的容器终止然后再重新启动它。</p><h4 id="进入容器-2"><a class="markdownIt-Anchor" href="#进入容器-2"></a> 进入容器</h4><p>在运行容器的时候使用<code>-d</code>参数，容器会进入后台，用户无法看到容器中的信息，需要通过命令来进入到容器中进行操作。</p><p><code>docker attach CONTAINER</code> 它允许我们连接到正在运行的容器并在其中运行命令。可以使用它来在容器内部执行操作，例如查看容器的日志或运行容器内的应用程序。这条命令将会打开一个新的终端窗口，可以在容器内部运行命令。要退出容器，可以使用快捷键 <code>Ctrl+P</code> 和 <code>Ctrl+Q</code>。</p><p>注意，<code>docker attach</code> 命令只能用于连接正在运行的容器。如果要连接已停止的容器，我们需要使用 <code>docker exec</code> 命令。</p><p><code>docker exec</code> 命令的语法如下：</p><p><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></p><p>其中，<code>CONTAINER</code> 是要连接的容器的名称或 ID，<code>COMMAND</code> 是要在容器内部运行的命令，<code>ARG</code> 是命令的参数。</p><p>例如，假设想要在名为 <code>my_container</code> 的容器内部运行命令 <code>ls -l</code>，可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec my_container ls -l</span><br></pre></td></tr></table></figure><p>要在容器中使用 bash，举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# docker exec -ti a0bb97c292d1 /bin/bash</span><br><span class="line">root@a0bb97c292d1:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@a0bb97c292d1:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h4 id="删除容器-2"><a class="markdownIt-Anchor" href="#删除容器-2"></a> 删除容器</h4><p>可以使用<code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code>命令删除处于终止状态的容器。</p><p>可选参数：</p><ul><li><code>-f</code>，–force=false 强行终止并删除一个运行中的容器</li><li><code>-l</code>，–link=false 删除容器的连接，但保留容器</li><li><code>-v</code>，–volumes=false 删除容器挂载的数据卷</li></ul><p>扩展</p><p><code>docker rm $(docker ps -a -q)</code>，删除所有容器</p><h4 id="导入导出"><a class="markdownIt-Anchor" href="#导入导出"></a> 导入导出</h4><p>导出容器是指导出一个已经创建好的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用<code>docker export CONTAINER</code>命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# docker run -tid ubuntu:14.04</span><br><span class="line">547e74d47ec3eb30736aee22c1b7bf2acd6e71470a1ade4561007a10b3b14a36</span><br><span class="line">[root@localhost test]# docker ps -a</span><br><span class="line">CONTAINER ID     IMAGE            COMMAND          CREATED          STATUS           PORTS       NAMES</span><br><span class="line">547e74d47ec3     ubuntu:14.04     &quot;/bin/bash&quot;      6 seconds ago    Up 5 seconds                 unruffled_jennings</span><br><span class="line">[root@localhost test]# docker export 547 &gt; test.tar</span><br><span class="line">[root@localhost test]# ls</span><br><span class="line">test.tar </span><br></pre></td></tr></table></figure><p>导出的文件又可以使用<code>docker import</code>命令导入，成为镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls</span><br><span class="line">test.tar</span><br><span class="line">[root@localhost test]# cat test.tar | docker import - test/ubuntu:v1.0</span><br><span class="line">sha256:1ab7c63a882a9bc13ff4673081a237ba8785d47ba69458bfe976c0e5fc7b9c99</span><br><span class="line">[root@localhost test]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">test/ubuntu           v1.0                1ab7c63a882a        22 seconds ago      175MB</span><br><span class="line">ubuntu                14.04-server        ae63a9e87332        2 hours ago         215MB</span><br><span class="line">securityweekly/test   latest              68ceff3107a8        3 hours ago         188MB</span><br><span class="line">ubuntu                14.04               dea1945146b9        6 weeks ago         188MB</span><br></pre></td></tr></table></figure><h3 id="其他命令"><a class="markdownIt-Anchor" href="#其他命令"></a> 其他命令</h3><ul><li><p><code>docker --help</code> 查看帮助命令</p></li><li><p><code>docker logs</code>：用于查看容器的日志输出。</p></li><li><p><code>docker volume ls</code> 查看 volume 列表</p></li><li><p><code>docker network ls</code> 查看网络列表</p></li></ul><p>这只是一些常用的 Docker 命令，Docker 还有很多其他的命令和功能。有关 Docker 命令的完整列表，可以参考 Docker 的<a href="https://docs.docker.com/engine/reference/commandline/run/">官方文档</a></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p><a href="https://docker.easydoc.net">Docker 快速入门</a></p><p><a href="https://www.jianshu.com/p/f272726db9c5">Docker安装与基本操作</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;Docker 是一个开源的容器管理平台，它允许开发人员在轻量级容器中运行应用程序。容器是一种轻量级的虚拟化技术，它允许将应用程序及其依赖项打包在</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="容器" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="容器" scheme="http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://blog.heyb.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>「RDS」华为云 RDS 恢复误删MySQL数据恢复流程</title>
    <link href="http://blog.heyb.top/2022/12/01/[rds]-huawei-cloud-rds-recovery-process-for-mistakenly-deleting-mysql-data.html"/>
    <id>http://blog.heyb.top/2022/12/01/[rds]-huawei-cloud-rds-recovery-process-for-mistakenly-deleting-mysql-data.html</id>
    <published>2022-11-30T16:00:00.000Z</published>
    <updated>2022-12-25T14:31:45.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>本文是记录 2021年4月25日云数据恢复操作</p><p>大致流程是通过 binlog 恢复 mysql 中的数据，我们购买的是华为云 RDS，所以直接在 RDS 进行操作。</p><p>RDS 它的恢复流程是会先将数据全量恢复到 指定日期，再重放 binlog 操作到指定时间点。</p><h2 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h2><ol><li><p>登录华为云服务器管理后台</p></li><li><p>在「关注资源」（或者左边菜单栏） - 选中 「云数据库 RDS」</p></li><li><p>在 RDS 控制台中选中 「备份管理」，下载<em><strong>两个备份数据</strong></em>。一个是今天0425日的（是我服务器停机后手动备份的，时间点为：2021/04/25 14:57:39）， 一个是昨日RDS 自动备份的（时间点为2021/04/24 20:51:38）</p></li><li><p>在 RDS 控制台中选中「数据库管理服务（DAS）」，此时会新打开一个 DAS窗口</p></li><li><p>在 DAS 控制台菜单中选中「开发工具」，点击实例名称，如rds-001(192.168.10.20</p></li><li><p>在上菜单栏中选择「binlog」标签 =&gt; 「归档日志」-「起止时间」- 输入具体日期，如 2021/04/24 21:30:00 到 2021/04/24  23:59:59</p></li><li><p>点击解析日志，再点查看日志详细内容，找到我们具体注释操作（动作描述为数据表 xxx 发生 DDL 操作）的具体时间（变更时间）， 举个例子为 22 点整，我们记录下来，届时要回滚的操作就是要指定到这个**#时间点#**</p></li><li><p>回到 RDS 窗口，在 RDS 控制台中选中 「实例管理」，点击实例的名称 - 如rds -001 296ce7f544bd4e889d2e38b934bf80cain01 进入到具体实例的详情中</p></li><li><p>在左侧菜单选择「备份恢复」，选择 「binlog备份」标签</p></li><li><p>「恢复到指定时间点」是指整个库一起恢复，「表级时间点恢复」可以勾选具体表来进行恢复，我们依据需求进行选择，时间点设置到我们进行 DDL操作前的 <strong>#时间点#</strong>，然后进行恢复</p></li><li><p>恢复后我们要恢复对误操作时间点之后的系统操作（即普通用户操作），有两种方法，一种是直接比对时间点后的数据（如根据时间去查询数据，然后比对两份数据），另外一种是在 DAS 中解析 binlog，依据日志对数据重新进行设置值，直至最终恢复完毕</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;本文是记录 2021年4月25日云数据恢复操作&lt;/p&gt;
&lt;p&gt;大致流程是通过 binlog 恢复 mysql 中的数据，我们购买的是华为云 RD</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="RDS" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/"/>
    
    <category term="华为云" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="华为云" scheme="http://blog.heyb.top/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    
    <category term="RDS" scheme="http://blog.heyb.top/tags/RDS/"/>
    
  </entry>
  
  <entry>
    <title>「Go」Go-搭建IM即时通讯系列文章1-搭建基础框架</title>
    <link href="http://blog.heyb.top/2022/11/27/go-go---building-im-instant-messaging-series-1---building-the-infrastructure.html"/>
    <id>http://blog.heyb.top/2022/11/27/go-go---building-im-instant-messaging-series-1---building-the-infrastructure.html</id>
    <published>2022-11-27T15:06:20.000Z</published>
    <updated>2022-12-25T14:29:19.675Z</updated>
    
    <content type="html"><![CDATA[<p>通过「Go」Go 组件系列文章，我们已经了解了一些组件的基本使用。下面我们将以实现登录功能为目标来完整的搭建一个基础框架。</p><p>和上述步骤一样，我们从配置项搭建开始，在  <code>项目根目录/src/main/</code> 目录下新建一个 <code>config</code> 目录，用于存放配置文件。在该目录下新建 <code>database</code>、<code>settings</code> 目录，并分别新建 <code>database.go</code> 和 <code>settings.go</code> 文件，用做初始化读取配置（viper）以及初始化数据库操作（grom）。</p><h2 id="viper-读取配置"><a class="markdownIt-Anchor" href="#viper-读取配置"></a> Viper 读取配置</h2><p><code>settings.go</code> 提供了读取配置并设置到全局实体提供给其他类使用，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package settings</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">此文件用于读取配置文件 app.yml，并设置到对应实体，以提供给其他文件使用。</span></span><br><span class="line"><span class="comment">因此该文件需要优先进行初始化操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义实体装载配置文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Settings 设置</span></span><br><span class="line"><span class="keyword">type</span> Settings <span class="keyword">struct</span> &#123;</span><br><span class="line">Server   Server   <span class="string">`mapstructure:&quot;server&quot;`</span></span><br><span class="line">Database Database <span class="string">`mapstructure:&quot;db&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Setting = &amp;Settings&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server 服务</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Url 地址</span></span><br><span class="line">Url <span class="type">string</span> <span class="string">`mapstructure:&quot;url&quot;`</span></span><br><span class="line"><span class="comment">// Port 端口</span></span><br><span class="line">Port <span class="type">int</span> <span class="string">`mapstructure:&quot;port&quot;`</span></span><br><span class="line"><span class="comment">// ReadTimeout 读取超时</span></span><br><span class="line">ReadTimeout time.Duration <span class="string">`mapstructure:&quot;readTimeout&quot;`</span></span><br><span class="line"><span class="comment">// WriteTimeout 写入超时</span></span><br><span class="line">WriteTimeout time.Duration <span class="string">`mapstructure:&quot;writeTimeout&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ServerSetting = &amp;Server&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Database 数据库</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Type 类型</span></span><br><span class="line">Type        <span class="type">string</span> <span class="string">`mapstructure:&quot;type&quot;`</span></span><br><span class="line">User        <span class="type">string</span> <span class="string">`mapstructure:&quot;user&quot;`</span></span><br><span class="line">Password    <span class="type">string</span> <span class="string">`mapstructure:&quot;password&quot;`</span></span><br><span class="line">Host        <span class="type">string</span> <span class="string">`mapstructure:&quot;host&quot;`</span></span><br><span class="line">Name        <span class="type">string</span> <span class="string">`mapstructure:&quot;name&quot;`</span></span><br><span class="line">TablePrefix <span class="type">string</span> <span class="string">`mapstructure:&quot;prefix&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DatabaseSetting = &amp;Database&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup 设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setup</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 配置文件名(不带扩展名，即 app.yml 只需要app这部分)</span></span><br><span class="line">viper.SetConfigName(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"><span class="comment">// 如果配置文件名称中没有扩展名，则为必填项</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line"><span class="comment">// 在其中查找配置文件的路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;src/resource/&quot;</span>)</span><br><span class="line"><span class="comment">// 查找并读取配置文件</span></span><br><span class="line">err := viper.ReadInConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 处理读取配置文件时出现的错误</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;读取配置异常: %w&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;初始化配置文件成功&quot;</span>)</span><br><span class="line">viper.WatchConfig()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将配置信息解析为实体</span></span><br><span class="line">err = viper.UnmarshalKey(<span class="string">&quot;settings&quot;</span>, Setting)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;读取配置异常，解析失败: %w&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为全局变量，后续有其他配置则新增实体和变量即可</span></span><br><span class="line">ServerSetting = &amp;Setting.Server</span><br><span class="line">DatabaseSetting = &amp;Setting.Database</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line"><span class="comment">// 超时时间单位设置为秒</span></span><br><span class="line">ServerSetting.ReadTimeout = ServerSetting.ReadTimeout * time.Second</span><br><span class="line">ServerSetting.WriteTimeout = ServerSetting.WriteTimeout * time.Second</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该类主要操作</p><ol><li>读取配置文件并解析为实体</li><li>设置全局变量提供给其他类使用</li><li>设置初始值</li></ol><h2 id="gorm-连接数据库"><a class="markdownIt-Anchor" href="#gorm-连接数据库"></a> Gorm 连接数据库</h2><p><code>database.go</code> 提供了初始化数据库连接的操作，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> database</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm/logger&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/config/settings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DBS 定义全局变量，提供给其他方法调用</span></span><br><span class="line"><span class="keyword">var</span> DBS *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup 初始化数据库连接</span></span><br><span class="line"><span class="comment">// https://gorm.io/zh_CN/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setup</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="comment">//定义连接路径</span></span><br><span class="line">dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">settings.DatabaseSetting.User,</span><br><span class="line">settings.DatabaseSetting.Password,</span><br><span class="line">settings.DatabaseSetting.Host,</span><br><span class="line">settings.DatabaseSetting.Name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库，并设置基本的配置</span></span><br><span class="line"><span class="comment">// 日志</span></span><br><span class="line">newLogger := logger.New(</span><br><span class="line">log.New(os.Stdout, <span class="string">&quot;\r\n&quot;</span>, log.LstdFlags), <span class="comment">// io writer（日志输出的目标，前缀和日志包含的内容）</span></span><br><span class="line">logger.Config&#123;</span><br><span class="line"><span class="comment">// 慢 SQL 阈值</span></span><br><span class="line">SlowThreshold: time.Second,</span><br><span class="line"><span class="comment">// 日志级别</span></span><br><span class="line">LogLevel: logger.Silent,</span><br><span class="line"><span class="comment">// 忽略ErrRecordNotFound（记录未找到）错误</span></span><br><span class="line">IgnoreRecordNotFoundError: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 彩色打印</span></span><br><span class="line">Colorful: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DBS, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;</span><br><span class="line">Logger: newLogger,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;初始化数据库异常: %w&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通用数据库对象 sql.DB ，然后使用其提供的功能</span></span><br><span class="line">sqlDB, err := DBS.DB()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于设置连接池中空闲连接的最大数量。</span></span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 设置打开数据库连接的最大数量。</span></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了连接可复用的最大时间。</span></span><br><span class="line">sqlDB.SetConnMaxLifetime(time.Hour)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该类主要操作</p><ol><li>读取数据库连接配置</li><li>初始化数据库连接</li><li>定义了 慢 SQL 日志配置</li><li>设置了数据库连接池配置</li><li>返回全局变量DBS供其他类使用</li></ol><h2 id="init-加载配置"><a class="markdownIt-Anchor" href="#init-加载配置"></a> Init 加载配置</h2><p>在  <code>项目根目录/src/main/config</code> 目录下新建 <code>init.go</code> 文件，用于初始化上面两个配置项。</p><p><code>init.go</code> 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;star-im/src/main/config/database&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/config/redis&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/config/settings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Initial</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化配置</span></span><br><span class="line">settings.Setup()</span><br><span class="line"><span class="comment">// 初始化数据库连接</span></span><br><span class="line">database.Setup()</span><br><span class="line">  <span class="comment">// 后续有其他配置项可以在下面添加……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该文件到时候放在main方法中执行即可</p><h2 id="main-程序入口"><a class="markdownIt-Anchor" href="#main-程序入口"></a> Main 程序入口</h2><p>在  <code>项目根目录</code> 下新建一个 <code>main.go</code> 作为我们作为http程序主入口，参考 <code>gin</code> 章节初始化<code>gin</code></p><p><code>main.go</code> 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/config&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/config/settings&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/routers&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// init 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化配置项</span></span><br><span class="line">config.Initial()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line">routersInit := routers.Setup()</span><br><span class="line"><span class="comment">// 读取超时</span></span><br><span class="line">readTimeout := settings.ServerSetting.ReadTimeout</span><br><span class="line"><span class="comment">// 写入超时</span></span><br><span class="line">writeTimeout := settings.ServerSetting.WriteTimeout</span><br><span class="line"><span class="comment">// 端口</span></span><br><span class="line">endPoint := fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, settings.ServerSetting.Port)</span><br><span class="line"><span class="comment">// 最大 header 数</span></span><br><span class="line">maxHeaderBytes := <span class="number">1</span> &lt;&lt; <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 http Server</span></span><br><span class="line">server := &amp;http.Server&#123;</span><br><span class="line">Addr:           endPoint,</span><br><span class="line">Handler:        routersInit,</span><br><span class="line">ReadTimeout:    readTimeout,</span><br><span class="line">WriteTimeout:   writeTimeout,</span><br><span class="line">MaxHeaderBytes: maxHeaderBytes,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;[info] 启动http服务器侦听 %s&quot;</span>, endPoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">err := server.ListenAndServe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 启动异常</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;启动服务异常：%w&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该类主要操作</p><ol><li>初始化配置</li><li>初始化路由配置以及服务基础设置</li></ol><p><code>routers.Setup()</code> ，路由等信息单独放在另外一个目录 <code>routers</code>中来统一管理。</p><h2 id="router-路由配置"><a class="markdownIt-Anchor" href="#router-路由配置"></a> router 路由配置</h2><p>在  <code>项目根目录/src/main/</code> 目录下新建一个 <code>routers</code> 目录，并按照层级建立 <code>api/v1</code> 两个目录，用于存放路由接口。v1<br>表示接口版本号，方便后续迭代接口版本。</p><p>在 <code>项目根目录/src/main/routers/api</code> 目录下创建 <code>health.go</code> ，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> api</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/common/app&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ping 接口连通性测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接返回成功结果</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: <span class="string">&quot;成功&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类主要做连通性测试，因此直接返回json成功数据</p><p>在 <code>项目根目录/src/main/routers</code>  目录下创建 <code>router.go</code> 文件用于初始化路由配置，代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/handler&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/routers/api&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup 初始化路由</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setup</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 记录到文件</span></span><br><span class="line">f, _ := os.Create(<span class="string">&quot;gin.log&quot;</span>)</span><br><span class="line">gin.DefaultWriter = io.MultiWriter(f)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用中间件</span></span><br><span class="line">  <span class="comment">// 统一日志</span></span><br><span class="line">r.Use(gin.Logger())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要鉴权</span></span><br><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, api.Ping)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类主要操作</p><ol><li>初始化路由设置</li><li>指定记录日志到文件</li><li>指定具体的路由地址以及请求方式和响应函数</li></ol><p>这时候我们启动根目录下的 <code>main</code>函数即可启动服务，通过浏览器访问：<a href="http://localhost:8081/ping">http://localhost:8081/ping</a> 可以得到返回值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>到这一步我们已经能够提供一个提供基础访问的应用，后续我们继续完善应用的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过「Go」Go 组件系列文章，我们已经了解了一些组件的基本使用。下面我们将以实现登录功能为目标来完整的搭建一个基础框架。&lt;/p&gt;
&lt;p&gt;和上述步骤一样，我们从配置项搭建开始，在  &lt;code&gt;项目根目录/src/main/&lt;/code&gt; 目录下新建一个 &lt;code&gt;con</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>「Go」Go-搭建IM即时通讯系列文章2-统一返回值及异常处理</title>
    <link href="http://blog.heyb.top/2022/11/27/go-go---building-im-instant-messaging-series-2---unified-return-values-and-exception-handling.html"/>
    <id>http://blog.heyb.top/2022/11/27/go-go---building-im-instant-messaging-series-2---unified-return-values-and-exception-handling.html</id>
    <published>2022-11-27T15:06:20.000Z</published>
    <updated>2022-12-25T14:29:33.480Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发过程中，通过定义统一返回值还可以提高框架的可用性和可维护性，让开发人员更容易理解和使用框架中的各种功能。同时统一异常处理能够帮助我们更好地控制程序的流程，能够让我们更好地捕获异常并作出相应的处理。这样做可以帮助我们减少代码重复，提高代码的可读性和可维护性。</p><h2 id="统一返回值"><a class="markdownIt-Anchor" href="#统一返回值"></a> 统一返回值</h2><p>我们规范约定返回值参数有利于我们对数据进行管理以及提升前后端开发的效率。</p><p>在  <code>项目根目录/src/main/</code> 目录下新建一个<code>common/app</code> 层级目录，并在 <code>app </code>目录下分别建立 <code>code.go</code>、<code>msg.go</code>、 <code>response.go</code> 用于存放 返回值、返回消息、统一返回值的实体对象。</p><p><code>code.go</code> 主要定义返回值常量，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> app</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  <span class="comment">// 成功使用 200</span></span><br><span class="line">SUCCESS = http.StatusOK</span><br><span class="line">  <span class="comment">// 异常使用 -1</span></span><br><span class="line">ERROR   = <span class="number">-1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>msg.go</code> 主要定义返回值常量对应的消息内容，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> app</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageMap 返回值常量对应的消息内容，消息集合：&#123;消息码，消息内容&#125;</span></span><br><span class="line"><span class="keyword">var</span> MessageMap = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line">SUCCESS: <span class="string">&quot;成功&quot;</span>,</span><br><span class="line">ERROR:   <span class="string">&quot;失败&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetMsg 根据代码获取返回信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMsg</span><span class="params">(code <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">msg, ok := MessageMap[code]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MessageMap[ERROR]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>response.go</code> 主要定义返回值的对象，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> app</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response 响应对象</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 响应编码</span></span><br><span class="line">Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line"><span class="comment">// 返回消息</span></span><br><span class="line">Msg <span class="type">string</span> <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line"><span class="comment">// 返回数据</span></span><br><span class="line">Data <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Res 设置 gin.JSON 的内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Res</span><span class="params">(c *gin.Context, httpCode, errCode <span class="type">int</span>, data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">c.JSON(httpCode, Response&#123;</span><br><span class="line">Code: errCode,</span><br><span class="line">Msg:  GetMsg(errCode),</span><br><span class="line">Data: data,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Success 返回成功结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Success</span><span class="params">(c *gin.Context, data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">Res(c, http.StatusOK, SUCCESS, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error 返回错误结果，异常结果放在统一异常处理 handler中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Error</span><span class="params">(c *gin.Context, data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">Res(c, http.StatusOK, ERROR, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时我们可以修改 <code>src/main/routers/api/health.go</code> 中返回的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> api</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/common/app&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ping 接口连通性测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接返回成功结果</span></span><br><span class="line">app.Success(c, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候我们通过浏览器访问 <a href="http://localhost:8081/ping%EF%BC%8C%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%E8%BF%94%E5%9B%9E%EF%BC%9A">http://localhost:8081/ping，得到如下返回：</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候我们就可以根据不同的返回值进行不同的业务处理了</p><h2 id="统一异常处理"><a class="markdownIt-Anchor" href="#统一异常处理"></a> 统一异常处理</h2><p>我们需要统一处理系统的异常信息并让异常结果也显示为统一的返回结果对象，那么需要进行统一异常处理。</p><p>在  <code>项目根目录/src/main/</code> 目录下新建一个 <code>handler</code> 目录，并在目录下新建一个 <code>exception.go</code> 文件，用于处理异常信息</p><p><code>exception.go</code> 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/common/app&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recover 注意 Recover 要尽量放在router.User的第一个被加载</span></span><br><span class="line"><span class="comment">// 如不是的话，在recover前的中间件或路由，将不能被拦截到</span></span><br><span class="line"><span class="comment">// 程序的原理是：</span></span><br><span class="line"><span class="comment">// 1.请求进来，执行recover</span></span><br><span class="line"><span class="comment">// 2.程序异常，抛出panic</span></span><br><span class="line"><span class="comment">// 3.panic被 recover捕获，返回异常信息，并Abort,终止这次请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recover</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> r != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//打印错误堆栈信息</span></span><br><span class="line">log.Printf(<span class="string">&quot;panic: %v\n&quot;</span>, r)</span><br><span class="line">debug.PrintStack()</span><br><span class="line"><span class="comment">//封装通用json返回</span></span><br><span class="line">c.JSON(http.StatusOK, app.Response&#123;</span><br><span class="line">Code: app.ERROR,</span><br><span class="line">Msg:  ErrorToString(r),</span><br><span class="line">Data: <span class="literal">nil</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//终止后续接口调用，不加的话recover到异常后，还会继续执行接口里后续代码</span></span><br><span class="line">c.Abort()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载完 defer recover，继续后续接口调用</span></span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrorToString recover错误，转string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ErrorToString</span><span class="params">(r <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">error</span>:</span><br><span class="line"><span class="keyword">return</span> v.Error()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> r.(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该类主要捕获panic异常，并返回 json 信息给客户端</p><p>在 <code>src/main/routers/router.go</code> 文件中添加如下代码即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一异常处理</span></span><br><span class="line">r.Use(handler.Recover)</span><br></pre></td></tr></table></figure><p>此时我们可以修改<code>router</code>中 <code>/ping</code> 的方法来测试结果</p><p>将 <code>src/main/routers/router.go</code> 中如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, api.Ping)</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 无意抛出 panic</span></span><br><span class="line"><span class="keyword">var</span> slice = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice[<span class="number">6</span>] = <span class="number">6</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后重启项目，通过浏览器访问 <a href="http://localhost:8081/ping%EF%BC%8C%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%E8%BF%94%E5%9B%9E%EF%BC%9A">http://localhost:8081/ping，得到如下返回：</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;runtime error: index out of range [6] with length 5&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>现在我们得到的就是统一的异常返回值，这里的 msg 可以根据需要再进行修改。</p><p>在业务中我们可以通过判断业务逻辑，再进行抛出异常，如将刚才函数中的内容修改为如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 抛出 panic, true这里可以改为自己的业务处理逻辑</span></span><br><span class="line">   <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;抛出了指定的异常信息&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过浏览器访问 <a href="http://localhost:8081/ping%EF%BC%8C%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%E8%BF%94%E5%9B%9E%EF%BC%9A">http://localhost:8081/ping，得到如下返回：</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;抛出了指定的异常信息&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到成功捕获了 panic 抛出的异常信息，这可以很方便我们做业务逻辑的时候处理异常。（测试成功后记得把ping的函数恢复回之前的）</p><p>gin router 中也提供了针对 NoRoute 和 NoMethod 的处理，在 <code>router.go</code> 中添加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理404</span></span><br><span class="line">r.NoRoute(handler.HandleNotFound)</span><br><span class="line">r.NoMethod(handler.HandleNotFound)</span><br></pre></td></tr></table></figure><p>在 <code>src/main/handler/exception.go</code> 中添加处理方法，直接返回处理结果即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleNotFound</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 我这里使用的是统一返回值</span></span><br><span class="line">app.ErrorWithCode(c, app.NOT_FOUND, <span class="literal">nil</span>)</span><br><span class="line">  <span class="comment">// // 你们也可以直接使用普通的返回结果，如下</span></span><br><span class="line">  <span class="comment">// c.JSON(http.StatusOK, gin.H&#123;</span></span><br><span class="line"><span class="comment">//&quot;msg&quot;: &quot;找不到资源&quot;,</span></span><br><span class="line">  <span class="comment">//    &quot;code&quot;: 404,</span></span><br><span class="line">  <span class="comment">//    &quot;data&quot;: &quot;&quot;</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="swag-接口文档"><a class="markdownIt-Anchor" href="#swag-接口文档"></a> swag 接口文档</h2><p>Swagger是一种API框架，它可以为REST APIs定义、生成、测试和文档化。它使用一种名为Swagger元数据的特殊格式来描述API，并使用Swagger UI来展示API的定义。这使得开发人员可以在不离开API文档的情况下测试API，并且可以轻松地为API创建文档。</p><p>我们引入 Swagger 来生成接口文档，方便统一管理接口及调试。</p><p>相关链接：</p><p><a href="https://github.com/swaggo/swag/blob/master/README_zh-CN.md">GitHub</a></p><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/swaggo/swag/cmd/swag@latest</span><br></pre></td></tr></table></figure><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swag init -o &quot;src/main/docs&quot;</span><br></pre></td></tr></table></figure><ul><li>-o 为 output，指定输出目录，默认为“./docs”</li></ul><p>其他更多文章参考 <a href="https://github.com/swaggo/swag/blob/v1.8.8/README_zh-CN.md">GitHub中文文档</a></p><p>在主程序入口 <code>main.go</code> 中可以添加如下注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @title           Star-IM</span></span><br><span class="line"><span class="comment">// @version         1.0</span></span><br><span class="line"><span class="comment">// @description     即时通讯接口文档</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>src/main/routers/api/health.go</code> 文件中添加如下注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ping</span></span><br><span class="line"><span class="comment">// @Summary      健康检查</span></span><br><span class="line"><span class="comment">// @Description  接口连通性测试</span></span><br><span class="line"><span class="comment">// @Tags         测试</span></span><br><span class="line"><span class="comment">// @Success      200  &#123;object&#125;  app.Response</span></span><br><span class="line"><span class="comment">// @Router       /ping [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>src/main/routers/router.go</code> 加入swagger接口文档的访问，并引入指定了目录的swagger文件</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">swaggerFiles <span class="string">&quot;github.com/swaggo/files&quot;</span></span><br><span class="line">ginSwagger <span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">_ <span class="string">&quot;star-im/src/main/docs&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/handler&quot;</span></span><br><span class="line"><span class="string">&quot;star-im/src/main/routers/api&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup 初始化路由</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setup</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 记录到文件</span></span><br><span class="line">f, _ := os.Create(<span class="string">&quot;gin.log&quot;</span>)</span><br><span class="line">gin.DefaultWriter = io.MultiWriter(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用中间件</span></span><br><span class="line"><span class="comment">// 统一异常处理</span></span><br><span class="line">r.Use(handler.Recover)</span><br><span class="line"><span class="comment">// 统一日志</span></span><br><span class="line">r.Use(gin.Logger())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要鉴权</span></span><br><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, api.Ping)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要变更内容为</p><ul><li><code>import  _ &quot;star-im/src/main/docs&quot;</code></li><li><code>import swaggerFiles &quot;github.com/swaggo/files&quot;</code></li><li><code>import ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</code></li><li><code>r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))</code></li></ul><h4 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h4><p>通过浏览器访问 <a href="http://localhost:8081/swagger/index.html#/">http://localhost:8081/swagger/index.html#/</a> 可以进入到swagger 接口文档的管理界面</p><p>至此，当前目录结构为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── doc</span><br><span class="line">│   └── build</span><br><span class="line">│       └── 1-framwork.md</span><br><span class="line">├── gin.log</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── common</span><br><span class="line">    │   │   └── app</span><br><span class="line">    │   │       ├── code.go</span><br><span class="line">    │   │       ├── msg.go</span><br><span class="line">    │   │       └── response.go</span><br><span class="line">    │   ├── config</span><br><span class="line">    │   │   ├── database</span><br><span class="line">    │   │   │   └── database.go</span><br><span class="line">    │   │   ├── init.go</span><br><span class="line">    │   │   └── settings</span><br><span class="line">    │   │       └── settings.go</span><br><span class="line">    │   ├── docs</span><br><span class="line">    │   │   ├── docs.go</span><br><span class="line">    │   │   ├── swagger.json</span><br><span class="line">    │   │   └── swagger.yaml</span><br><span class="line">    │   ├── handler</span><br><span class="line">    │   │   └── exception.go</span><br><span class="line">    │   ├── models</span><br><span class="line">    │   │   └── model.go</span><br><span class="line">    │   ├── routers</span><br><span class="line">    │   │   ├── api</span><br><span class="line">    │   │   │   ├── health.go</span><br><span class="line">    │   │   │   └── v1</span><br><span class="line">    │   │   └── router.go</span><br><span class="line">    │   └── util</span><br><span class="line">    ├── resource</span><br><span class="line">    │   └── app.yml</span><br><span class="line">    └── test</span><br><span class="line">        └── pkg</span><br><span class="line">            ├── test_gin.go</span><br><span class="line">            ├── test_gorm.go</span><br><span class="line">            ├── test_jwt.go</span><br><span class="line">            ├── test_redis.go</span><br><span class="line">            └── test_viper.go</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在软件开发过程中，通过定义统一返回值还可以提高框架的可用性和可维护性，让开发人员更容易理解和使用框架中的各种功能。同时统一异常处理能够帮助我们更好地控制程序的流程，能够让我们更好地捕获异常并作出相应的处理。这样做可以帮助我们减少代码重复，提高代码的可读性和可维护性。&lt;/p&gt;</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>「Windows」Windows “因为在此系统上禁止运行脚本”解决办法</title>
    <link href="http://blog.heyb.top/2022/11/26/windows-windows-because-running-scripts-on-this-system-is-disabled-solution.html"/>
    <id>http://blog.heyb.top/2022/11/26/windows-windows-because-running-scripts-on-this-system-is-disabled-solution.html</id>
    <published>2022-11-26T09:11:21.000Z</published>
    <updated>2022-12-25T14:31:30.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>最近升级了windows11，然后在系统上安装一些常用工具，遇到了如下的问题。</p><blockquote><p>nrm : 无法加载文件 C:\Users\用户名\AppData\Roaming\npm\nrm.ps1，因为在此系统上禁止运行脚本。</p></blockquote><p><img src="https://pic1.zhimg.com/80/v2-15867761d0618599271045d3cd2fc838_1440w.jpg" alt="img"></p><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><p>处理方案在提示中有，可以通过访问链接查看：<a href="https://go.microsoft.com/fwlink/?LinkID=135170">https://go.microsoft.com/fwlink/?LinkID=135170</a></p><p>核心是power shell的安全策略，将 nrm 命令视为了不安全脚本，不允许执行。只需要放开权限就行。</p><p>我们通过管理员权限运行power shell，然后输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-9e4bb9af3b778d0d91ce7bdb4eacbdca_1440w.jpg" alt="img"></p><p>选择“是”，就OK了。</p><p>如果要恢复策略则设置则执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-ExecutionPolicy Default</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/493496089">https://zhuanlan.zhihu.com/p/493496089</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;最近升级了windows11，然后在系统上安装一些常用工具，遇到了如下的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nrm : 无法加载文件</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Windows" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Windows/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Windows" scheme="http://blog.heyb.top/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>「Go」Go 组件系列文章4-gin</title>
    <link href="http://blog.heyb.top/2022/11/23/go-go-component-series-4-gin.html"/>
    <id>http://blog.heyb.top/2022/11/23/go-go-component-series-4-gin.html</id>
    <published>2022-11-23T09:54:20.000Z</published>
    <updated>2022-12-25T14:28:59.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Go Gin是一个用Go语言编写的HTTP  Web框架。它旨在提供一个简洁而强大的方式来构建Web应用程序。它因为 <a href="https://github.com/julienschmidt/httprouter">httprouter</a> 的性能提高了40倍。具有良好的性能，并且提供了许多有用的功能，例如路由，中间件，模板渲染等。它还具有很好的扩展性，可以与其他Go库和框架集成使用。</p><p>相关链接：</p><p><a href="https://github.com/gin-gonic/gin">GitHub</a></p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>在  <code>项目根目录/src/test/pkg</code> 目录下新建 <code>test_gin.go</code> 测试文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 默认返回一个已连接日志记录器和恢复中间件的引擎实例。</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 绑定路由 /ping，访问后执行func的方法</span></span><br><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 返回一个 json， 状态值为 200， H的内容为 map[string]</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在0.0.0.0：8080上侦听和服务(对于Windows“为 localhost：8080”)</span></span><br><span class="line">err := r.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;启动服务异常：&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过浏览器访问：<a href="http://localhost:8081/ping">http://localhost:8081/ping</a></p><p>得到如下信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时我们就已经完成了http框架的测试，官方 GitHub<br>文档有提供不同请求方式、参数绑定、文件上传等示例，可以参考学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;Go Gin是一个用Go语言编写的HTTP  Web框架。它旨在提供一个简洁而强大的方式来构建Web应用程序。它因为 &lt;a href=&quot;http</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/tags/Golang/"/>
    
    <category term="gin" scheme="http://blog.heyb.top/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>「Go」Go 组件系列文章3-gorm</title>
    <link href="http://blog.heyb.top/2022/11/22/go-go-component-series-3-gorm.html"/>
    <id>http://blog.heyb.top/2022/11/22/go-go-component-series-3-gorm.html</id>
    <published>2022-11-22T09:22:20.000Z</published>
    <updated>2022-12-25T14:28:47.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>GORM 是一个用于构建 Go 语言应用程序的对象关系映射（ORM）库。它可以帮助开发人员在 Go 语言项目中更轻松地使用数据库。它支持多种数据库，包括 MySQL、PostgreSQL 和 SQLite，并提供了一组简单易用的 API，可以让开发人员使用 Go 语言的结构体来描述数据库表和字段，并通过这些结构体来执行数据库操作。并支持事务、批量操作等等。和<code>Java</code>的<code>hibernate</code>框架相似。</p><p>相关链接：</p><p><a href="https://github.com/go-gorm/gorm">GitHub</a></p><p><a href="https://gorm.io/zh_CN/docs/index.html">GORM中文网</a></p><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>要使用 <a href="http://gorm.io/gorm%EF%BC%8C%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%E5%AE%83%E3%80%82%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8">gorm.io/gorm，首先需要安装它。可以使用</a> Go 语言的包管理工具 go mod 来安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get gorm.io/gorm</span><br><span class="line">go get gorm.io/driver/mysql</span><br></pre></td></tr></table></figure><p>安装完成后，在 Go 语言项目中就可以引入 gorm 包并使用它了。首先，需要创建一个 gorm.DB 类型的变量，用于表示与数据库的连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *gorm.DB</span><br></pre></td></tr></table></figure><p>然后，使用 gorm.Open() 函数来连接到数据库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br></pre></td></tr></table></figure><p>其中 user 和password 为连接数据库的用户和密码，dbname 为库名，后面设置根据自己需求设置。</p><p>以下为完整实例：</p><p>创建数据库的步骤忽略，我们约定数据库名称为star-im，用户名和密码均为root。</p><p>在  <code>项目根目录/src/test/pkg</code> 目录下新建 <code>test_gorm.go</code> 测试文件，代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestProduct 定义一个实体</span></span><br><span class="line"><span class="keyword">type</span> TestProduct <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// gorm.Model 提供了基础实体的定义，包含了id, CreatedAt, UpdatedAt, DeletedAt 字段</span></span><br><span class="line">gorm.Model</span><br><span class="line"><span class="comment">// Name 商品名称</span></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line"><span class="comment">// Price 商品价格</span></span><br><span class="line">Price <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 ORM 框架 —— 连接 MySQL https://github.com/go-gorm/gorm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接信息，字符串中内容分别为：用户名:密码@连接方式(Host:Port)/数据库名?字符集&amp;解析时间&amp;默认时间</span></span><br><span class="line"><span class="comment">// 更多参数详见：https://github.com/go-sql-driver/mysql#parameters</span></span><br><span class="line">dsn := <span class="string">&quot;root:root@tcp(127.0.0.1:3306)/star-im?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line"><span class="comment">// 连接数据库，并设置基本的配置</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果连接有异常则打印</span></span><br><span class="line">fmt.Println(<span class="string">&quot;连接数据库失败：&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迁移 schema，如果数据库该表没有则创建表</span></span><br><span class="line">err = db.AutoMigrate(&amp;TestProduct&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;创建数据库表异常：&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create 创建记录</span></span><br><span class="line"><span class="comment">// 定义实体</span></span><br><span class="line">product := &amp;TestProduct&#123;Name: <span class="string">&quot;奶茶&quot;</span>, Price: <span class="number">100</span>&#125;</span><br><span class="line"><span class="comment">// 创建记录</span></span><br><span class="line">result := db.Create(product)</span><br><span class="line"><span class="comment">// 创建成功后会返回插入数据的主键给实体赋值 ID</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ID为：&quot;</span>, product.ID)</span><br><span class="line">fmt.Println(<span class="string">&quot;如果有异常，则会输出：&quot;</span>, result.Error)</span><br><span class="line">fmt.Println(<span class="string">&quot;返回插入记录的条数：&quot;</span>, result.RowsAffected)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find 查询</span></span><br><span class="line">prod := db.First(&amp;product, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;奶茶&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;查询数:&quot;</span>, prod.RowsAffected)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找后返回实体</span></span><br><span class="line">prod2 := TestProduct&#123;&#125;</span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;奶茶&quot;</span>).First(&amp;prod2)</span><br><span class="line">fmt.Println(<span class="string">&quot;实体：&quot;</span>, prod2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update - 修改</span></span><br><span class="line"><span class="comment">// 将 product 的 price 更新为 200</span></span><br><span class="line">db.Model(&amp;product).Update(<span class="string">&quot;Price&quot;</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// Update - 更新多个字段</span></span><br><span class="line">db.Model(&amp;product).Updates(TestProduct&#123;Price: <span class="number">200</span>, Name: <span class="string">&quot;蛋糕&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 仅更新非零值字段</span></span><br><span class="line">db.Model(&amp;product).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Price&quot;</span>: <span class="number">200</span>, <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;蛋糕&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete - 逻辑删除 product，会修改 deleted_at，标记为删除</span></span><br><span class="line">db.Delete(&amp;product, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行程序后在控制台输出如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ID为： 1</span><br><span class="line">如果有异常，则会输出： &lt;nil&gt;</span><br><span class="line">返回插入记录的条数： 1</span><br><span class="line">查询数: 1</span><br><span class="line">实体： &#123;&#123;1 2022-11-22 16:53:58.969 +0800 CST 2022-11-22 16:53:58.969 +0800 CST &#123;0001-01-01 00:00:00 +0000 UTC false&#125;&#125; 奶茶 100&#125;</span><br></pre></td></tr></table></figure><p>其他更多操作请参考 <a href="https://gorm.io/zh_CN/docs/index.html">GORM中文网</a> ，以及 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a>、<a href="https://gorm.io/zh_CN/docs/generic_interface.html">连接池</a> 、<a href="https://gorm.io/zh_CN/docs/logger.html">日志</a> 等配置可根据自身需求学习设置。我在后续过程中也会讲解并设置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;GORM 是一个用于构建 Go 语言应用程序的对象关系映射（ORM）库。它可以帮助开发人员在 Go 语言项目中更轻松地使用数据库。它支持多种数据</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/tags/Golang/"/>
    
    <category term="gorm" scheme="http://blog.heyb.top/tags/gorm/"/>
    
  </entry>
  
  <entry>
    <title>「Go」Go 组件系列文章2-viper</title>
    <link href="http://blog.heyb.top/2022/11/21/go-go-component-series-2-viper.html"/>
    <id>http://blog.heyb.top/2022/11/21/go-go-component-series-2-viper.html</id>
    <published>2022-11-21T11:41:20.000Z</published>
    <updated>2022-12-25T14:28:33.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Viper是一个完整的Go应用程序配置解决方案，可以用于读取 JSON、TOML、YAML、HCL、env file和Java properties 配置文件。可以使用简单的方法来读取和设置配置值，并且可以设置默认值和类型转换器来确保程序始终能够读取到有效的配置值。</p><p>我们通常将一些配置信息，如数据库的访问路径，端口号等存放在配置文件中方便统一修改。</p><p>在 Java 中通常为 <code>application.yml</code> 或者 <code>applicatiton.properties</code> 文件，然后在 springboot 框架下使<br>用 <code>@ConfigurationProperties(prefix=”setting_name”) </code> 或者 <code>@Value(“valueStr”)</code> 的形式来读取。</p><p>Viper 就是 go 用于做这一部分的工作类库</p><p>相关链接：</p><p><a href="https://github.com/spf13/viper">GitHub</a></p><p><a href="https://pkg.go.dev/github.com/spf13/viper">PKG</a></p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>在项目中打开命令行执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><p>在 <code>项目根目录/src/resource</code> 资源目录下新建一个 <code>app.yml</code> 配置文件，并写入以下配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">settings:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>注：我们现在约定 <code>settings </code> 为配置项根节点，之后新增例如 <code>settings:database</code>之类的节点，则是在settings下新增一个 <code>database </code>节点，而不是重复设置多一个 <code>settings</code>。 其他新增/修改项也遵循此说法。</p><p>如在settings下新增 <code>database </code>内容， 并修改 <code>server</code>下的端口号为9999，示例如下：</p><p>正确示例为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">settings:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p>错误示例为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">settings:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">server:</span>   </span><br><span class="line"><span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line"><span class="attr">settings:</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>在  <code>项目根目录/src/test</code> 目录下新建一个 <code>pkg</code> 目录，用于测试引入的第三方类库。在目录下新建 <code>test_viper.go</code> 测试文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main 方法必须使用 main 包</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要执行的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 配置文件名(不带扩展名，即 app.yml 只需要app这部分)</span></span><br><span class="line">viper.SetConfigName(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"><span class="comment">// 如果配置文件名称中没有扩展名，则为必填项</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line"><span class="comment">// 在其中查找配置文件的路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;src/resource/&quot;</span>)</span><br><span class="line"><span class="comment">// 查找并读取配置文件</span></span><br><span class="line">err := viper.ReadInConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 处理读取配置文件时出现的错误</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;读取配置异常，原因为: %w&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 打印内容到控制台</span></span><br><span class="line">fmt.Println(<span class="string">&quot;初始化 app 配置成功&quot;</span>)</span><br><span class="line"><span class="comment">// 获取配置文件中的参数</span></span><br><span class="line">url := viper.GetString(<span class="string">&quot;settings.server.url&quot;</span>)</span><br><span class="line">port := viper.GetString(<span class="string">&quot;settings.server.port&quot;</span>)</span><br><span class="line"><span class="comment">// 打印参数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;配置中的服务器地址及端口号为：%s:%s&quot;</span>, url, port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行程序后在控制台输出如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化 app 配置成功</span><br><span class="line">配置中的服务器地址及端口号为：localhost:8081</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;Viper是一个完整的Go应用程序配置解决方案，可以用于读取 JSON、TOML、YAML、HCL、env file和Java properti</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/tags/Golang/"/>
    
    <category term="viper" scheme="http://blog.heyb.top/tags/viper/"/>
    
  </entry>
  
  <entry>
    <title>「Go」Go 组件系列文章1-modules</title>
    <link href="http://blog.heyb.top/2022/11/21/go-go-component-series-1-modules.html"/>
    <id>http://blog.heyb.top/2022/11/21/go-go-component-series-1-modules.html</id>
    <published>2022-11-21T11:28:20.000Z</published>
    <updated>2022-12-25T14:28:00.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>模块是一组发布和版本化为单个单元的 Go 包。modules是源代码交换和版本控制的单元。go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。</p><p><code>go mod</code> 是 Go 编程语言中用于管理模块依赖关系的一个命令。</p><p><code>go mod</code> 允许您轻松地在 Go 项目中添加、删除和更新依赖项，以及管理依赖项的版本，以确保兼容性和可重复性。</p><p>go modules 可以理解为 maven / gradle 等工具</p><p><a href="https://github.com/golang/go/wiki/Modules">官方文档及介绍</a></p><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><p>在使用 <code>go mod</code> 前，需要在项目目录下执行 <code>go mod init &lt;name&gt;</code> 命令来初始化模块。</p><p>例如，我们以项目 star-im 为例进行初始化，在项目根目录（star-im/）中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init star-im</span><br></pre></td></tr></table></figure><p>会在根目录生成一个 go.mod 的文件来进行包依赖的管理，其中会包含我们所需要的依赖及版本内容，此外某些依赖后面会有 indirect<br>字样，表示该依赖为传递依赖，也就是非直接依赖。</p><p>其他命令如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go mod &lt;command&gt;</span><br><span class="line">download    download modules to local cache -- 将模块下载到本地缓存</span><br><span class="line">edit        edit go.mod from tools or scripts -- 从工具或脚本编辑 go.mod 以编辑依赖关系</span><br><span class="line">graph       print module requirement graph -- 查看依赖关系图</span><br><span class="line">init        initialize new module in current directory -- 初始化当前目录中的新模块</span><br><span class="line">tidy        add missing and remove unused modules -- 添加缺少的模块并删除未使用的模块</span><br><span class="line">vendor      make vendored copy of dependencies -- 制作依赖项的供应商副本</span><br><span class="line">verify      verify dependencies have expected content -- 验证依赖项是否具有预期内容</span><br><span class="line">why         explain why packages or modules are needed -- 解释为什么需要包或模块</span><br></pre></td></tr></table></figure><p>比较常用的是 <code>init</code>, <code>tidy</code>, <code>edit</code> ，当我们引入依赖包的之后，可以使用 <code>go mod tidy </code><br>来命令来整理依赖模块。其他更多内容可参考：<a href="https://zhuanlan.zhihu.com/p/482014524">go mod使用 | 全网最详细 </a> 或者参考官方文档</p><p>可以使用命令 <code>go list -m -u all </code>来检查可以升级的package</p><p>依赖包仓库地址：<a href="https://pkg.go.dev/%EF%BC%88%E7%9B%B8%E5%BD%93%E4%BA%8Emaven%E7%9A%84">https://pkg.go.dev/（相当于maven的</a> <a href="https://mvnrepository.com/%EF%BC%89%EF%BC%8C%E6%90%9C%E7%B4%A2%E9%9C%80%E8%A6%81%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%AD%A4%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%87%8C%E9%9D%A2%E4%B9%9F%E5%8C%85%E5%90%AB%E4%BA%86%E4%BE%9D%E8%B5%96%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8B%E9%A1%B9%E7%AD%89%E3%80%82">https://mvnrepository.com/），搜索需要的依赖包可以访问此链接，里面也包含了依赖包的使用事项等。</a></p><p>目前 go web 似乎没有比较成型的 web 开发标准，因此我沿用了 Java 的习惯</p><p>在根目录中新增 src 目录，以及 main、resource、test 三个下级目录，用于存放主要程序文件、资源设置文件、测试文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">star-im</span><br><span class="line">  └── src</span><br><span class="line">      ├── main</span><br><span class="line">      ├── resource</span><br><span class="line">      └── test</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;模块是一组发布和版本化为单个单元的 Go 包。modules是源代码交换和版本控制的单元。go命令直接支持使用modules，包括记录和解析对其</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/tags/Golang/"/>
    
    <category term="go mod" scheme="http://blog.heyb.top/tags/go-mod/"/>
    
  </entry>
  
  <entry>
    <title>「Python」Mac 系统切换Python版本</title>
    <link href="http://blog.heyb.top/2022/11/21/python-mac-system-switches-python-version.html"/>
    <id>http://blog.heyb.top/2022/11/21/python-mac-system-switches-python-version.html</id>
    <published>2022-11-21T02:23:00.000Z</published>
    <updated>2022-12-25T14:31:00.631Z</updated>
    
    <content type="html"><![CDATA[<p>从MacOS 12.4 Beta版(21F5048e) 开始，可以通过<code>pyenv</code>在intel和Apple芯片中安装python2。</p><p>例如在M1中安装 2.7.18 版本的 python2。</p><ol><li>首先在系统上安装 pyenv</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载 pyenv</span></span><br><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><ol start="2"><li>接下来，使用 pyenv 安装您想要使用的 Python 版本。例如，要安装 Python 2.7.18 版本，可以在终端中输入以下命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载指定版本</span></span><br><span class="line">pyenv install 2.7.18</span><br></pre></td></tr></table></figure><ol start="3"><li>安装完成后，可以使用 pyenv 的 <code>global</code> 命令来设置当前系统的默认 Python 版本。例如，设置默认版本为 2.7.18，可以在终端中输入以下命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换指定版本</span></span><br><span class="line">pyenv global 2.7.18</span><br></pre></td></tr></table></figure><p>如果执行pyenv不生效可以手动将其加入到系统环境变量（非必须）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入到环境变量</span></span><br><span class="line">export PATH=&quot;$(pyenv root)/shims:$&#123;PATH&#125;&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>最后，可以通过输入 <code>python --version</code> 命令来检查当前使用的 Python 版本是否已经切换成功。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印python版本</span></span><br><span class="line">python --version</span><br></pre></td></tr></table></figure><p>如果一切顺利，将可以看到<code>Python 2.8.18</code>的输出。</p><p>此方法可以与<code>brew install python3</code>方式安装的<code>python3</code>共存。</p><p>如果想要临时切换到其他版本的 Python，可以在执行 Python 命令时，使用 <code>pyenv run</code> 命令来指定要使用的 Python 版本。</p><p>例如，要在当前终端会话中临时使用 Python 3.6.5 版本，可以在终端中输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv run python3.6.5</span><br></pre></td></tr></table></figure><p>如果您想要在当前目录下的所有 Python 脚本中临时使用指定的 Python 版本，可以使用 <code>pyenv local</code> 命令来设置当前目录的 Python 版本。</p><p>如果遇到VS(Visual Studio Code)无法使用<code>code</code>命令，可以参阅博文：<a href="https://www.wyr.me/post/692">《MacOS 12.3 无法正常使用code命令的解决方法》</a>。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p><a href="https://www.wyr.me/post/658">brew安装python2</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从MacOS 12.4 Beta版(21F5048e) 开始，可以通过&lt;code&gt;pyenv&lt;/code&gt;在intel和Apple芯片中安装python2。&lt;/p&gt;
&lt;p&gt;例如在M1中安装 2.7.18 版本的 python2。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先在系统上安装 </summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Python" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Python" scheme="http://blog.heyb.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>「Java」macOS切换JDK版本</title>
    <link href="http://blog.heyb.top/2022/10/25/java-macos-switches-jdk-version.html"/>
    <id>http://blog.heyb.top/2022/10/25/java-macos-switches-jdk-version.html</id>
    <published>2022-10-25T03:59:00.000Z</published>
    <updated>2022-12-25T14:30:41.977Z</updated>
    
    <content type="html"><![CDATA[<p>在 Mac 系统上切换 JDK 版本，可以使用以下步骤：</p><ol><li><p>使用 Finder 或其他文件管理工具，打开系统根目录（通常是 /）。</p></li><li><p>找到 Library/Java/JavaVirtualMachines 目录，该目录下存放着系统安装的所有 JDK 版本。</p></li><li><p>找到您想要使用的 JDK 版本，例如 jdk1.8.0_261.jdk。</p><p>在该 JDK 版本目录下，找到 Contents/Home 目录，该目录下存放着 JDK 安装的核心文件。</p><p>将该目录的完整路径（例如 /Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home）复制到剪贴板。</p><p>也可以通过命令打印 Java home</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">horustech@Horuss-MacBook-Pro booking % /usr/libexec/java_home -V</span><br><span class="line">Matching Java Virtual Machines (7):</span><br><span class="line">    17.0.1 (x86_64) &quot;Eclipse Temurin&quot; - &quot;Eclipse Temurin 17&quot; /Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home</span><br><span class="line">    16.0.2 (x86_64) &quot;Amazon.com Inc.&quot; - &quot;Amazon Corretto 16&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-16.0.2/Contents/Home</span><br><span class="line">    15.0.2 (x86_64) &quot;Amazon.com Inc.&quot; - &quot;Amazon Corretto 15&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-15.0.2/Contents/Home</span><br><span class="line">    1.8.321.07 (x86_64) &quot;Oracle Corporation&quot; - &quot;Java&quot; /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br><span class="line">    1.8.0_312 (x86_64) &quot;Amazon&quot; - &quot;Amazon Corretto 8&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-1.8.0_312/Contents/Home</span><br><span class="line">    1.8.0_312 (x86_64) &quot;Eclipse Temurin&quot; - &quot;Eclipse Temurin 8&quot; /Library/Java/JavaVirtualMachines/temurin-8.jdk/Contents/Home</span><br><span class="line">    1.8.0_311 (x86_64) &quot;Oracle Corporation&quot; - &quot;Java SE 8&quot; /Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home</span><br><span class="line">/Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home</span><br></pre></td></tr></table></figure></li><li><p>使用终端（Terminal）工具，执行以下命令来修改 JDK 版本：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> JAVA_HOME=&lt;JDK路径&gt;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home</span></span><br></pre></td></tr></table></figure><p>或者手动编辑文件添加： 打开bash_profile文件加入JAVA_HOME</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open ~/.bash_profile</span><br></pre></td></tr></table></figure><p>添加最后一行，<code> export JAVA_HOME=&quot;这里填刚才的路径&quot;</code></p><ol start="5"><li>执行以下命令来使修改生效：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bash_profile</span></span><br></pre></td></tr></table></figure><ol start="6"><li>执行以下命令来检查 JDK 版本是否已成功切换：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br></pre></td></tr></table></figure><p>如果您更改了 .bashrc 或其他配置文件，请按照实际情况进行调整。</p><p>此外，您还可以使用 alternatives 命令来管理系统中安装的 JDK 版本。该命令可以让您方便地在多个 JDK 版本之间进行切换，并且可以保证系统中只有一个默认的 JDK 版本。如果您想要了解更多关于 alternatives 命令的信息，可以在终端中执行 man alternatives 命令查看相关帮助文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Mac 系统上切换 JDK 版本，可以使用以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 Finder 或其他文件管理工具，打开系统根目录（通常是 /）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到 Library/Java/JavaVirtualMachines 目</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Java" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Java/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Java" scheme="http://blog.heyb.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>「Python」PPT 转 Markdown</title>
    <link href="http://blog.heyb.top/2022/10/21/[python]-ppt-to-markdown.html"/>
    <id>http://blog.heyb.top/2022/10/21/[python]-ppt-to-markdown.html</id>
    <published>2022-10-21T09:11:21.000Z</published>
    <updated>2022-12-25T14:31:13.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>最近在学习学科类课程，教师提供的课件都是PPT的形式。我自己想整理转成Markdown就需要一个个ppt去复制里面的文本，在洗澡的时候就想着能不能直接通过脚本来一键转换，然后搜了一下类库就开始操作。</p><h2 id="开始"><a class="markdownIt-Anchor" href="#开始"></a> 开始</h2><p>我检索到当前比较适合的类库——python-pptx 以下是相关网站</p><p><a href="https://pypi.org/project/python-pptx/">PYPI</a></p><p><a href="https://github.com/scanny/python-pptx">Github</a></p><p><a href="https://python-pptx.readthedocs.io/en/latest/">官方文档</a></p><h3 id="官方文档示例"><a class="markdownIt-Anchor" href="#官方文档示例"></a> 官方文档示例</h3><p>从官方文档可以找到到获取文本的示例：<a href="https://python-pptx.readthedocs.io/en/latest/user/quickstart.html#extract-all-text-from-slides-in-presentation">官方文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extract all text from slides in presentation</span></span><br><span class="line"><span class="comment"># 从演示文稿中的幻灯片中提取所有文本</span></span><br><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 ppt</span></span><br><span class="line">prs = Presentation(path_to_presentation)</span><br><span class="line"></span><br><span class="line"><span class="comment"># text_runs will be populated with a list of strings,</span></span><br><span class="line"><span class="comment"># one for each text run in presentation</span></span><br><span class="line">text_runs = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 Slide 幻灯片</span></span><br><span class="line"><span class="keyword">for</span> slide <span class="keyword">in</span> prs.slides:</span><br><span class="line">  <span class="comment"># 获取形状 Shape</span></span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> slide.shapes:</span><br><span class="line">      <span class="comment"># 判断是否有文字框 text_frame</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> shape.has_text_frame:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 获取文字框中的段落 paragraphs</span></span><br><span class="line">        <span class="keyword">for</span> paragraph <span class="keyword">in</span> shape.text_frame.paragraphs:</span><br><span class="line">          <span class="comment"># 文字块 run</span></span><br><span class="line">            <span class="keyword">for</span> run <span class="keyword">in</span> paragraph.runs:</span><br><span class="line">              <span class="comment"># 获取文字并加到字符串数组中</span></span><br><span class="line">                text_runs.append(run.text)</span><br><span class="line">                </span><br><span class="line"><span class="comment"># 打印测试结果     </span></span><br><span class="line"><span class="built_in">print</span>(text_runs)</span><br></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>创建 result 结果列表，最后我们会将全部信息存储到 result 列表中，并写入一个 md 文档当中。</p><p>ppt这个库的逻辑是逐页（page）读取每个形状（shape）</p><p>我们的程序是首先判断遇到的形状是否是文本框，如果是文本框的话，直接将全部文本信息写入results。</p><p>如果不是文本框的话再判断这个形状是不是图片对象。如果是的话，新建一个文件夹，将这个图片存储到这个文件夹中。最后将存储到本地的图片的存储路径标准化为markdown格式写入results内。</p><h3 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h3><p>单ppt文件转换markdown</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections.abc</span><br><span class="line"><span class="comment"># 此处是用的是python-pptx 包</span></span><br><span class="line"><span class="comment"># pip3 install python-pptx</span></span><br><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作系统（用于生产文件）</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 正则匹配</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># PPT 文件相对路径 filepath</span></span><br><span class="line">filepath = <span class="string">&quot;这里写入 ppt 的路径名称.pptx&quot;</span></span><br><span class="line"><span class="comment"># 文件名（截取文件名开头至文件名末尾倒数 5 位）</span></span><br><span class="line">file_name = filepath[:-<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化ppt对象</span></span><br><span class="line">prs = Presentation(filepath)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果文本数组</span></span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 Slide 幻灯片</span></span><br><span class="line"><span class="keyword">for</span> slide <span class="keyword">in</span> prs.slides:</span><br><span class="line">    <span class="comment"># 获取形状 Shape</span></span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> slide.shapes:</span><br><span class="line">        <span class="comment"># 判断是否有文字框 text_frame</span></span><br><span class="line">        <span class="keyword">if</span> shape.has_text_frame:</span><br><span class="line">            <span class="comment"># 获取文字框中的段落 paragraphs</span></span><br><span class="line">            <span class="keyword">for</span> paragraph <span class="keyword">in</span> shape.text_frame.paragraphs:</span><br><span class="line">                part = []</span><br><span class="line">                <span class="comment"># 文字块 run</span></span><br><span class="line">                <span class="keyword">for</span> run <span class="keyword">in</span> paragraph.runs:</span><br><span class="line">                    text = run.text</span><br><span class="line">                    <span class="comment"># 如果匹配 第x章，则设置为主标题 # 第一章</span></span><br><span class="line">                    <span class="keyword">if</span> re.search(<span class="string">&#x27;第.+章&#x27;</span>, text):</span><br><span class="line">                        text = <span class="string">&#x27;# &#x27;</span> + text</span><br><span class="line">                    <span class="comment"># 如果匹配 一、二、三、之类的，则设置为副标题 # 一、</span></span><br><span class="line">                    <span class="keyword">elif</span> re.search(<span class="string">&#x27;[一二三四五六七八九十]+、&#x27;</span>, text):</span><br><span class="line">                        text = <span class="string">&#x27;## &#x27;</span> + text</span><br><span class="line">                    <span class="comment"># 如果匹配格式为数字+小数点，类似 1.1.1</span></span><br><span class="line">                    <span class="keyword">elif</span> re.search(<span class="string">&#x27;\d\.&#x27;</span>, text):</span><br><span class="line">                        <span class="comment"># 则设置副标题 例如 #### 1.1.1</span></span><br><span class="line">                        text = (<span class="string">&#x27;#&#x27;</span> * (text.count(<span class="string">&#x27;.&#x27;</span>) + <span class="number">2</span>)) + <span class="string">&#x27; &#x27;</span>  + text</span><br><span class="line">                    <span class="comment"># 获取文字块并加到字符串数组中</span></span><br><span class="line">                    part.append(text)</span><br><span class="line">                results.append(<span class="string">&#x27;&#x27;</span>.join(part))</span><br><span class="line">        <span class="comment"># 否则判断是否为图片</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                imdata = shape.image.blob</span><br><span class="line">                <span class="comment"># 判断文件后缀类型</span></span><br><span class="line">                imagetype = shape.image.content_type</span><br><span class="line">                typekey = imagetype.find(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span></span><br><span class="line">                imtype = imagetype[typekey:]</span><br><span class="line">                <span class="comment"># 创建image文件夹保存抽出图片</span></span><br><span class="line">                path = <span class="string">&quot;图片文件夹/&#123;&#125;_image/&quot;</span>.<span class="built_in">format</span>(file_name)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">                    os.makedirs(path)</span><br><span class="line">                <span class="comment"># 图片生成</span></span><br><span class="line">                image_file = path + shape.name + <span class="string">&quot;.&quot;</span> + imtype</span><br><span class="line">                name = shape.name</span><br><span class="line">                file_str = <span class="built_in">open</span>(image_file, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">                file_str.write(imdata)</span><br><span class="line">                file_str.close()</span><br><span class="line">                <span class="comment"># 标准化为markdown图片格式</span></span><br><span class="line">                results.append(<span class="string">&#x27;![&#123;&#125;](&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(name, image_file))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 去掉多余空格</span></span><br><span class="line">results = [line <span class="keyword">for</span> line <span class="keyword">in</span> results <span class="keyword">if</span> line.strip()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入全部results信息</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;&#123;&#125;.md&#x27;</span>.<span class="built_in">format</span>(file_name), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;\n&#x27;</span>.join(results))</span><br></pre></td></tr></table></figure><p>如果批量操作，只需要循环目录下的文件进行操作即可</p><p>指定目录下面所有ppt转换markdown</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections.abc</span><br><span class="line"><span class="comment"># 此处是用的是python-pptx 包</span></span><br><span class="line"><span class="comment"># pip3 install python-pptx</span></span><br><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作系统（用于生产文件）</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 正则匹配</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录</span></span><br><span class="line"><span class="built_in">dir</span> = <span class="string">&#x27;./课件&#x27;</span></span><br><span class="line"><span class="comment"># 遍历目录下面的文件</span></span><br><span class="line">item = os.listdir(<span class="built_in">dir</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> item:</span><br><span class="line">  <span class="comment"># 如果文件名包含.pptx 则执行转换代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.pptx&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># PPT 文件相对路径 filepath</span></span><br><span class="line">        filepath = <span class="built_in">dir</span> + <span class="string">&#x27;/&#x27;</span> + file</span><br><span class="line">        <span class="comment"># 文件名（截取文件名开头至文件名末尾倒数 5 位）</span></span><br><span class="line">        file_name = filepath[:-<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实例化ppt对象</span></span><br><span class="line">        prs = Presentation(filepath)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 结果文本数组</span></span><br><span class="line">        results = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取 Slide 幻灯片</span></span><br><span class="line">        <span class="keyword">for</span> slide <span class="keyword">in</span> prs.slides:</span><br><span class="line">            <span class="comment"># 获取形状 Shape</span></span><br><span class="line">            <span class="keyword">for</span> shape <span class="keyword">in</span> slide.shapes:</span><br><span class="line">                <span class="comment"># 判断是否有文字框 text_frame</span></span><br><span class="line">                <span class="keyword">if</span> shape.has_text_frame:</span><br><span class="line">                    <span class="comment"># 获取文字框中的段落 paragraphs</span></span><br><span class="line">                    <span class="keyword">for</span> paragraph <span class="keyword">in</span> shape.text_frame.paragraphs:</span><br><span class="line">                        part = []</span><br><span class="line">                        <span class="comment"># 文字块 run</span></span><br><span class="line">                        <span class="keyword">for</span> run <span class="keyword">in</span> paragraph.runs:</span><br><span class="line">                            text = run.text</span><br><span class="line">                            <span class="comment"># 如果匹配 第x章，则设置为主标题 # 第一章</span></span><br><span class="line">                            <span class="keyword">if</span> re.search(<span class="string">&#x27;第.+章&#x27;</span>, text):</span><br><span class="line">                                text = <span class="string">&#x27;# &#x27;</span> + text</span><br><span class="line">                            <span class="comment"># 如果匹配 一、二、三、之类的，则设置为副标题 # 一、</span></span><br><span class="line">                            <span class="keyword">elif</span> re.search(<span class="string">&#x27;[一二三四五六七八九十]+、&#x27;</span>, text):</span><br><span class="line">                                text = <span class="string">&#x27;## &#x27;</span> + text</span><br><span class="line">                            <span class="comment"># 如果匹配格式为数字+小数点，类似 1.1.1</span></span><br><span class="line">                            <span class="keyword">elif</span> re.search(<span class="string">&#x27;\d\.&#x27;</span>, text):</span><br><span class="line">                                <span class="comment"># 则设置副标题 例如 #### 1.1.1</span></span><br><span class="line">                                text = (<span class="string">&#x27;#&#x27;</span> * (text.count(<span class="string">&#x27;.&#x27;</span>) + <span class="number">2</span>)) + <span class="string">&#x27; &#x27;</span>  + text</span><br><span class="line">                            <span class="comment"># 获取文字块并加到字符串数组中</span></span><br><span class="line">                            part.append(text)</span><br><span class="line">                        results.append(<span class="string">&#x27;&#x27;</span>.join(part))</span><br><span class="line">                <span class="comment"># 否则判断是否为图片</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        imdata = shape.image.blob</span><br><span class="line">                        <span class="comment"># 判断文件后缀类型</span></span><br><span class="line">                        imagetype = shape.image.content_type</span><br><span class="line">                        typekey = imagetype.find(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span></span><br><span class="line">                        imtype = imagetype[typekey:]</span><br><span class="line">                        <span class="comment"># 创建image文件夹保存抽出图片</span></span><br><span class="line">                        path = <span class="string">&quot;图片文件夹/&#123;&#125;_image/&quot;</span>.<span class="built_in">format</span>(file_name)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">                            os.makedirs(path)</span><br><span class="line">                        <span class="comment"># 图片生成</span></span><br><span class="line">                        image_file = path + shape.name + <span class="string">&quot;.&quot;</span> + imtype</span><br><span class="line">                        name = shape.name</span><br><span class="line">                        file_str = <span class="built_in">open</span>(image_file, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">                        file_str.write(imdata)</span><br><span class="line">                        file_str.close()</span><br><span class="line">                        <span class="comment"># 标准化为markdown图片格式</span></span><br><span class="line">                        results.append(<span class="string">&#x27;![&#123;&#125;](&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(name, image_file))</span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 去掉多余空格</span></span><br><span class="line">        results = [line <span class="keyword">for</span> line <span class="keyword">in</span> results <span class="keyword">if</span> line.strip()]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写入全部results信息</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;&#123;&#125;.md&#x27;</span>.<span class="built_in">format</span>(file_name), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&#x27;\n&#x27;</span>.join(results))</span><br></pre></td></tr></table></figure><p>更好的做法是将转换的代码抽离成一个函数，提供调用，这里不做展开，欢迎自己探索。</p><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><p>如果运行代码出现 <code>AttributeError: module 'collections' has no attribute 'abc’</code> 异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/compat/__init__.py&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    Container = collections.abc.Container</span><br><span class="line">AttributeError: module <span class="string">&#x27;collections&#x27;</span> has no attribute <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/用户名/workspace/python/smallScript/office/ppt2markdown.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line">  File <span class="string">&quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/__init__.py&quot;</span>, line <span class="number">14</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> pptx.api <span class="keyword">import</span> Presentation  <span class="comment"># noqa</span></span><br><span class="line">  File <span class="string">&quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/api.py&quot;</span>, line <span class="number">15</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> .package <span class="keyword">import</span> Package</span><br><span class="line">  File <span class="string">&quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/package.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> pptx.opc.package <span class="keyword">import</span> OpcPackage</span><br><span class="line">  File <span class="string">&quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/opc/package.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> pptx.compat <span class="keyword">import</span> is_string, Mapping</span><br><span class="line">  File <span class="string">&quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/compat/__init__.py&quot;</span>, line <span class="number">14</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    Container = collections.Container</span><br><span class="line">AttributeError: module <span class="string">&#x27;collections&#x27;</span> has no attribute <span class="string">&#x27;Container&#x27;</span></span><br></pre></td></tr></table></figure><p>则在python文件前引入依赖 <code>import collections.abc</code> 即可</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p><a href="https://python-pptx.readthedocs.io/en/latest/">官方文档</a></p><p><a href="https://cloud.tencent.com/developer/article/1708628">看完这篇Python操作PPT总结，从此使用Python玩转Office全家桶就没有压力了！</a></p><p><a href="https://blog.csdn.net/ZHOUYANYIJIE/article/details/121092568">【python自动化】读取ppt内全部文本和图片信息并导出markdown文档</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;最近在学习学科类课程，教师提供的课件都是PPT的形式。我自己想整理转成Markdown就需要一个个ppt去复制里面的文本，在洗澡的时候就想着能不</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Python" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Python" scheme="http://blog.heyb.top/tags/Python/"/>
    
    <category term="PPT" scheme="http://blog.heyb.top/tags/PPT/"/>
    
  </entry>
  
  <entry>
    <title>「Docker」Docker 安装 SQL Server2019</title>
    <link href="http://blog.heyb.top/2022/10/20/[docker]-docker-installation-sql-server-2019.html"/>
    <id>http://blog.heyb.top/2022/10/20/[docker]-docker-installation-sql-server-2019.html</id>
    <published>2022-10-20T15:18:10.000Z</published>
    <updated>2022-12-25T14:32:18.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><ul><li>在<strong>其他分发</strong> <a href="https://go.microsoft.com/fwlink/p/?linkid=2196119">Docker Hub 上的 Linux 容器映像</a> 中可以参考更多的Docker安装的内容</li></ul><p>当前稳定版本为 2019， 预览版为 2022，这里我们使用稳定版本。</p><p>可以在 Docker 命令行界面中输入以下命令来拉取 SQL Server 2019 的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mcr.microsoft.com/mssql/server:2019-latest</span><br></pre></td></tr></table></figure><p>这条命令会从 Microsoft 的官方镜像仓库中拉取最新版本的 SQL Server 2019 镜像</p><h2 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h2><p>拉取完成后，您可以使用以下命令来创建运行 SQL Server 2019 容器，这里密码必须为复杂密码（建议大小写英文+数字+特殊符号，这里举例为 @Password），否则无法启动。</p><p><code>-p</code> 为映射端口，这里默认为 1433，可以自行修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=@Password&quot; -p 1433:1433 -d mcr.microsoft.com/mssql/server:2019-latest</span><br></pre></td></tr></table></figure><p>这条命令会在 Docker 中运行一个 SQL Server 2019 容器，并且会把容器的 1433 端口映射到主机的 1433 端口上。然后你就可以使用预设的用户名sa，密码@Password 进行登录</p><p>此外，还有一些额外的步骤，你可以在 SQL Server 的 Docker 容器中执行。例如，你可以使用 Docker 命令行工具来进入容器，并在其中执行各种 SQL 脚本。有关更多信息，建议你参阅 Docker 官方文档。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p>官方文档：<a href="https://www.microsoft.com/zh-cn/evalcenter/evaluate-sql-server-2019?filetype=EXE">https://www.microsoft.com/zh-cn/evalcenter/evaluate-sql-server-2019?filetype=EXE</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;其他分发&lt;/strong&gt; &lt;a href=&quot;https://go.microsoft.com/fwlink/p/</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="容器" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="容器" scheme="http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://blog.heyb.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>「Hexo」1-使用Hexo搭建个人博客</title>
    <link href="http://blog.heyb.top/2022/09/10/hexo-1---use-hexo-to-build-a-personal-blog.html"/>
    <id>http://blog.heyb.top/2022/09/10/hexo-1---use-hexo-to-build-a-personal-blog.html</id>
    <published>2022-09-09T16:00:00.000Z</published>
    <updated>2022-12-06T05:11:40.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>如首篇文章所说的，在很久之前我就想搭建自己的个人博客网站，以前在 csdn 的博客不知道为啥就被封禁了，懒得去申诉了。我也有想过自己开发一个，但是奈何审美水平不高，做一个好的前端页面自觉要花费很多功夫，搭建完成之后还要购买服务器来进行维护，都是比较耗费尽力的，后来找了一轮相关的资料，就找到 <a href="https://hexo.io/zh-cn/">Hexo</a> 这个博客的框架。觉得各方面都比较符合我的期望，下面会做一些入门的介绍。</p><h2 id="什么是hexo"><a class="markdownIt-Anchor" href="#什么是hexo"></a> 什么是Hexo</h2><p>Hexo 是是一个快速、简洁且高效的静态博客框架，基于 Node.js 渲染，支持 Markdown 语法且能通过命令行一键部署到 github、heroku、coding 等网站。拥有免费且丰富的主题和插件，可以让你轻松定制你的博客网站。还阿提供了方便的命令行工具，可以帮助你快速搭建、生成和部署你的博客网站。此外文章的本体可以留存在本地备份随时修改。这一点是我比较喜欢的。</p><p>官方网站：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><p>Github: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p><h2 id="优点和不足"><a class="markdownIt-Anchor" href="#优点和不足"></a> 优点和不足</h2><p>Hexo 的优点如下：</p><ul><li><p>免费；轻量</p></li><li><p>基于 Node.js，易于安装和使用。</p></li><li><p>支持 Markdown 语法，使写作更加简单。</p></li><li><p>提供丰富的插件和主题，让你可以轻松定制你的博客。</p></li><li><p>提供方便的命令行工具，可以快速搭建、生成和部署你的博客网站。</p></li><li><p>原文内容在本地，迁移方便；</p></li></ul><p>Hexo 的缺点如下：</p><ul><li>依赖本地环境，不太适用于不同设备上随心发布；</li><li>只支持静态网站，不支持动态网站。</li><li>对于复杂的网站，可能不太适用。</li><li>在某些情况下，它的性能可能不如其他静态网站生成器。</li><li>相对于其他类似工具，它的社区支持可能不太完善。</li></ul><h2 id="安装前置环境"><a class="markdownIt-Anchor" href="#安装前置环境"></a> 安装前置环境</h2><p>安装前提：</p><p><a href="https://github.com">Github</a> | <a href="https://gitee.com/">Gitee</a>| <a href="https://coding.net/">Coding</a> ：资源/代码存放的仓库，目前他们均提供了相关的 pages —— 一种免费的静态站点托管服务，让我们可以在仓库里托管和发布自己的静态网站页面。</p><p><a href="https://nodejs.org/zh-cn/">Nodejs</a> ：Hexo 是基于 Node.js 平台开发的，所以你需要先安装 Node.js。（Node 各系统安装教程：<a href="https://wsxc0617.github.io/2019/05/11/4-nodejs-install-setup/">【NODE】NODE.JS 安装配置(转)</a>） ，建议使用 Node.js 12.0 及以上版本</p><p><a href="https://git-scm.com/">Git</a>：Hexo 使用 Git 来管理项目，将本地的 Hexo 内容提交到 Github 上去</p><p>如果你没有安装这些前置环境，建议你参阅官方文档，了解如何在你的系统上安装这些软件。</p><h2 id="准备-github-pages-仓库"><a class="markdownIt-Anchor" href="#准备-github-pages-仓库"></a> 准备 Github Pages 仓库</h2><h3 id="注册github帐号"><a class="markdownIt-Anchor" href="#注册github帐号"></a> 注册Github帐号</h3><p>已经有Github帐号跳过此步，首先进入<a href="https://github.com/">Github</a>进行注册，用户名、邮箱和密码之后都需要用到，自己记好。</p><p>在 Shell 中本地全局设置用户名和邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure><h3 id="创建-ssh-密钥"><a class="markdownIt-Anchor" href="#创建-ssh-密钥"></a> 创建 SSH 密钥</h3><p>在 Shell 中运行以下命令并多次回车</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;Github 邮箱&quot;</span><br></pre></td></tr></table></figure><p>然后键入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent -s</span><br></pre></td></tr></table></figure><p>出现<code>echo Agent pid xxxxx;</code> 继续输入指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>如果提示错误：<code>Could not open a connection to your authentication agent.</code>则输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval &#x27;ssh-agent -s&#x27;</span><br><span class="line">ssh-add</span><br></pre></td></tr></table></figure><p>会出现如：<code>Identity added: /c/Users/用户/.ssh/id_rsa (/c/users/用户/.ssh/id_rsa)</code></p><p>到了这一步，就可以添加SSH key到你的Github账户了。输入以下指令，拷贝Key（或者进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后到Github里面，点击右上角个人头像——Settings，在左边菜单栏找到SSH and GPG keys，点击New SSH key，Title 随便命名，Key就粘贴上刚才复制的key，然后点Add SSH key，最后会让你重新输入下gitHub的密码即可</p><p>添加完成之后在自己电脑上执行 shell 命令进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>可能会看到有警告，没事，输入“yes”就好</p><p>出现类似：<code>Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.</code>就表示SSH配置好了</p><h3 id="创建repository"><a class="markdownIt-Anchor" href="#创建repository"></a> 创建repository</h3><p>repository相当于一个仓库，用来放置你的代码文件。首先，登陆进入<a href="https://github.com/">Github</a>，并进入个人页面——右上角自己的头像 —— Your repositories，然后选择<code>Repositories</code>，点击New，新建一个<code>repository</code></p><p>创建时，只需要填写Repository name即可，这个名字的格式必须为 [你的github名称].github.io，<a href="http://xn--biuhe-dq1hs2fdz5aotrzx0c.github.io">例如我的为biuhe.github.io</a>，点击<code>Create repository</code> 即可创建</p><h2 id="安装-hexo"><a class="markdownIt-Anchor" href="#安装-hexo"></a> 安装 Hexo</h2><p>安装好 Node 之后，输入安装 hexo 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>安装完成后，在自己选定的文件夹下（如 D:\Hexo），执行以下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;blog-name&gt;</span><br></pre></td></tr></table></figure><p>Hexo 会进行初始化，在目标文件夹建立博客所需要的文件，随后我们安装依赖包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>就已经安装好了，我们可以通过 hexo help (或者 hexo h )来查看 hexo 支持的命令</p><p>以下为常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo help # 帮助</span><br><span class="line">hexo new &quot;文章名称&quot; # 新建文章</span><br><span class="line">hexo new page &quot;页面名称&quot; # 新建页面</span><br><span class="line">hexo g # 完整命令为 hexo generate，用于生成静态文件</span><br><span class="line">hexo d # 完整命令为 hexo deploy，用于将本地文件发布到 github 上</span><br><span class="line">hexo s # 完整命令为 hexo server，用于启动服务器，主要用来本地预览</span><br><span class="line">hexo n # 完整命令为 hexo new，用于新建一篇文章</span><br><span class="line">hexo clean # 清楚缓存文件等</span><br></pre></td></tr></table></figure><p>你可以使用以下命令启动本地服务器，浏览并预览你的博客：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后用浏览器访问 <a href="http://localhost:4000">http://localhost:4000</a> 就可以在本地预览到博客内容了，hexo3.0使用的默认主题是landscape。</p><p>如果页面无法加载可能是端口被占用了，可以先在刚才命令窗口<code>Ctrl+C</code> 关闭服务器，使用 <code>hexo server -p 端口号</code> ，如<code>hexo server -p 5000 </code> 指定运行端口为 5000， 然后通过  http://localhost:5000进行访问</p><p>Hexo 博客目录文件结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml       # 网站配置信息</span><br><span class="line">├── db.json           # 数据</span><br><span class="line">├── node_modules      # node下载的依赖模块（npm install生成的）</span><br><span class="line">├── package-lock.json # 锁定 node 安装模块的版本号</span><br><span class="line">├── package.json      # node 依赖模块信息</span><br><span class="line">├── public            # 网站文件</span><br><span class="line">├── scaffolds         # 模板文件</span><br><span class="line">├── source            # 用户资源（存放markdown文档）</span><br><span class="line">└── themes            # 主题</span><br></pre></td></tr></table></figure><h2 id="部署github"><a class="markdownIt-Anchor" href="#部署github"></a> 部署github</h2><p>编辑刚才创建的hexo目录下的 <code>_config.yml</code> 文件，在 <code>_config.yml</code> 最下方，添加如下配置(命令中的第一个biuhe为Github的用户名，第二个biuhe为之前New的Repository的名字，记得改成自己的。另外记得一点，hexo的配置文件中任何冒号后面都是带一个空格的，否则会出现异常：ERROR Deployer not found : github）</p><p>详细可参考：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">git@github.com:biuhe/biuhe.github.io.git,master</span></span><br></pre></td></tr></table></figure><p>配置 <code>_config.yml </code>并保存，执行以下命令部署到Github上。</p><p>首选生成静态网页。如果你想要将你的博客部署到网站上，你需要生成静态网页。你可以使用以下命令生成静态网页</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>在通过 <code>deploy </code>命令部署到网站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>如果执行hexo d命令报下名错：<code>ERROR Deployer not found: git</code></p><p>就需要安装一下 <code>hexo-deployer-git</code> 这个模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>安装好了继续执行<code>hexo d</code>部署命令，输入 github 的账号密码，就可以访问了。我的是： <a href="http://biuhe.github.io">biuhe.github.io</a></p><h2 id="发表一篇文章"><a class="markdownIt-Anchor" href="#发表一篇文章"></a> 发表一篇文章</h2><p>1.在Git Bash执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;my new post&quot;</span><br></pre></td></tr></table></figure><p>2.在创建的hexo目录下<code>source/_posts</code> 文件中打开 <a href="http://my-new-post.md">my-new-post.md</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: my new post #可以改成中文的，如“新文章”</span><br><span class="line">date: 2016-02-21 16:04:09 #发表日期，一般不改动</span><br><span class="line">categories: blog #文章文类</span><br><span class="line"><span class="section">tags: [文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section">#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上</span></span><br><span class="line">&lt;!--more--&gt;，在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。</span><br></pre></td></tr></table></figure><p>写完文章后，你可以使用</p><ol><li><code>hexo g</code> 生成静态文件。</li><li><code>hexo s</code> 在本地预览效果</li><li><code>hexo d</code> 同步到 github，然后使用<a href="http://xn--github-8h6jw94g4v9a.github.io">http://github用户名.github.io</a> 进行访问</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>到这里，就算初步搭好了一个属于自己的独立博客，后续就是本地写文章然后部署最后发布就行。当然这只是最基本的流程，hexo提供了许多好看的主题，后续会进行讲解。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p>本文摘自：<a href="http://tengj.top/">嘟嘟独立</a></p><p>官方中文文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;如首篇文章所说的，在很久之前我就想搭建自己的个人博客网站，以前在 csdn 的博客不知道为啥就被封禁了，懒得去申诉了。我也有想过自己开发一个，但</summary>
      
    
    
    
    <category term="写作" scheme="http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/"/>
    
    <category term="博客" scheme="http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/Hexo/"/>
    
    
    <category term="博客" scheme="http://blog.heyb.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Blog" scheme="http://blog.heyb.top/tags/Blog/"/>
    
    <category term="Hexo" scheme="http://blog.heyb.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>「Node」Node.js 版本管理升降级</title>
    <link href="http://blog.heyb.top/2022/08/19/[node]-node.js-version-management-upgrade.html"/>
    <id>http://blog.heyb.top/2022/08/19/[node]-node.js-version-management-upgrade.html</id>
    <published>2022-08-19T10:04:23.000Z</published>
    <updated>2022-12-25T14:23:03.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>因为 Node 版本不兼容，导致 <code>npm install</code> 或者 <code>npm run dev</code> 等操作报错。因此我们需要降级或者使用指定版本的 Node。</p><h2 id="版本管理模块-n"><a class="markdownIt-Anchor" href="#版本管理模块-n"></a> 版本管理模块 N</h2><p>N 是一个轻量级的 Node.js 版本管理工具。它可以让开发人员快速地安装、切换和卸载不同版本的 Node.js。</p><ol><li>安装 Node 版本管理模块</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure><ol start="2"><li>安装完成后，可以使用以下命令来查看可用的 Node.js 版本：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n ls</span><br></pre></td></tr></table></figure><ol start="3"><li>要安装指定版本的 Node.js，可以使用以下命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &lt;version&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;version&gt;</code> 是要安装的 Node.js 版本。例如，要安装最新的 LTS 版本的 Node.js，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n lts</span><br></pre></td></tr></table></figure><ol start="4"><li>安装完成后，可以使用以下命令来切换到指定版本的 Node.js：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n use &lt;version&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;version&gt;</code> 是要切换到的 Node.js 版本。</p><p>需要注意的是，N 工具并不会自动切换到新安装的 Node.js 版本，需要手动运行 <code>n use</code> 命令来切换到新版本。</p><p>此外，N 还提供了其他实用的命令，例如可以使用 <code>n rm</code> 命令来卸载指定版本的 Node.js，使用 <code>n latest</code> 命令来安装最新版本的 Node.js 等。可以使用 <code>n --help</code> 命令来查看所有可用的命令。</p><h2 id="版本管理工具-nvm-推荐"><a class="markdownIt-Anchor" href="#版本管理工具-nvm-推荐"></a> 版本管理工具 NVM （推荐）</h2><p>nvm （Node Version Manager）是 Node.js 版本管理器，允许通过命令行快速安装和使用不同版本的节点</p><p>github: <a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p><p>详细内容建议通过官方 <a href="http://readme.md">readme.md</a> 文档来进行学习</p><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3><p>github: <a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></p><p>下载地址到发布页进行下载 exe 结尾的安装程序进行安装：<a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="macos"><a class="markdownIt-Anchor" href="#macos"></a> macOS</h3><p>推荐使用 brew 进行下载管理</p><ol><li>安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure><p>在安装完成后，可以使用以下命令来安装指定版本的 Node.js：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install &lt;version&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;version&gt;</code> 是要安装的 Node.js 版本。</p><p>如果安装成功仍然无法执行，则配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source $(brew --prefix nvm)/nvm.sh&quot; &gt;&gt; .bash_profile;</span><br></pre></td></tr></table></figure><p>使环境变量生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bash_profile</span><br></pre></td></tr></table></figure><p>要安装最新的 LTS 版本的 Node.js，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install --lts</span><br></pre></td></tr></table></figure><ol start="2"><li>安装完成后，可以使用以下命令来切换到指定版本的 Node.js：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use &lt;version&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;version&gt;</code> 是要切换到的 Node.js 版本。如 <code>nvm use 12.13.0</code> 即可安装指定版本</p><p>需要注意的是，在使用 nvm 安装的某个版本的 Node.js 时，需要在终端中运行 nvm 命令来切换到该版本。如果不运行 nvm 命令，则终端默认使用系统中默认安装的 Node.js 版本。</p><p>NVM 其他命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nvm list 是查找本电脑上所有的node版本</span><br><span class="line">    - nvm list 查看已经安装的版本</span><br><span class="line">    - nvm list installed 查看已经安装的版本</span><br><span class="line">    - nvm list available 查看网络可以安装的版本</span><br><span class="line">nvm install &lt;version&gt; 安装指定版本node</span><br><span class="line">nvm use &lt;version&gt; 切换使用指定的版本node</span><br><span class="line">nvm ls 列出所有版本</span><br><span class="line">nvm current显示当前版本</span><br><span class="line">nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名</span><br><span class="line">nvm unalias &lt;name&gt; ## 删除已定义的别名</span><br><span class="line">nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包</span><br><span class="line">nvm on 打开nodejs控制</span><br><span class="line">nvm off 关闭nodejs控制</span><br><span class="line">nvm proxy 查看设置与代理</span><br><span class="line">nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/</span><br><span class="line"></span><br><span class="line">nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.</span><br><span class="line">nvm uninstall &lt;version&gt; 卸载制定的版本</span><br><span class="line">nvm use [version] [arch] 切换制定的node版本和位数</span><br><span class="line">nvm root [path] 设置和查看root路径</span><br><span class="line">nvm version 查看当前的版本</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;因为 Node 版本不兼容，导致 &lt;code&gt;npm install&lt;/code&gt; 或者 &lt;code&gt;npm run dev&lt;/code&gt; 等操</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="前端" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Node" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Node/"/>
    
    
    <category term="前端" scheme="http://blog.heyb.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Node" scheme="http://blog.heyb.top/tags/Node/"/>
    
    <category term="NVM" scheme="http://blog.heyb.top/tags/NVM/"/>
    
  </entry>
  
  <entry>
    <title>「Go」解决go编译出现timeout的问题</title>
    <link href="http://blog.heyb.top/2022/08/15/go-solves-the-timeout-problem-in-go-compilation.html"/>
    <id>http://blog.heyb.top/2022/08/15/go-solves-the-timeout-problem-in-go-compilation.html</id>
    <published>2022-08-15T15:12:31.000Z</published>
    <updated>2022-12-25T14:27:44.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>Go 编译时无法连接其网站，有如以下报错：</p><p>Windows的报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go: downloading github.com/xiecat/xhttp v0.0.0-20220117022559-2545617efd91</span><br><span class="line">main.go:8:2: github.com/kataras/golog@v0.1.7: Get &quot;https://proxy.golang.org/github.com/kataras/golog/@v/v0.1.7.zip&quot;: dial tcp 172.217.163.49:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond</span><br></pre></td></tr></table></figure><p>Linux的报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.go:8:2: github.com/kataras/golog@v0.1.7: Get &quot;https://proxy.golang.org/github.com/kataras/golog/@v/v0.1.7.zip&quot;: dial tcp 172.217.160.113:443: i/o timeout</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h2><h3 id="windows-10"><a class="markdownIt-Anchor" href="#windows-10"></a> Windows 10</h3><p>设置国内代理地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set GOPROXY=https://goproxy.cn</span><br><span class="line">set GO111MODULE=on</span><br></pre></td></tr></table></figure><h3 id="linux-ubuntu"><a class="markdownIt-Anchor" href="#linux-ubuntu"></a> Linux &amp; ubuntu</h3><p>设置代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p>先执行上面的命令，然后再重新执行编译命令就行了。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p><a href="https://www.sssins.com/2022/08/14/37991.html">https://www.sssins.com/2022/08/14/37991.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;Go 编译时无法连接其网站，有如以下报错：&lt;/p&gt;
&lt;p&gt;Windows的报错&lt;/p&gt;
&lt;figure class=&quot;highlight she</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>「Go」Golang</title>
    <link href="http://blog.heyb.top/2022/08/14/%E3%80%8Cgo%E3%80%8Dgolang.html"/>
    <id>http://blog.heyb.top/2022/08/14/%E3%80%8Cgo%E3%80%8Dgolang.html</id>
    <published>2022-08-14T09:11:21.000Z</published>
    <updated>2022-12-25T14:35:39.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Go 是一种开源的编程语言，它由 Google 公司的工程师们在 2007 年提出，并在 2009 年开源。Go 是一种静态类型、编译型、并发型的语言。</p><p>Go 的主要目标是提供一种简单、可扩展、快速、可靠的编程语言，它既适用于大型项目，也适用于小型项目。Go 语言的设计目标是让程序员快速开发出高质量的程序，同时也能使这些程序运行得更快。</p><p>Go 语言提供了丰富的内置类型、结构体、接口、函数等</p><p>如果你想学习 Go 语言，下面是一些建议：</p><ol><li><p>首先，你应该去 Go 语言官网（<a href="https://golang.org/%EF%BC%89%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85">https://golang.org/）下载并安装</a> Go 语言的开发工具。Go 语言官网还提供了完整的 Go 语言文档，可以作为参考手册。</p></li><li><p>然后，你可以通过学习 Go 语言的官方教程（<a href="https://tour.golang.org/%EF%BC%89%E6%9D%A5%E4%BA%86%E8%A7%A3">https://tour.golang.org/）来了解</a> Go 语言的基本语法和用法。这个教程提供了许多在线实例，可以让你在线实时编写和执行 Go 代码。</p></li><li><p>在学习完基本语法后，你可以阅读 Go 语言官方文档（<a href="https://golang.org/doc/%EF%BC%89%E4%B8%AD%E7%9A%84%E2%80%9CEffective">https://golang.org/doc/）中的“Effective</a> Go”一章，了解 Go 语言的设计哲学和编码规范。</p></li><li><p>随后，你可以阅读 Go 语言官方文档中的其他章节，了解 Go 语言的标准库、工具和其他特性。</p></li><li><p>最后，你可以在网上搜索 Go 语言的相关书籍和教程，找到适合你的学习方式</p></li></ol><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ul><li>静态类型：Go 语言是一种静态类型语言，它的类型系统严格，能够检查出许多类型错误。</li><li>并发型：Go 语言提供了丰富的并发模型，原生支持并发编程，提供了 goroutine 和 channel，可以方便地编写多核、高并发的程序。</li><li>简单易学：Go 语言的语法简单易懂，可以轻松上手，适合初学者。</li><li>编译速度快：Go 语言的编译速度快，生成的可执行文件体积小，可以提高开发效率。</li><li>内存管理好：Go 语言内置了垃圾回收机制，可以自动管理内存，避免内存泄漏问题。</li><li>功能强大的标准库：Go 语言拥有丰富的标准库，可以方便地实现常见的功能。</li><li>支持多种操作系统：Go 语言可以运行在多种操作系统上，包括 Windows、Mac OS、Linux 等。</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ul><li>异常处理不够完善：Go 语言的异常处理机制不够完善，不能像其他语言那样抛出和捕获异常。</li><li>运行速度不够快：Go 语言的运行速度不如 C++ 和 Java 等其他语言。</li><li>编译速度慢：Go 的编译速度相对于其他语言比较慢，这对于快速迭代和开发来说不太方便。</li><li>文档与社区支持不足：Go 的文档和社区支持相对于其他流行的语言来说还不够完善，第三方函数库暂时没有主流编程语言多</li><li>单进程限制：Go 语言默认的是单进程，如果需要多进程的话，需要手动编写代码来实现。</li><li>数据类型与类型转换限制：Go 语言在数据类型和类型转换方面比较严格，不太适合大型项目开发。</li><li>静态类型语言限制：Go 语言是一门静态类型语言，这对于一些动态语言的程序员来说不太习惯。</li><li>对于并发编程的限制：Go 语言的并发模型相对于其他语言来说比较特殊，不太适合熟悉其他语言的程序员。</li></ul><h2 id="安装与下载"><a class="markdownIt-Anchor" href="#安装与下载"></a> 安装与下载</h2><p>其他系统版本参考官方链接进行下载安装：<a href="https://go.dev/doc/install">https://go.dev/doc/install</a></p><p>无法访问的用户可以通过中文网的下载地址进行安装：<a href="https://studygolang.com/dl">https://studygolang.com/dl</a></p><p>Linux 下需要设置 4 个环境变量：GoRoot、GoPath、GoBin及Path 到profile文件中（~/.bash_profile（单一用户）或/etc/profile（所有用户））</p><ul><li>GOROOT：该环境变量的值应该为Go语言的当前安装目录,例如:</li></ul><p><code>export GOROOT =/usr/local/go</code></p><ul><li>GOPATH：该环境变量的值应该为Go语言的工作区的集合，例如：</li></ul><p><code>export GOPATH=~/golib:~/goproject</code></p><ul><li>GOBIN：它的值应该是你想存放Go程序的可执行文件的目录，例如：</li></ul><p><code>export GOBIN=~/gobin</code></p><ul><li>PATH：为了方便使用Go语言命令和Go程序的可执行文件，需要追加其值，如：</li></ul><p><code>export PATH=$PATH:$GOROOT/bin:$GOBIN</code></p><p>然后通过source 命令使文件生效，如<code>source ~/.bash_profile</code></p><p>macOS 下可使用brew 安装</p><p>超找 go</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search go</span><br></pre></td></tr></table></figure><p>下载安装指定版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install go@1.19</span><br></pre></td></tr></table></figure><p>查看安装版本验证安装结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><h2 id="设置模块代理"><a class="markdownIt-Anchor" href="#设置模块代理"></a> 设置模块代理</h2><p>参考 <a href="https://goproxy.cn/">https://goproxy.cn/</a></p><p><a href="https://goproxy.cn/#usage-macos-or-linux">macOS 或 Linux</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p><a href="https://goproxy.cn/#usage-windows">Windows</a></p><p>打开你的 PowerShell 并执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">env</span>:GO111MODULE = <span class="string">&quot;on&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">env</span>:GOPROXY = <span class="string">&quot;https://goproxy.cn&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="编写"><a class="markdownIt-Anchor" href="#编写"></a> 编写</h2><p>新建一个 <code>.go</code> 结尾的文件</p><p>写入一下内容</p><p>helloworld.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明文件所在包，每个 go 文件必须有归属的包</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入程序中需要用到的包，以使用包中的函数/方法，例如 Println()</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数 程序入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 含有格式化输出、接收输入的函数</span></span><br><span class="line"><span class="comment">// 在控制台中输出一句话，双引号中的内容（字符串）会原样输出</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译-执行"><a class="markdownIt-Anchor" href="#编译-执行"></a> 编译 &amp; 执行</h2><p>在go文件目录下打开命令行执行以下命令即可编译成可执行的二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br></pre></td></tr></table></figure><p>此外，在不同平台环境中编译其他平台命令如下：</p><h3 id="macos"><a class="markdownIt-Anchor" href="#macos"></a> macOS</h3><p>Mac下编译Linux, Windows平台的64位可执行程序</p><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build helloworld.go</span><br></pre></td></tr></table></figure><p>Windows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build helloworld.go</span><br></pre></td></tr></table></figure><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3><p>Linux下编译Mac, Windows平台的64位可执行程序</p><p>macOS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build helloworld.go</span><br></pre></td></tr></table></figure><p>Windows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build helloworld.go</span><br></pre></td></tr></table></figure><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3><p>Windows下编译Mac, Linux平台的64位可执行程序</p><p>macOS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin3</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build helloworld.go</span><br></pre></td></tr></table></figure><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build helloworld.go</span><br></pre></td></tr></table></figure><p>语义如下：</p><p>GOOS：目标可执行程序运行操作系统，支持 darwin，freebsd，linux，windows</p><p>GOARCH：目标可执行程序操作系统构架，包括 386，amd64，arm</p><h3 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h3><p>也可以通过 <code>go run helloworld.go </code>  来直接编译运行</p><h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2><ul><li>变量定义：在 Go 语言中，变量需要在使用前进行定义。变量定义的语法格式为：<code>var variable_name type</code>。例如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br></pre></td></tr></table></figure><ul><li>常量定义：Go 语言支持常量定义，常量的值在程序运行期间不能被改变。常量定义的语法格式为：<code>const constant_name = value</code>。例如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><ul><li>运算符：Go 语言支持常见的算数、关系和逻辑运算符。例如，加法运算符为 <code>+</code>，减法运算符为 <code>-</code>，小于运算符为 <code>&lt;</code> 等。</li><li>控制语句：Go 语言支持常见的控制语句，包括 if、else、for、switch 等。例如，if 语句的语法格式为：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// code to be executed if condition is true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数：Go 语言支持函数定义和调用。函数定义的语法格式为：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">(parameter1 type1, parameter2 type2)</span></span> return_type &#123;</span><br><span class="line">    <span class="comment">// code to be executed</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用的语法格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line">function_name(parameter1, parameter2)</span><br></pre></td></tr></table></figure><p>下面是一个简单的Go语言程序，它演示了一些基础语法的用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义一个变量</span></span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用if语句</span></span><br><span class="line">  <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">    <span class="comment">// 使用fmt包的Println函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is less than b&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用for循环</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result := add(a, b)</span><br><span class="line">  fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的程序定义了两个变量<code>a</code>和<code>b</code>，并使用if语句来比较它们的值。它还使用了for循环来打印一些数字，定义了一个函数来计算两个数的和，并调用了这个函数。</p><p>其他更多内容请参考网站进行扩展学习</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><blockquote><p><a href="https://golang.org">官网</a></p><p><a href="https://books.studygolang.com">Go语言中文网</a></p><p><a href="https://books.studygolang.com/gopl-zh/">Go语言圣经</a></p><p><a href="https://github.com/chai2010/advanced-go-programming-book">Go语言高级编程</a></p><p><a href="https://www.runoob.com/go/go-tutorial.html">菜鸟教程网</a>（推荐）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;Go 是一种开源的编程语言，它由 Google 公司的工程师们在 2007 年提出，并在 2009 年开源。Go 是一种静态类型、编译型、并发型</summary>
      
    
    
    
    <category term="技术" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"/>
    
    
    <category term="技术" scheme="http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Golang" scheme="http://blog.heyb.top/tags/Golang/"/>
    
  </entry>
  
</feed>
