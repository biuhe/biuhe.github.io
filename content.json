{"meta":{"title":"Biu's Blog","subtitle":"","description":"","author":"He Yongbiao","url":"http://blog.heyb.top","root":"/"},"pages":[{"title":"About","date":"2022-08-07T14:46:31.562Z","updated":"2022-08-07T14:46:31.559Z","comments":false,"path":"about/index.html","permalink":"http://blog.heyb.top/about/index.html","excerpt":"","text":"联系我 邮箱：wsxc_0617@sina.cn 微信：biubiu20201001 GitHub: https://github.com/biuhe"},{"title":"categories","date":"2022-08-15T02:27:07.868Z","updated":"2022-08-07T10:43:28.631Z","comments":false,"path":"categories/index.html","permalink":"http://blog.heyb.top/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-08-15T02:27:07.846Z","updated":"2022-08-07T10:43:28.768Z","comments":false,"path":"repository/index.html","permalink":"http://blog.heyb.top/repository/index.html","excerpt":"","text":""},{"title":"Books","date":"2022-08-15T02:27:07.862Z","updated":"2022-08-08T09:52:08.744Z","comments":false,"path":"books/index.html","permalink":"http://blog.heyb.top/books/index.html","excerpt":"","text":""},{"title":"Links","date":"2022-08-15T02:27:07.867Z","updated":"2022-08-08T09:53:19.202Z","comments":false,"path":"links/index.html","permalink":"http://blog.heyb.top/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-08-15T02:27:07.865Z","updated":"2022-08-07T10:43:28.837Z","comments":false,"path":"tags/index.html","permalink":"http://blog.heyb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2022年总结","slug":"个人/2022年总结","date":"2022-12-31T15:59:59.000Z","updated":"2022-12-31T16:03:24.453Z","comments":true,"path":"2022/12/31/2022-summary.html","link":"","permalink":"http://blog.heyb.top/2022/12/31/2022-summary.html","excerpt":"","text":"在一声声咳嗽中，就要迎来了新的一年。 我以为不出门我可以苟进新冠决赛圈，没想到在却是在冬至的时候发了烧，一连着圣诞节都睡了过去。 这一年所拥有、失去、遗憾、成长。以前总希望时间能够过得快些，希望自己快点长大，现在却总想着能够慢一些，好多事情都似乎没来得及做，却已经结结实实地完结了一年。 学习 今年在技术上进展缓慢，工作中用到的框架并不是主流的，多是做配置文件串联API 的工作，多是基于 MuleSoft 框架做的，现在也逐渐向 Springboot 迁移。所以更多学习的重心还是放在业余自学上。 今年就着个项目倒腾了一下vue3、typeScript和vite ，不得不说，换了vite之后，速度是真的快，调试服务和打包的速度都比用webpack快了太多了。同一项目下调试从平均需要 35-40 秒缩短到了 2 秒左右，对于开发的体验来说真的太舒服了。 此外今年主要学习的新语言是 go，对比Java来说，我感觉更轻便更灵活，学习了一些基础语法之后就可以上手开发一个应用。感觉可以适用于一些更中小型的应用如文件系统，小工具等。新的一年我期望会投入go的精力会更多一些，同时也希望能在容器化的内容多学习一些。期望能够持续地构建自己的知识框架，形成一些可复用的、较优的、结构化的方法论，避免遇到同样的问题不断重复的踩坑。 感情 今年的身份又多了一层，变成了从柳小姐的男朋友转变成了柳小姐的丈夫，和别人介绍的时候还没适应过来，还是「这是我的男/女朋友」，只是我们的关系更安定了一些。小环说，我跟她在一起之后似乎没有失眠过了，都是一躺下没多久就开始打呼噜了。想想我们的关系的确变得更「简单」了，有什么事情都可以直接和对方坦诚布公。在这段感情中我学习到了很多，开始以长远关系和长期价值去思考婚姻和家庭，争取从一个不错的男朋友成为一个优秀的丈夫。新的一年也期待能够再加一层身份，能够带着一个迷你的小环。 其他 今年的时间多了，听的歌反而比去年少了很多（可能是因为在路上交通的时间少了），这里推荐三首我经常听的歌给大家：Bahamas - All The Time，JVKE - golden hour，伍佰 - 泪桥。 总觉得没有听到很抓耳的歌，刷了B站的 00-09 年百大华语金曲感慨以前的歌还是能打，也很庆幸自己经历过华语乐坛群星璀璨的年代。 今年和小环一起看了 55 部电影电视剧（加上我没跟她一起看的估计有 60+了） 大多时候我们都是刷了一些老剧，比较高分的有： 电影：无名之辈、我不是药神、Hello 树先生、让子弹飞、夏洛特烦恼，看不见的客人。 电视剧：庆余年、琅琊榜、国王:永远的君主、甄嬛传、寻秦记。 动漫：罗小黑、罗小黑战记。 这里我就不再做推荐了。 新的剧集有梦华录、风吹半夏，电影隐入尘烟都是今年值得一看的。 隐入尘烟看完，总感觉一口气郁结在心头，长叹一口气却也不能纾解。不由想起史铁生说的：“其实每时每刻我们都是幸运的，因为任何灾难的前面，都可能再加一个“更”字。” 最后 当下总是最好的时候，纵然有许多事情，我们唯有接受，努力，好好生活。 新的一年期望大家身体健康，平安喜乐，万事顺意。","categories":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/tags/%E4%B8%AA%E4%BA%BA/"}]},{"title":"「Docker」Docker 系列文章2 - Dockerfile","slug":"技术/容器/docker/「Docker」Docker 系列文章2 - Dockerfile","date":"2022-12-15T15:35:33.000Z","updated":"2022-12-25T14:32:51.782Z","comments":true,"path":"2022/12/15/docker-docker-series-2---dockerfile.html","link":"","permalink":"http://blog.heyb.top/2022/12/15/docker-docker-series-2---dockerfile.html","excerpt":"","text":"简介 Dockerfile是一个文本文件，其中包含创建 Docker 镜像所需的步骤和指令。主要分为基础镜像信息、维护者信息、镜像操作指令和容器启动时指令四个部分，并支持以 # 开头的注释行。这些指令告诉 Docker 如何设置应用程序的运行环境，通常包括安装软件包、复制文件和设置环境变量的命令。 用户可以使用 Dockerfile 与 docker build 命令一起使用，用于创建 Docker 自定义镜像，然后可以用该镜像创建 Docker 容器。 构建镜像 例如，假设我们想要创建一个基于 go-gin 的应用程序，并使用 Docker 运行它。可以使用 Dockerfile 来指定应用程序所需的依赖项、工作目录和启动命令。 以下是执行步骤 初始化 go 项目：在 Go 项目目录中初始化 go.mod 文件。在终端中输入 go mod init 并回车，这将创建 go.mod 文件。 安装 go-gin 框架：在项目中安装 Gin 框架。在终端中输入 go get github.com/gin-gonic/gin 并回车，这将安装 Gin 框架。 编写使用 Gin 框架的 Go 代码，gin.go 文件代码如下： 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)// 测试 http 框架 https://github.com/gin-gonic/ginfunc main() &#123; // 默认返回一个已连接日志记录器和恢复中间件的引擎实例。 r := gin.Default() // 绑定路由 /ping，访问后执行func的方法 r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; // 返回一个 json， 状态值为 200， H的内容为 map[string] c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;pong&quot;, &#125;) &#125;) // 在0.0.0.0：8080上侦听和服务(对于Windows“为 localhost：8080”) err := r.Run() if err != nil &#123; fmt.Println(&quot;启动服务异常：&quot;, err) &#125;&#125; 创建一个 Dockerfile 文件，并编写文件。 12345678910111213141516171819202122232425# 使用安装了Go的基本映像FROM golang:latest# 维护者信息MAINTAINER docker_user wsxc_0617@sina.cn# 镜像的操作指令# 将工作目录设置为项目根目录WORKDIR /app# 将Go代码复制到容器的工作目录COPY . .# 设置 go module 模式，并设置代理服务ENV GO111MODULE=onENV GOPROXY=https://goproxy.cn,direct# 构建Go代码RUN env GOOS=linux GOARCH=amd64 go build -o go-gin# 暴露应用程序的端口EXPOSE 8080# 当容器启动时运行Go代码ENTRYPOINT [&quot;./go-gin&quot;] 在这个文件中，第一行必须需要使用 FROM 命令来指定要使用的基础镜像 使用 COPY 命令将 Go 代码复制到镜像中 使用 ENV 设置环境变量，这里设置 go module 的代理服务，避免 Go 依赖包下载失败 使用 RUN go build 命令来构建 Go 代码，-o 表示指定打包后输出的文件名称 在 Dockerfile 中运行的 Go 代码。可以使用 CMD 或 ENTRYPOINT 命令来运行 Go 代码，一般是执行 go build 构建好的程序名 使用 docker build 命令来构建你的 Docker 镜像。在终端中输入 docker build -t &lt;image-name&gt; . 并回车，其中 &lt;image-name&gt; 是我们要为镜像指定的名称 1docker build -t go-gin . 在命令中 -t 指定镜像的名称和标记， 格式为 name:tag，如 go-gin:latest 命令末尾的 . 表示构建上下文，即 Dockerfile 和需要包含在镜像中的文件的位置。也可以通过将 . 替换为包含Dockerfile的目录路径来指定不同的目录作为上下文。例如： 1docker build -t myimage:latest /path/to/dir 这将使用 /path/to/dir 目录中的 Dockerfile 和所需文件构建镜像。 重要的是，上下文必须包括 Dockerfile 和构建镜像所需的所有文件。Docker 守护程序将使用上下文构建镜像，并为 Dockerfile 中的每条指令创建一个新层。 命令参考：https://docs.docker.com/engine/reference/commandline/build/ 构建完成后，我们可以通过 docker images 查看构建好的镜像 1docker images 可以看到如下信息： 12REPOSITORY TAG IMAGE ID CREATED SIZEgo-gin latest d82303fc77be 34 seconds ago 1.13GB 使用 docker run 命令来运行你的 Docker 镜像。在终端中输入 docker run -p 8080:8080 &lt;image-name&gt; 并回车，其中 8080 是你希望运行应用程序的端口。 我们运行 docker run -p 8080:8080 go-gin 来运行镜像。可以看到如下结果： 1234567891011[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] GET /ping --&gt; main.main.func1 (3 handlers)[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default[GIN-debug] Listening and serving HTTP on :8080 命令参考文档：https://docs.docker.com/engine/reference/run/ 通过浏览器访问 http://localhost:8080/ping 可以看到返回了信息 &#123;&quot;message&quot;:&quot;pong&quot;&#125; 分段构建 「Dockerfile 构建镜像太大了怎么处理」 在 Dockerfile 中，可以使用多个构建阶段来进行分段构建。分段构建的目的是为了在构建 Docker 镜像的过程中，更加高效地使用资源。 在 Dockerfile 中，每个构建阶段都是一个单独的上下文，在每个构建阶段中执行的操作都是独立的。在每个构建阶段结束时，Docker 会将其上下文打包成一个新的镜像层，并将其与前面的镜像层合并。 我们在上一步操作中可以看到我们的代码量很小，但是构建出来的镜像却有 1GB 大小。主要是因为依赖包等内容也一并打包到构建的镜像中去了，实际上我们仅需编译好 Go 的二进制文件即可运行。因此可以通过 Dockerfile 的分段构建来进行镜像的瘦身。 代码如下： 1234567891011121314151617181920212223242526272829303132333435# ---------- 构建 ---------- ## 使用安装了Go的基本映像【并且设置别名】FROM golang:latest as go_app_build# 维护者信息MAINTAINER docker_user wsxc_0617@sina.cn# 镜像的操作指令# 将工作目录设置为项目根目录WORKDIR /app# 将Go代码复制到容器COPY . .# 设置 go module的代理服务ENV GO111MODULE=onENV GOPROXY=https://goproxy.cn,direct# 构建Go代码RUN env GOOS=linux GOARCH=amd64 go build -o go-gin .# ---------- 运行 ---------- ## 运行环境设置为 alpineFROM alpine:latest as go_app_run# 【采用相同的目录为工作目录】WORKDIR /app# 【将构建镜像中编译好的二进制文件复制到运行镜像中】#COPY --from=go_app_build /app .COPY --from=0 /app .# 显示应用程序的端口EXPOSE 8080# 当容器启动时运行Go代码ENTRYPOINT [&quot;./go-gin&quot;] 在修改后的 Dockerfile 中，我们可以看到有两个构建阶段：“go_app_build” 和 “go_app_run”。 在 “go_app_build” 构建阶段中，我们执行了将 Go 代码复制到容器、设置 Go module 的代理服务以及构建 Go 代码的操作。 在 “go_app_run” 构建阶段中，我们执行了将编译好的二进制文件复制到运行镜像中的操作。 COPY 指令的 --from 选项允许你从其他构建阶段复制文件。可以使用 FROM 指令的名称来标识构建阶段，也可以使用数字来标识构建阶段。当使用数字标识构建阶段时，0 表示第一个构建阶段，1 表示第二个构建阶段，以此类推。 例如，在本例中，0 表示名为 “go_app_build” 的构建阶段，即在修改后的 Dockerfile 中的第一个构建阶段。 使用数字标识构建阶段的好处是，当我们添加、删除或重新排制构建阶段时，只需要更新相应的数字即可，而不需要更新所有的构建阶段名称。 例如，假设你在修改后的 Dockerfile 中再添加了一个构建阶段，那么只需要将这个新的构建阶段的标识符设置为 2，其他的构建阶段的标识符都不需要更改。这样可以避免出现因为构建阶段名称的更改而导致的潜在问题 我们使用 docker build -t go-gin2 . 命令，来构建名为 go-gin2 的镜像，并通过 docker images 查看构建好的镜像，结果如下： 12REPOSITORY TAG IMAGE ID CREATED SIZEgo-gin2 latest ddbe692c0268 56 minutes ago 36.1MB 可以看到我们构建出来的镜像比之前小了很多，主要因为 同一个 Dockerfile 文件的多个 FROM 是多个不同的image，不同的 image 之间数据隔离，包括环境变量，但是不同的 image 之间可以通过 --from 来传递数据 同一个 Dockerfile 的多个 FROM 只有最后一个FROM 才会生成最终的镜像，因此编译阶段的环境没有在第二阶段中，第二阶段只是引用了第一阶段的生成物：二进制文件，所以最终生成的镜像文件比写一个 FROM 要小得多 分段构建的优点是，当构建过程中的某个操作失败时，Docker 只需要重新构建失败的构建阶段，而不需要重新构建整个镜像。这样可以提高构建效率，并减少构建失败的风险。 总的来说，分段构建是一种非常有用的技术，可以帮助我们提高 Docker 镜像的构建效率，并减少构建失败的风险。建议在编写 Dockerfile 时尽量使用分段构建，以便更好地利用 Docker 的构建功能。 指令 Dockerfile 指令的一般格式为INSTRUCTION &lt;arguments&gt;，下面分别做详细介绍。 FROM 格式为FROM &lt;image&gt;或FROM &lt;image&gt;:&lt;tag&gt;。第一条指令必须为FROM指令，在同一个Dockerfile中创建多个镜像时可以使用多个FROM指令（每个镜像一次）。 MAINTAINER 格式为MAINTAINER &lt;name&gt;，指定维护者信息。 RUN 格式为RUN &lt;command&gt;或RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。前者将在shell终端中运行命令，即/bin/sh -c；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现。 1RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;] 每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，当命令较长时可使用\\来换行。 CMD 支持三种格式： CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]，使用exec执行，推荐方式。 CMD command param1 param2，在/bin/sh中执行，提供给需要交互的应用。 CMD [&quot;param1&quot;, &quot;param2&quot;]，提供给ENTRYPOINT的默认参数 指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时指定了运行的命令则会覆盖掉CMD指定的命令。 EXPOSE 格式为EXPOSE &lt;port&gt; [&lt;port&gt;...]，告诉Docker服务端容器暴露的端口号，供互联系统使用。 在启动容器时需要通过-P，Docker主机会自动分配一个端口转发到指定的端口；使用-p则可以具体指定哪个本地端口映射过来。 ENV 格式ENV &lt;key&gt; &lt;value&gt;，指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。 1234ENV PG_MAJOR 9.3ENV PG_VERSION 9.3.4RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgres &amp;&amp; ...ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH ADD 格式ADD &lt;src&gt; &lt;dest&gt;，复制指定的&lt;src&gt;到容器中的&lt;dest&gt;，其中&lt;src&gt;可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。 COPY 格式COPY &lt;src&gt; &lt;dest&gt;，复制本地主机的&lt;src&gt;（为Dockerfile所在目录的相对路径，文件或目录）为容器中的&lt;dest&gt;，目标路径不存在时会自动创建。 ENTRYPOINT 配置容器启动后执行的命令，且不可被docker run提供的参数覆盖。有两种格式： ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] ENTRYPOINT command param1 param2，shell中执行。 每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后一个生效。 VOLUME 格式VOLUME [&quot;/data&quot;]，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。 USER 格式USER daemon，指定运行容器时的用户名或UID，后续的RUN也会使用指定用户。 当服务不需要管理员权限时，可通过该命令指定运行用户，并可在之前创建所需要的用户。要临时获取管理员权限可使用gosu，而不推荐sudo。 WORKDIR 格式WORKDIR /path/to/workdir，为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。 可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。 12345WORKDIR /aWORKDIR bWORKDIR cRUN pwd# 最终路径为/a/b/c ONBUILD 格式ONBUILD [INSTRUCTION]，配置当前所创建的镜像作为其他新创建的基础镜像时所执行的操作指令。 镜像image-A Dockerfile 1234[...]ONBUILD ADD . /app/srcONBUILD RUN /usr/local/bin/python-build --dir /app/src[...] 基于image-A创建新镜像，新的Dockerfile中使用FROM images-A指定基础镜像时，会自动执行ONBUILD指令内容，等价于在后面添加了两条指令。 12345FROM images-A# Automatically run the following 等价于自动运行以下命令ADD . /app/srcRUN /usr/local/bin/python-build --dir /app/src 使用ONBUILD指令的镜像推荐在标签中注明。例如ruby:1.9-onbuild。 实用技巧： 如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。 例如上面的底是golang:latest，我们可以运行docker run -it -d golang:latest bash，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。 掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。 扩展 怎样上传到阿里云私有仓库？ 参考 官方文档 Docker安装与基本操作 Docker 快速入门-制作自己的镜像 go 构建最小的镜像","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"技术/容器","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"技术/容器/Docker","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"容器","permalink":"http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.heyb.top/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://blog.heyb.top/tags/Dockerfile/"}]},{"title":"「ChatGPT」OpenAI ChatGPT注册攻略","slug":"技术/其他/「ChatGPT」OpenAI ChatGPT注册攻略","date":"2022-12-08T09:22:20.000Z","updated":"2022-12-25T14:31:59.934Z","comments":true,"path":"2022/12/08/chatgpt-openai-chatgpt-registration-strategy.html","link":"","permalink":"http://blog.heyb.top/2022/12/08/chatgpt-openai-chatgpt-registration-strategy.html","excerpt":"","text":"简介 ChatGPT 是一种大型语言模型，由OpenAI训练而成。它的目的是通过对大量语言数据的学习，能够帮助人们更好地理解和生成自然语言。它可以用来完成各种自然语言处理任务，比如机器翻译 —— 将一段文本从一种语言翻译到另外一种语言，问答系统 —— 回答日常生活的常见问题、学术问题，文本生成 —— 生成文章、邮件，解释语言语法、语义等等。 以下是 chatGPT的使用案例，可以自己参考使用或摸索合适自己的方式 案例序号 案例名称 案例来源 1 生成AI Prompt https://twitter.com/GuyP/status/1598020781065527296 2 编写iOS SwiftUI APP https://twitter.com/avielgr/status/1598895550392197121 3 学习技术 https://twitter.com/HamelHusain/status/1598834924848836609 4 写出一个可以生成小鸟图片的Python脚本 https://twitter.com/bgavran3/status/1598857248536956928 5 写Javascript脚本 https://twitter.com/vertinski/status/1599099368472137729 6 参与SAT考试 https://twitter.com/davidtsong/status/1598767389390573569 7 自然语言转成Latex https://twitter.com/jdjkelly/status/1598021488795586561 8 解释代码 https://twitter.com/goodside/status/1598129631609380864 9 改写故事 https://twitter.com/raphaelmilliere/status/1598469100535259136 10 debugging代码 https://twitter.com/amasad/status/1598042665375105024 11 写计算机网络家庭作业 https://twitter.com/abhnvx/status/1598258353196929024 12 替代搜索引擎 https://twitter.com/RajJohri2019/status/1598492953764315137 13 创作短剧 https://twitter.com/rgodfrey/status/1598162900140445697 14 创作食谱 https://twitter.com/stephsmithio/status/1598920887029628928 15 反编译汇编代码 https://twitter.com/mahal0z/status/1598536939942006784 16 代写办公邮件 https://twitter.com/CubicleApril/status/1598753388895797282 17 写年度总结报告 https://twitter.com/shanselman/status/1599073011050872832 18 闲聊 https://twitter.com/t3dotgg/status/1598954493680713729 19 撰写技术博客 https://twitter.com/goodside/status/1598235521675038722 20 逻辑推理问题 https://twitter.com/Robdeprop/status/1598285166971351040 准备 留学代理，要求是非中国（及地区）的地址，如日韩、印度、新加坡、美国等 准备一个国外手机号或者用接码平台 sms-activate 开始 接码平台 打开接码平台 sms-activate.org，注册一个账号。注册后在右上角个人信息中进行充值，这里单位是卢布 接码OpenAi的一次费用是大概10卢布（约 1 块多人民币），不过只能充美金，充值0.2美元即可，充值时下滑可以选择支付宝进行支付。 充值完成后我们去注册openAI的账号 注册OpenAI账号 首先是打开ChatGPT的账户注册页面。谷歌注册或者邮箱注册都可以，这里用邮箱注册作为例子。 用邮箱注册后有个验证邮件，进去邮箱，点开链接。（如果无法打开链接的话要注意邮件中是否允许了可执行脚本） 如果出现提示说不能在当前国家服务： Not available OpenAI's services are not available in your country. 就是因为代理没有设置为全局，或者地区不对。 如果出现了这个提示，那么接下来怎么切换代理，都是没用的，可以在浏览器控制台清空状态 解决地区问题 首先要将代理地址切换到不是国内地区的代理（如港澳台） 然后，先复制下面这段代码 1javascript:window.localStorage.removeItem(Object.keys(window.localStorage).find(i=&gt;i.startsWith(&#x27;@@auth0spajs&#x27;))) 打开浏览器控制台粘贴进去，然后按下回车键，接着刷新页面，如果代理没问题，就可以正常看到注册页面了。 填写手机验证码 到我们的接码网站上去，在左侧菜单栏搜索OpenAi，然后选择巴西（经测试可用）或印度（更实惠但未经测试），点击小黄车购买。 然后在右侧主页面会出现购买好的手机号，点击复制后回到 openAI的验证界面-verify your phone number，选择了对应国家地区然后粘贴手机号选send code。 回到接码平台的手机号界面，等待一会儿网站会提示验证码，我们复制粘贴即可。 如果申请Send code发送短信时，总是出现发送短信请求次数过多，无法发送的问题。 这个应该是ChatGPT的用户突然暴增导致的，官方也给了说明，大家耐心等待一会应该就可以。 现在我们可以愉快的进行使用了 其他 需要注意的是 ChatGPT目前是不联网的状态，所以回答的内容也是2021年之前的。 ChatGPT的回答不是 100%准确，仅可以作为参考。并且也和提问的技巧有关系： 如：问它能说一下Java工作中遇到的问题吗？ 它会回答： 由于我是一个计算机程序，我没有工作，也没有遇到任何 Java 问题。我只能通过对已有信息的学习来回答问题。你可以提供一些关于 Java 的信息，我可以尝试为你解答问题。 如果问它：假设我是一名 多年经验的高级java开发程序员，你能尝试模拟说我在工作中遇到的问题吗 它就可以模拟情景来进行回答 ChatGPT使用英文提问会比使用中文提问效果会更好 参考 最强AI对话系统ChatGPT不完全使用指南——已发掘功能展览！","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"其他","slug":"技术/其他","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/"},{"name":"AI","slug":"技术/其他/AI","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/"},{"name":"ChatGPT","slug":"技术/其他/AI/ChatGPT","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/ChatGPT/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://blog.heyb.top/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://blog.heyb.top/tags/OpenAI/"}]},{"title":"「Docker」Docker 系列文章1 - 入门","slug":"技术/容器/docker/「Docker」Docker 系列文章1 - 入门","date":"2022-12-04T08:14:47.000Z","updated":"2022-12-25T14:32:35.853Z","comments":true,"path":"2022/12/04/docker-docker-series-1---getting-started.html","link":"","permalink":"http://blog.heyb.top/2022/12/04/docker-docker-series-1---getting-started.html","excerpt":"","text":"简介 Docker 是一个开源的容器管理平台，它允许开发人员在轻量级容器中运行应用程序。容器是一种轻量级的虚拟化技术，它允许将应用程序及其依赖项打包在一起，并在任何支持容器的环境中运行。这样，开发人员可以确保应用程序在不同的平台上保持一致，并且能够在任何地方快速部署和运行。 Docker可以简单理解为轻量级的虚拟机，但它使用独立于底层操作系统的容器来运行应用程序。与虚拟机相比，Docker 可以更快速地启动和运行应用程序，因为它不需要启动一个完整的操作系统来运行应用程序。这也使得 Docker 更容易在多个环境中进行部署，例如开发环境、测试环境和生产环境。 优点 轻量级：可以通过一行命令完成启动和停止，方便快捷。 可移植：可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意操作系统，在不同的环境中运行。 隔离：运行时利用沙箱机制形成隔离容器，各个应用互不干扰，可以有效地管理应用程序之间的依赖关系和资源限制。 Docker 的生态系统提供了丰富的工具，可以帮助开发人员构建、部署和管理容器化应用程序。 能做什么 快速部署，解决不同环境中系统差异的问题 在使用Docker前，我们在不同环境下（如开发环境、测试环境、生产环境等）需要安装、配置、维护不同的应用程序（如JDK、Tomcat、数据库等），不同应用在每个环境都需要做一遍同样的操作，工作量繁重。使用Docker可以自己创建空镜像从头构建（或使用公共仓库中构建好的镜像），直接能够在不同环境中一步到位搭建部署整套应用环境。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“代码在我机器上没问题啊”的情况。 解决依赖问题，多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0 大型项目中依赖关系复杂，依赖的组件非常多，不同组件之间部署时往往会产生依赖兼容性问题。 例如：一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项，甚至Node JS的版本都需要不相同，此时便会出现依赖兼容问题。Docker应用运行在容器中，使用沙箱机制可以将环境互相隔离。不同应用需要不同的版本我们就运行在不同的容器中即可。 更轻松的扩展和维护 基于上面的优点，使得Docker在应用复用更为容易，能够使得应用快速扩展，让服务弹性伸缩变得简单，能够轻松地完成动态管理的工作，根据业务需求实时扩展或拆除应用程序和服务。 快速安装测试/学习软件，用完就可以删除，不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK 概念 镜像（Image）：像是文件模板，可以理解为软件安装包，可以方便的进行传播和安装。一个镜像可以创建多个容器 容器（Container）：是由镜像创建的运行实例，可以理解为软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。 仓库（Repository）：集中存放镜像文件的场所，可以理解为 Maven、Git 的仓库，当我们需要镜像文件的时候，可以从远程仓库中拉取。官方镜像仓库：https://hub.docker.com/ 安装 桌面版：https://www.docker.com/products/docker-desktop 服务器版：https://docs.docker.com/engine/install/#server 问题 windows 打开桌面版的时候如果出现了如下问题 Hardware assisted virtualization and data execution protection must be enabled in the BIOS. 则需要开启 WSL2 功能 在控制面板-&gt;程序-&gt;启用或关闭 windows 功能，勾选Windows虚拟机监控程序平台和适用于Linux的Windows子系统，以开启 Windows 虚拟化和 Linux 子系统（WSL2) 如果出现 WSL 2 installation is incomplete. The WSL2 Linux kernel is now installed using a separate MSI update package. Please click the link and follow the instructions to install the kernel update: xxx 则需要安装最新版本的 WSL2： https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi 配置 镜像加速源 镜像加速器 镜像加速器地址 Docker 中国官方镜像 https://registry.docker-cn.com DaoCloud 镜像站 http://f1361db2.m.daocloud.io Azure 中国镜像 https://dockerhub.azk8s.cn 科大镜像站 https://docker.mirrors.ustc.edu.cn 阿里云 https://&lt;your_code&gt;.mirror.aliyuncs.com 七牛云 https://reg-mirror.qiniu.com 网易云 https://hub-mirror.c.163.com 腾讯云 https://mirror.ccs.tencentyun.com 安装软件 传统应用安装，可能需要先安装许多的依赖。例如我们安装WordPress （一个基于 PHP 和 MySQL 的免费和开源内容管理系统（CMS））的话，则需要先安装Apache、Php、MySQL等环境后才可以正常安装WordPress。同一系统下也不方便安装多个版本的软件，有些软件还卸载不干净。 相对比之下Dokcer安装更简洁，一个命令就可以快速安装和卸载。也没有系统兼容的问题，Linux专享的软件也可以在Windows下使用。 安装Redis 在Redis官方网站中并没有提供Docker相关的安装方式。 可以通过Docker官方镜像仓库查找Redis镜像：https://hub.docker.com/_/redis 通过命令 docker pull redis 来拉取镜像，也可以通过直接运行 docker run 来创建并运行容器： 1docker run -d -p 6379:6379 --name redis redis:latest 然后会返回一串容器id（我这里是1c8f24cddd1d7a4accac19e1ef8f7ab68e70f663c3a8f184bbc732fd50f43abd）， 就表示创建成功。如果有需要，我们也可以设置更多参数： 1docker run --restart=always --log-opt max-size=100m --log-opt max-file=2 -p 6379:6379 --name redis -d redis --appendonly yes --requirepass 123456 --restart=always 为开机启动 -log 为日志方面的设置 -p 为将内部端口映射到外部的端口，将6379端口挂载出去，前面为宿主机端口，后面为镜像内端口 -name 为容器名字 -d redis 表示后台启动redis -- appendonly yes 开启 redis 持久化 -- requirepass 为设置redis访问密码 注意：生产环境尽量不要使用 latest 版本，应使用指定版本号 查看状态 通过以下命令查看容器运行状态： 1docker ps -a |grep &lt;容器名&gt; 运行 docker ps -a |grep redis 得到以下结果： 11c8f24cddd1d redis &quot;docker-entrypoint.s…&quot; 47 seconds ago Up 45 seconds 0.0.0.0:6379-&gt;6379/tcp redis 或者通过容器 id 来查看状态如：docker ps -a | grep 1c8f 查看容器运行日志 1docker logs --since 30m &lt;容器名/id&gt; –since 30m 是查看此容器30分钟之内的日志情况。 运行docker logs --since 30m redis 或 docker logs --since 30m 1c8f 得到如下结果： 12345671:C 15 Dec 2022 08:23:37.361 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo1:C 15 Dec 2022 08:23:37.361 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started1:C 15 Dec 2022 08:23:37.361 # Configuration loaded1:M 15 Dec 2022 08:23:37.363 * monotonic clock: POSIX clock_gettime1:M 15 Dec 2022 08:23:37.366 * Running mode=standalone, port=6379.1:M 15 Dec 2022 08:23:37.366 # Server initialized1:M 15 Dec 2022 08:23:37.367 * Ready to accept connections 进入容器 1docker extc -it &lt;容器&gt; &lt;命令&gt; 运行 docker exec -it redis redis-cli 或 docker exec -it 1c8f redis-cli 就可以进入到redis 当中，刚才我们设置了密码，因此要用auth命令登录后才可以使用。 1234567127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; set abc 1OK127.0.0.1:6379&gt; get abc&quot;1&quot;127.0.0.1:6379&gt; exit 此时我们已经可以操作并查看到redis中的数据了，证明我们已经安装成功，接下来我们学习怎样停止或删除容器 删除容器 我们需要停止运行中的容器才可以删除 停止命令： 1docker stop &lt;容器名/id&gt; 运行 docker stop redis 或 docker stop 1c8f停止容器 删除命令： 1docker rm &lt;容器名/id&gt; 运行 docker rm redis 或 docker rm 1c8f 删除容器 通过 docker ps -a 查看 redis 容器已经被删除 删除镜像 查看全部镜像命令： 1docker images 删除镜像命令： 1docker rmi &lt;镜像id&gt; 运行 docker rmi 7614 删除镜像， 这里的7614是我的redis的镜像id 常用命令 镜像 获取镜像 docker pull IMAGE_NAME[:Tag] ：用于从 Docker 仓库下载镜像，如不显式指定TAG，则默认选择latest标签 查看信息 docker images列出本地主机上已有的镜像信息 docker inspect IMAGE_ID可以获取该镜像的详细信息。 标签镜像 docker tag REPOSITORY:TAG可为本地镜像添加新的标签，例如 docker tag ubuntu:latest latest_ubuntu:latest 搜索镜像 docker search IMAGE_NAME ：用于在 Docker 仓库中搜索镜像，例如 docker search mysql 可选参数： --automated=false 仅显示自动创建的镜像 --no-trunc=false 输出信息不截断显示 -s，–starts=0 指定仅显示评价为指定星级以上的镜像 删除镜像 docker rmi IMAGE[IMAGE...]IMAGE可以为标签或ID。使用镜像ID来删除时，会先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身。 注意：当有该镜像创建的容器存在时，镜像文件默认是无法被删除的。 docker ps -a命令可以看到本机上存在的所有容器。 强制删除镜像用docker rmi -f IMAGE命令。使用-f参数来强制删除一个存在容器依赖的镜像会造成一些遗留问题。正确做法是先删除依赖镜像的所有容器，再来删除镜像。删除容器用docker rm CONTAINER_ID命令。 创建镜像 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG] 基于已有镜像的容器创建 可选参数： -a，–author=“” 作者信息 -m，–message&quot;&quot; 提交信息 -p，–pause=true 提交时暂停容器运行 举例如下： 12345678910111213[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 dea1945146b9 6 weeks ago 188MB[root@localhost test]# docker run -ti ubuntu:14.04 /bin/bashroot@098ab9bc25f8:/# touch testroot@098ab9bc25f8:/# exitexit[root@localhost test]# docker commit -m &quot;Added a new file&quot; -a &quot;Docker Test&quot; 098ab9bc25f8 testsha256:68ceff3107a82641378dee544caeed48e6d544b4d74b525051381b7db7479d35[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest 68ceff3107a8 16 seconds ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB 基于本地模板导入使用cat 镜像压缩包 | docker import -REPOSITORY:TAG命令。 123456789[root@localhost test]# lsubuntu-14.04-x86_64-minimal.tar.gz[root@localhost test]# cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04-serversha256:ae63a9e87332075323de0e2cb3e12dd6ea8c6078e006dd937dc0d670c4a8773d[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04-server ae63a9e87332 12 seconds ago 215MBtest latest 68ceff3107a8 About an hour ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB 存储镜像 docker save -o 压缩包保存名 REPOSITORY:TAG 可存出镜像。 举例如下： 123456[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 dea1945146b9 6 weeks ago 188MB[root@localhost test]# docker save -o ubuntu_server.tar ubuntu:14.04[root@localhost test]# lsubuntu_server.tar 载入镜像 docker load --input 压缩包保存名或者docker load &lt; 压缩包保存名可从导出的文件中重新载入镜像。 举例如下： 1234567[root@localhost test]# lsubuntu_server.tar[root@localhost test]# docker load --input ubuntu_server.tar Loaded image: ubuntu:14.04[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 dea1945146b9 6 weeks ago 188MB 构建镜像 docker build：用于从 Dockerfile 创建一个新的镜像 上传镜像 可以使用docker push NAME[:TAG]上传镜像到仓库，默认上传到DockerHub官方仓库。第一次使用必须要先登录。 举例如下： 1234567891011121314151617181920212223242526[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04-server ae63a9e87332 4 minutes ago 215MBtest latest 68ceff3107a8 About an hour ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB[root@localhost test]# docker tag test:latest username/test:latest[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04-server ae63a9e87332 7 minutes ago 215MBusername/test latest 68ceff3107a8 About an hour ago 188MBtest latest 68ceff3107a8 About an hour ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB[root@localhost test]# docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.Username: usernamePassword: Login Succeeded[root@localhost test]# docker push username/test:latestThe push refers to a repository [docker.io/username/test]786a798121af: Pushed 7fb9ba64f896: Pushed 4e1e6ac5b9d6: Pushed 48daf661d621: Pushed bf59e7acf5c4: Pushed c47d9b229ca4: Pushed latest: digest: sha256:c46955d49b5b7cf15528b94d5c4fb7028b61c52cf00ee4d14073a92379e2237f size: 1566 容器 创建容器 docker create CONTAINER_NAME 命令来新建一个容器，新建的容器处于停止状态，可以使用docker start &lt;CONTAINER_ID&gt;命令来启动它。 启动容器 启动容器有两种方式： 将在终止状态的容器重新启动，命令为 docker start CONTAINER 基于镜像创建并运行一个新的容器，命令为 docker run CONTAINER ， 等价于先执行docker create，再执行docker start。 可选参数： -t，让Docker分配一个伪终端并绑定到容器的标准输入上 -i，则让容器的标准输入保持打开 -d，会让Docker容器在后台以守护形式运行，获取容器输出信息 例如 docker run -t -i ubuntu:14.04 /bin/bash 会启动一个bash终端，允许用户进行交互，举例如下： 123456789101112131415161718192021222324[root@localhost test]# docker run -t -i ubuntu:14.04 /bin/bashroot@eac23878c8bf:/# pwd/root@eac23878c8bf:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@eac23878c8bf:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 15 pts/0 00:00:00 psroot@eac23878c8bf:/# exitexit[root@localhost test]# docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello word; sleep 1; done&quot;2105fbb444b3b028a1b26ec5879d8d282ccc2fa7d0a9776a8a86e808d3414843[root@localhost test]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2105fbb444b3 ubuntu:14.04 &quot;/bin/sh -c &#x27;while...&quot; 11 seconds ago Up 10 seconds confident_payneeac23878c8bf ubuntu:14.04 &quot;/bin/bash&quot; 2 minutes ago Exited (0) 2 minutes ago adoring_shockley[root@localhost test]# docker logs 2105fbb444b3hello wordhello wordhello wordhello word...[root@localhost test]# docker stop 2105 停止容器 docker stop 命令用于停止一个正在运行的容器 可选参数： -t， 指定停止容器前等待的秒数。默认值是10秒 扩展： docker ps -a -q 命令为查看所有(-a)的容器ID(-q)，这条命令也可以提供给另外的命令组合使用，如下： docker stop $(docker ps -a -q) ，命令为停止所有容器 docker restart 将一个运行态的容器终止然后再重新启动它。 进入容器 在运行容器的时候使用-d参数，容器会进入后台，用户无法看到容器中的信息，需要通过命令来进入到容器中进行操作。 docker attach CONTAINER 它允许我们连接到正在运行的容器并在其中运行命令。可以使用它来在容器内部执行操作，例如查看容器的日志或运行容器内的应用程序。这条命令将会打开一个新的终端窗口，可以在容器内部运行命令。要退出容器，可以使用快捷键 Ctrl+P 和 Ctrl+Q。 注意，docker attach 命令只能用于连接正在运行的容器。如果要连接已停止的容器，我们需要使用 docker exec 命令。 docker exec 命令的语法如下： docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 其中，CONTAINER 是要连接的容器的名称或 ID，COMMAND 是要在容器内部运行的命令，ARG 是命令的参数。 例如，假设想要在名为 my_container 的容器内部运行命令 ls -l，可以使用下面的命令： 1docker exec my_container ls -l 要在容器中使用 bash，举例如下： 12345[root@localhost test]# docker exec -ti a0bb97c292d1 /bin/bashroot@a0bb97c292d1:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@a0bb97c292d1:/# exitexit 删除容器 可以使用docker rm [OPTIONS] CONTAINER [CONTAINER...]命令删除处于终止状态的容器。 可选参数： -f，–force=false 强行终止并删除一个运行中的容器 -l，–link=false 删除容器的连接，但保留容器 -v，–volumes=false 删除容器挂载的数据卷 扩展 docker rm $(docker ps -a -q)，删除所有容器 导入导出 导出容器是指导出一个已经创建好的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export CONTAINER命令。 12345678[root@localhost test]# docker run -tid ubuntu:14.04547e74d47ec3eb30736aee22c1b7bf2acd6e71470a1ade4561007a10b3b14a36[root@localhost test]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES547e74d47ec3 ubuntu:14.04 &quot;/bin/bash&quot; 6 seconds ago Up 5 seconds unruffled_jennings[root@localhost test]# docker export 547 &gt; test.tar[root@localhost test]# lstest.tar 导出的文件又可以使用docker import命令导入，成为镜像。 12345678910[root@localhost test]# lstest.tar[root@localhost test]# cat test.tar | docker import - test/ubuntu:v1.0sha256:1ab7c63a882a9bc13ff4673081a237ba8785d47ba69458bfe976c0e5fc7b9c99[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/ubuntu v1.0 1ab7c63a882a 22 seconds ago 175MBubuntu 14.04-server ae63a9e87332 2 hours ago 215MBsecurityweekly/test latest 68ceff3107a8 3 hours ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB 其他命令 docker --help 查看帮助命令 docker logs：用于查看容器的日志输出。 docker volume ls 查看 volume 列表 docker network ls 查看网络列表 这只是一些常用的 Docker 命令，Docker 还有很多其他的命令和功能。有关 Docker 命令的完整列表，可以参考 Docker 的官方文档 参考 Docker 快速入门 Docker安装与基本操作","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"技术/容器","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"技术/容器/Docker","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"容器","permalink":"http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.heyb.top/tags/Docker/"}]},{"title":"「RDS」华为云 RDS 恢复误删MySQL数据恢复流程","slug":"技术/云/「RDS」华为云 RDS 恢复误删MySQL数据恢复流程","date":"2022-11-30T16:00:00.000Z","updated":"2022-12-25T14:31:45.886Z","comments":true,"path":"2022/12/01/[rds]-huawei-cloud-rds-recovery-process-for-mistakenly-deleting-mysql-data.html","link":"","permalink":"http://blog.heyb.top/2022/12/01/[rds]-huawei-cloud-rds-recovery-process-for-mistakenly-deleting-mysql-data.html","excerpt":"","text":"背景 本文是记录 2021年4月25日云数据恢复操作 大致流程是通过 binlog 恢复 mysql 中的数据，我们购买的是华为云 RDS，所以直接在 RDS 进行操作。 RDS 它的恢复流程是会先将数据全量恢复到 指定日期，再重放 binlog 操作到指定时间点。 过程 登录华为云服务器管理后台 在「关注资源」（或者左边菜单栏） - 选中 「云数据库 RDS」 在 RDS 控制台中选中 「备份管理」，下载两个备份数据。一个是今天0425日的（是我服务器停机后手动备份的，时间点为：2021/04/25 14:57:39）， 一个是昨日RDS 自动备份的（时间点为2021/04/24 20:51:38） 在 RDS 控制台中选中「数据库管理服务（DAS）」，此时会新打开一个 DAS窗口 在 DAS 控制台菜单中选中「开发工具」，点击实例名称，如rds-001(192.168.10.20 在上菜单栏中选择「binlog」标签 =&gt; 「归档日志」-「起止时间」- 输入具体日期，如 2021/04/24 21:30:00 到 2021/04/24 23:59:59 点击解析日志，再点查看日志详细内容，找到我们具体注释操作（动作描述为数据表 xxx 发生 DDL 操作）的具体时间（变更时间）， 举个例子为 22 点整，我们记录下来，届时要回滚的操作就是要指定到这个**#时间点#** 回到 RDS 窗口，在 RDS 控制台中选中 「实例管理」，点击实例的名称 - 如rds -001 296ce7f544bd4e889d2e38b934bf80cain01 进入到具体实例的详情中 在左侧菜单选择「备份恢复」，选择 「binlog备份」标签 「恢复到指定时间点」是指整个库一起恢复，「表级时间点恢复」可以勾选具体表来进行恢复，我们依据需求进行选择，时间点设置到我们进行 DDL操作前的 #时间点#，然后进行恢复 恢复后我们要恢复对误操作时间点之后的系统操作（即普通用户操作），有两种方法，一种是直接比对时间点后的数据（如根据时间去查询数据，然后比对两份数据），另外一种是在 DAS 中解析 binlog，依据日志对数据重新进行设置值，直至最终恢复完毕","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"RDS","slug":"技术/RDS","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/"},{"name":"华为云","slug":"技术/RDS/华为云","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/%E5%8D%8E%E4%B8%BA%E4%BA%91/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"华为云","slug":"华为云","permalink":"http://blog.heyb.top/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"RDS","slug":"RDS","permalink":"http://blog.heyb.top/tags/RDS/"}]},{"title":"「Go」Go-搭建IM即时通讯系列文章1-搭建基础框架","slug":"技术/go/「Go」Go-搭建IM即时通讯系列文章1-搭建基础框架","date":"2022-11-27T15:06:20.000Z","updated":"2022-12-25T14:29:19.675Z","comments":true,"path":"2022/11/27/go-go---building-im-instant-messaging-series-1---building-the-infrastructure.html","link":"","permalink":"http://blog.heyb.top/2022/11/27/go-go---building-im-instant-messaging-series-1---building-the-infrastructure.html","excerpt":"","text":"通过「Go」Go 组件系列文章，我们已经了解了一些组件的基本使用。下面我们将以实现登录功能为目标来完整的搭建一个基础框架。 和上述步骤一样，我们从配置项搭建开始，在 项目根目录/src/main/ 目录下新建一个 config 目录，用于存放配置文件。在该目录下新建 database、settings 目录，并分别新建 database.go 和 settings.go 文件，用做初始化读取配置（viper）以及初始化数据库操作（grom）。 Viper 读取配置 settings.go 提供了读取配置并设置到全局实体提供给其他类使用，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// Package settings/**此文件用于读取配置文件 app.yml，并设置到对应实体，以提供给其他文件使用。因此该文件需要优先进行初始化操作*/package settingsimport ( &quot;fmt&quot; &quot;github.com/spf13/viper&quot; &quot;time&quot;)// 定义实体装载配置文件内容// Settings 设置type Settings struct &#123; Server Server `mapstructure:&quot;server&quot;` Database Database `mapstructure:&quot;db&quot;`&#125;var Setting = &amp;Settings&#123;&#125;// Server 服务type Server struct &#123; // Url 地址 Url string `mapstructure:&quot;url&quot;` // Port 端口 Port int `mapstructure:&quot;port&quot;` // ReadTimeout 读取超时 ReadTimeout time.Duration `mapstructure:&quot;readTimeout&quot;` // WriteTimeout 写入超时 WriteTimeout time.Duration `mapstructure:&quot;writeTimeout&quot;`&#125;var ServerSetting = &amp;Server&#123;&#125;// Database 数据库type Database struct &#123; // Type 类型 Type string `mapstructure:&quot;type&quot;` User string `mapstructure:&quot;user&quot;` Password string `mapstructure:&quot;password&quot;` Host string `mapstructure:&quot;host&quot;` Name string `mapstructure:&quot;name&quot;` TablePrefix string `mapstructure:&quot;prefix&quot;`&#125;var DatabaseSetting = &amp;Database&#123;&#125;// Setup 设置func Setup() &#123; // 配置文件名(不带扩展名，即 app.yml 只需要app这部分) viper.SetConfigName(&quot;app&quot;) // 如果配置文件名称中没有扩展名，则为必填项 viper.SetConfigType(&quot;yaml&quot;) // 在其中查找配置文件的路径 viper.AddConfigPath(&quot;src/resource/&quot;) // 查找并读取配置文件 err := viper.ReadInConfig() if err != nil &#123; // 处理读取配置文件时出现的错误 panic(fmt.Errorf(&quot;读取配置异常: %w&quot;, err)) &#125; fmt.Println(&quot;初始化配置文件成功&quot;) viper.WatchConfig() // 将配置信息解析为实体 err = viper.UnmarshalKey(&quot;settings&quot;, Setting) if err != nil &#123; panic(fmt.Errorf(&quot;读取配置异常，解析失败: %w&quot;, err)) &#125; // 设置为全局变量，后续有其他配置则新增实体和变量即可 ServerSetting = &amp;Setting.Server DatabaseSetting = &amp;Setting.Database // 设置初始值 // 超时时间单位设置为秒 ServerSetting.ReadTimeout = ServerSetting.ReadTimeout * time.Second ServerSetting.WriteTimeout = ServerSetting.WriteTimeout * time.Second&#125; 该类主要操作 读取配置文件并解析为实体 设置全局变量提供给其他类使用 设置初始值 Gorm 连接数据库 database.go 提供了初始化数据库连接的操作，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package databaseimport ( &quot;fmt&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot; &quot;gorm.io/gorm/logger&quot; &quot;log&quot; &quot;os&quot; &quot;star-im/src/main/config/settings&quot; &quot;time&quot;)// DBS 定义全局变量，提供给其他方法调用var DBS *gorm.DB// Setup 初始化数据库连接// https://gorm.io/zh_CN/func Setup() &#123; var err error //定义连接路径 dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;, settings.DatabaseSetting.User, settings.DatabaseSetting.Password, settings.DatabaseSetting.Host, settings.DatabaseSetting.Name) // 连接数据库，并设置基本的配置 // 日志 newLogger := logger.New( log.New(os.Stdout, &quot;\\r\\n&quot;, log.LstdFlags), // io writer（日志输出的目标，前缀和日志包含的内容） logger.Config&#123; // 慢 SQL 阈值 SlowThreshold: time.Second, // 日志级别 LogLevel: logger.Silent, // 忽略ErrRecordNotFound（记录未找到）错误 IgnoreRecordNotFoundError: true, // 彩色打印 Colorful: true, &#125;, ) DBS, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123; Logger: newLogger, &#125;) if err != nil &#123; panic(fmt.Errorf(&quot;初始化数据库异常: %w&quot;, err)) &#125; // 获取通用数据库对象 sql.DB ，然后使用其提供的功能 sqlDB, err := DBS.DB() // 用于设置连接池中空闲连接的最大数量。 sqlDB.SetMaxIdleConns(10) // 设置打开数据库连接的最大数量。 sqlDB.SetMaxOpenConns(100) // 设置了连接可复用的最大时间。 sqlDB.SetConnMaxLifetime(time.Hour)&#125; 该类主要操作 读取数据库连接配置 初始化数据库连接 定义了 慢 SQL 日志配置 设置了数据库连接池配置 返回全局变量DBS供其他类使用 Init 加载配置 在 项目根目录/src/main/config 目录下新建 init.go 文件，用于初始化上面两个配置项。 init.go 代码如下： 1234567891011121314151617package configimport ( &quot;star-im/src/main/config/database&quot; &quot;star-im/src/main/config/redis&quot; &quot;star-im/src/main/config/settings&quot;)// Initial 初始化func Initial() &#123; // 初始化配置 settings.Setup() // 初始化数据库连接 database.Setup() // 后续有其他配置项可以在下面添加……&#125; 该文件到时候放在main方法中执行即可 Main 程序入口 在 项目根目录 下新建一个 main.go 作为我们作为http程序主入口，参考 gin 章节初始化gin main.go 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;star-im/src/main/config&quot; &quot;star-im/src/main/config/settings&quot; &quot;star-im/src/main/routers&quot;)// init 初始化func init() &#123; // 初始化配置项 config.Initial()&#125;func main() &#123; // 路由 routersInit := routers.Setup() // 读取超时 readTimeout := settings.ServerSetting.ReadTimeout // 写入超时 writeTimeout := settings.ServerSetting.WriteTimeout // 端口 endPoint := fmt.Sprintf(&quot;:%d&quot;, settings.ServerSetting.Port) // 最大 header 数 maxHeaderBytes := 1 &lt;&lt; 20 // 配置 http Server server := &amp;http.Server&#123; Addr: endPoint, Handler: routersInit, ReadTimeout: readTimeout, WriteTimeout: writeTimeout, MaxHeaderBytes: maxHeaderBytes, &#125; log.Printf(&quot;[info] 启动http服务器侦听 %s&quot;, endPoint) // 启动服务 err := server.ListenAndServe() if err != nil &#123; // 启动异常 panic(fmt.Errorf(&quot;启动服务异常：%w&quot;, err)) &#125;&#125; 该类主要操作 初始化配置 初始化路由配置以及服务基础设置 routers.Setup() ，路由等信息单独放在另外一个目录 routers中来统一管理。 router 路由配置 在 项目根目录/src/main/ 目录下新建一个 routers 目录，并按照层级建立 api/v1 两个目录，用于存放路由接口。v1 表示接口版本号，方便后续迭代接口版本。 在 项目根目录/src/main/routers/api 目录下创建 health.go ，代码如下： 1234567891011121314package apiimport ( &quot;github.com/gin-gonic/gin&quot; &quot;star-im/src/main/common/app&quot;)// Ping 接口连通性测试func Ping(c *gin.Context) &#123; // 直接返回成功结果 c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;成功&quot;, &#125;)&#125; 该类主要做连通性测试，因此直接返回json成功数据 在 项目根目录/src/main/routers 目录下创建 router.go 文件用于初始化路由配置，代码如下 1234567891011121314151617181920212223242526package routersimport ( &quot;github.com/gin-gonic/gin&quot; &quot;io&quot; &quot;os&quot; &quot;star-im/src/main/handler&quot; &quot;star-im/src/main/routers/api&quot;)// Setup 初始化路由func Setup() *gin.Engine &#123; r := gin.Default() // 记录到文件 f, _ := os.Create(&quot;gin.log&quot;) gin.DefaultWriter = io.MultiWriter(f) // 使用中间件 // 统一日志 r.Use(gin.Logger()) // 不需要鉴权 r.GET(&quot;/ping&quot;, api.Ping) return r&#125; 该类主要操作 初始化路由设置 指定记录日志到文件 指定具体的路由地址以及请求方式和响应函数 这时候我们启动根目录下的 main函数即可启动服务，通过浏览器访问：http://localhost:8081/ping 可以得到返回值 1&#123;&quot;msg&quot;: &quot;成功&quot;&#125; 到这一步我们已经能够提供一个提供基础访问的应用，后续我们继续完善应用的内容。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"}]},{"title":"「Go」Go-搭建IM即时通讯系列文章2-统一返回值及异常处理","slug":"技术/go/「Go」Go-搭建IM即时通讯系列文章2-统一返回值及异常处理","date":"2022-11-27T15:06:20.000Z","updated":"2022-12-25T14:29:33.480Z","comments":true,"path":"2022/11/27/go-go---building-im-instant-messaging-series-2---unified-return-values-and-exception-handling.html","link":"","permalink":"http://blog.heyb.top/2022/11/27/go-go---building-im-instant-messaging-series-2---unified-return-values-and-exception-handling.html","excerpt":"","text":"在软件开发过程中，通过定义统一返回值还可以提高框架的可用性和可维护性，让开发人员更容易理解和使用框架中的各种功能。同时统一异常处理能够帮助我们更好地控制程序的流程，能够让我们更好地捕获异常并作出相应的处理。这样做可以帮助我们减少代码重复，提高代码的可读性和可维护性。 统一返回值 我们规范约定返回值参数有利于我们对数据进行管理以及提升前后端开发的效率。 在 项目根目录/src/main/ 目录下新建一个common/app 层级目录，并在 app 目录下分别建立 code.go、msg.go、 response.go 用于存放 返回值、返回消息、统一返回值的实体对象。 code.go 主要定义返回值常量，代码如下： 12345678910package appimport &quot;net/http&quot;const ( // 成功使用 200 SUCCESS = http.StatusOK // 异常使用 -1 ERROR = -1) msg.go 主要定义返回值常量对应的消息内容，代码如下： 123456789101112131415161718package app// MessageMap 返回值常量对应的消息内容，消息集合：&#123;消息码，消息内容&#125;var MessageMap = map[int]string&#123; SUCCESS: &quot;成功&quot;, ERROR: &quot;失败&quot;,&#125;// GetMsg 根据代码获取返回信息func GetMsg(code int) string &#123; msg, ok := MessageMap[code] if ok &#123; return msg &#125; return MessageMap[ERROR]&#125; response.go 主要定义返回值的对象，代码如下： 12345678910111213141516171819202122232425262728293031323334353637package appimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)// Response 响应对象type Response struct &#123; // 响应编码 Code int `json:&quot;code&quot;` // 返回消息 Msg string `json:&quot;msg&quot;` // 返回数据 Data interface&#123;&#125; `json:&quot;data&quot;`&#125;// Res 设置 gin.JSON 的内容func Res(c *gin.Context, httpCode, errCode int, data interface&#123;&#125;) &#123; c.JSON(httpCode, Response&#123; Code: errCode, Msg: GetMsg(errCode), Data: data, &#125;) return&#125;// Success 返回成功结果func Success(c *gin.Context, data interface&#123;&#125;) &#123; Res(c, http.StatusOK, SUCCESS, data)&#125;// Error 返回错误结果，异常结果放在统一异常处理 handler中func Error(c *gin.Context, data interface&#123;&#125;) &#123; Res(c, http.StatusOK, ERROR, data)&#125; 这时我们可以修改 src/main/routers/api/health.go 中返回的结果如下： 12345678910111213package apiimport ( &quot;github.com/gin-gonic/gin&quot; &quot;star-im/src/main/common/app&quot;)// Ping 接口连通性测试func Ping(c *gin.Context) &#123; // 直接返回成功结果 app.Success(c, nil)&#125; 这时候我们通过浏览器访问 http://localhost:8081/ping，得到如下返回： 12345&#123; &quot;code&quot;:200, &quot;msg&quot;:&quot;成功&quot;, &quot;data&quot;:null,&#125; 这时候我们就可以根据不同的返回值进行不同的业务处理了 统一异常处理 我们需要统一处理系统的异常信息并让异常结果也显示为统一的返回结果对象，那么需要进行统一异常处理。 在 项目根目录/src/main/ 目录下新建一个 handler 目录，并在目录下新建一个 exception.go 文件，用于处理异常信息 exception.go 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package handlerimport ( &quot;github.com/gin-gonic/gin&quot; &quot;log&quot; &quot;net/http&quot; &quot;runtime/debug&quot; &quot;star-im/src/main/common/app&quot;)// Recover 注意 Recover 要尽量放在router.User的第一个被加载// 如不是的话，在recover前的中间件或路由，将不能被拦截到// 程序的原理是：// 1.请求进来，执行recover// 2.程序异常，抛出panic// 3.panic被 recover捕获，返回异常信息，并Abort,终止这次请求func Recover(c *gin.Context) &#123; defer func() &#123; r := recover() if r != nil &#123; //打印错误堆栈信息 log.Printf(&quot;panic: %v\\n&quot;, r) debug.PrintStack() //封装通用json返回 c.JSON(http.StatusOK, app.Response&#123; Code: app.ERROR, Msg: ErrorToString(r), Data: nil, &#125;) //终止后续接口调用，不加的话recover到异常后，还会继续执行接口里后续代码 c.Abort() &#125; &#125;() //加载完 defer recover，继续后续接口调用 c.Next()&#125;// ErrorToString recover错误，转stringfunc ErrorToString(r interface&#123;&#125;) string &#123; switch v := r.(type) &#123; case error: return v.Error() default: return r.(string) &#125;&#125; 该类主要捕获panic异常，并返回 json 信息给客户端 在 src/main/routers/router.go 文件中添加如下代码即可。 12// 统一异常处理r.Use(handler.Recover) 此时我们可以修改router中 /ping 的方法来测试结果 将 src/main/routers/router.go 中如下代码 1r.GET(&quot;/ping&quot;, api.Ping) 修改为： 12345r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; // 无意抛出 panic var slice = []int&#123;1, 2, 3, 4, 5&#125; slice[6] = 6 &#125;) 然后重启项目，通过浏览器访问 http://localhost:8081/ping，得到如下返回： 12345&#123; &quot;code&quot;:-1, &quot;msg&quot;:&quot;runtime error: index out of range [6] with length 5&quot;, &quot;data&quot;:null,&#125; 现在我们得到的就是统一的异常返回值，这里的 msg 可以根据需要再进行修改。 在业务中我们可以通过判断业务逻辑，再进行抛出异常，如将刚才函数中的内容修改为如下代码： 123456r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; // 抛出 panic, true这里可以改为自己的业务处理逻辑 if true &#123; panic(&quot;抛出了指定的异常信息&quot;) &#125;&#125;) 通过浏览器访问 http://localhost:8081/ping，得到如下返回： 12345&#123; &quot;code&quot;:-1, &quot;msg&quot;:&quot;抛出了指定的异常信息&quot;, &quot;data&quot;:null,&#125; 可以看到成功捕获了 panic 抛出的异常信息，这可以很方便我们做业务逻辑的时候处理异常。（测试成功后记得把ping的函数恢复回之前的） gin router 中也提供了针对 NoRoute 和 NoMethod 的处理，在 router.go 中添加 123// 处理404r.NoRoute(handler.HandleNotFound)r.NoMethod(handler.HandleNotFound) 在 src/main/handler/exception.go 中添加处理方法，直接返回处理结果即可 1234567891011func HandleNotFound(c *gin.Context) &#123; // 我这里使用的是统一返回值 app.ErrorWithCode(c, app.NOT_FOUND, nil) // // 你们也可以直接使用普通的返回结果，如下 // c.JSON(http.StatusOK, gin.H&#123; // &quot;msg&quot;: &quot;找不到资源&quot;, // &quot;code&quot;: 404, // &quot;data&quot;: &quot;&quot; // &#125;) return&#125; swag 接口文档 Swagger是一种API框架，它可以为REST APIs定义、生成、测试和文档化。它使用一种名为Swagger元数据的特殊格式来描述API，并使用Swagger UI来展示API的定义。这使得开发人员可以在不离开API文档的情况下测试API，并且可以轻松地为API创建文档。 我们引入 Swagger 来生成接口文档，方便统一管理接口及调试。 相关链接： GitHub 安装 1go install github.com/swaggo/swag/cmd/swag@latest 使用 1swag init -o &quot;src/main/docs&quot; -o 为 output，指定输出目录，默认为“./docs” 其他更多文章参考 GitHub中文文档 在主程序入口 main.go 中可以添加如下注释： 123456// @title Star-IM// @version 1.0// @description 即时通讯接口文档func main() &#123; ……&#125; 在 src/main/routers/api/health.go 文件中添加如下注释 123456789// Ping// @Summary 健康检查// @Description 接口连通性测试// @Tags 测试// @Success 200 &#123;object&#125; app.Response// @Router /ping [get]func Ping(c *gin.Context) &#123; ……&#125; 在 src/main/routers/router.go 加入swagger接口文档的访问，并引入指定了目录的swagger文件 代码如下： 1234567891011121314151617181920212223242526272829303132package routersimport ( &quot;github.com/gin-gonic/gin&quot; swaggerFiles &quot;github.com/swaggo/files&quot; ginSwagger &quot;github.com/swaggo/gin-swagger&quot; &quot;io&quot; &quot;os&quot; _ &quot;star-im/src/main/docs&quot; &quot;star-im/src/main/handler&quot; &quot;star-im/src/main/routers/api&quot;)// Setup 初始化路由func Setup() *gin.Engine &#123; r := gin.Default() // 记录到文件 f, _ := os.Create(&quot;gin.log&quot;) gin.DefaultWriter = io.MultiWriter(f) // 使用中间件 // 统一异常处理 r.Use(handler.Recover) // 统一日志 r.Use(gin.Logger()) // 不需要鉴权 r.GET(&quot;/ping&quot;, api.Ping) r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler)) return r&#125; 主要变更内容为 import _ &quot;star-im/src/main/docs&quot; import swaggerFiles &quot;github.com/swaggo/files&quot; import ginSwagger &quot;github.com/swaggo/gin-swagger&quot; r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler)) 测试 通过浏览器访问 http://localhost:8081/swagger/index.html#/ 可以进入到swagger 接口文档的管理界面 至此，当前目录结构为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.├── LICENSE├── README.md├── doc│ └── build│ └── 1-framwork.md├── gin.log├── go.mod├── go.sum├── main.go└── src ├── main │ ├── common │ │ └── app │ │ ├── code.go │ │ ├── msg.go │ │ └── response.go │ ├── config │ │ ├── database │ │ │ └── database.go │ │ ├── init.go │ │ └── settings │ │ └── settings.go │ ├── docs │ │ ├── docs.go │ │ ├── swagger.json │ │ └── swagger.yaml │ ├── handler │ │ └── exception.go │ ├── models │ │ └── model.go │ ├── routers │ │ ├── api │ │ │ ├── health.go │ │ │ └── v1 │ │ └── router.go │ └── util ├── resource │ └── app.yml └── test └── pkg ├── test_gin.go ├── test_gorm.go ├── test_jwt.go ├── test_redis.go └── test_viper.go","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"}]},{"title":"「Windows」Windows “因为在此系统上禁止运行脚本”解决办法","slug":"技术/windows/「Windows」Windows “因为在此系统上禁止运行脚本”解决办法","date":"2022-11-26T09:11:21.000Z","updated":"2022-12-25T14:31:30.051Z","comments":true,"path":"2022/11/26/windows-windows-because-running-scripts-on-this-system-is-disabled-solution.html","link":"","permalink":"http://blog.heyb.top/2022/11/26/windows-windows-because-running-scripts-on-this-system-is-disabled-solution.html","excerpt":"","text":"背景 最近升级了windows11，然后在系统上安装一些常用工具，遇到了如下的问题。 nrm : 无法加载文件 C:\\Users\\用户名\\AppData\\Roaming\\npm\\nrm.ps1，因为在此系统上禁止运行脚本。 解决方法 处理方案在提示中有，可以通过访问链接查看：https://go.microsoft.com/fwlink/?LinkID=135170 核心是power shell的安全策略，将 nrm 命令视为了不安全脚本，不允许执行。只需要放开权限就行。 我们通过管理员权限运行power shell，然后输入命令 1set-ExecutionPolicy RemoteSigned 选择“是”，就OK了。 如果要恢复策略则设置则执行 1set-ExecutionPolicy Default 参考 https://zhuanlan.zhihu.com/p/493496089","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Windows","slug":"技术/Windows","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Windows/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.heyb.top/tags/Windows/"}]},{"title":"「Go」Go 组件系列文章4-gin","slug":"技术/go/「Go」Go 组件系列文章4-gin","date":"2022-11-23T09:54:20.000Z","updated":"2022-12-25T14:28:59.028Z","comments":true,"path":"2022/11/23/go-go-component-series-4-gin.html","link":"","permalink":"http://blog.heyb.top/2022/11/23/go-go-component-series-4-gin.html","excerpt":"","text":"简介 Go Gin是一个用Go语言编写的HTTP Web框架。它旨在提供一个简洁而强大的方式来构建Web应用程序。它因为 httprouter 的性能提高了40倍。具有良好的性能，并且提供了许多有用的功能，例如路由，中间件，模板渲染等。它还具有很好的扩展性，可以与其他Go库和框架集成使用。 相关链接： GitHub 安装 1go get github.com/gin-gonic/gin 测试 在 项目根目录/src/test/pkg 目录下新建 test_gin.go 测试文件 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; // 默认返回一个已连接日志记录器和恢复中间件的引擎实例。 r := gin.Default() // 绑定路由 /ping，访问后执行func的方法 r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; // 返回一个 json， 状态值为 200， H的内容为 map[string] c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;pong&quot;, &#125;) &#125;) // 在0.0.0.0：8080上侦听和服务(对于Windows“为 localhost：8080”) err := r.Run() if err != nil &#123; fmt.Println(&quot;启动服务异常：&quot;, err) &#125;&#125; 通过浏览器访问：http://localhost:8081/ping 得到如下信息： 123&#123; &quot;message&quot;: &quot;pong&quot;&#125; 此时我们就已经完成了http框架的测试，官方 GitHub 文档有提供不同请求方式、参数绑定、文件上传等示例，可以参考学习。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"gin","slug":"gin","permalink":"http://blog.heyb.top/tags/gin/"}]},{"title":"「Go」Go 组件系列文章3-gorm","slug":"技术/go/「Go」Go 组件系列文章3-gorm","date":"2022-11-22T09:22:20.000Z","updated":"2022-12-25T14:28:47.622Z","comments":true,"path":"2022/11/22/go-go-component-series-3-gorm.html","link":"","permalink":"http://blog.heyb.top/2022/11/22/go-go-component-series-3-gorm.html","excerpt":"","text":"简介 GORM 是一个用于构建 Go 语言应用程序的对象关系映射（ORM）库。它可以帮助开发人员在 Go 语言项目中更轻松地使用数据库。它支持多种数据库，包括 MySQL、PostgreSQL 和 SQLite，并提供了一组简单易用的 API，可以让开发人员使用 Go 语言的结构体来描述数据库表和字段，并通过这些结构体来执行数据库操作。并支持事务、批量操作等等。和Java的hibernate框架相似。 相关链接： GitHub GORM中文网 使用 安装 要使用 gorm.io/gorm，首先需要安装它。可以使用 Go 语言的包管理工具 go mod 来安装： 12go get gorm.io/gormgo get gorm.io/driver/mysql 安装完成后，在 Go 语言项目中就可以引入 gorm 包并使用它了。首先，需要创建一个 gorm.DB 类型的变量，用于表示与数据库的连接： 123import &quot;gorm.io/gorm&quot;var db *gorm.DB 然后，使用 gorm.Open() 函数来连接到数据库： 12345db, err := gorm.Open(&quot;mysql&quot;, &quot;user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;)if err != nil &#123; panic(&quot;failed to connect database&quot;)&#125;defer db.Close() 其中 user 和password 为连接数据库的用户和密码，dbname 为库名，后面设置根据自己需求设置。 以下为完整实例： 创建数据库的步骤忽略，我们约定数据库名称为star-im，用户名和密码均为root。 在 项目根目录/src/test/pkg 目录下新建 test_gorm.go 测试文件，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( &quot;fmt&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot;)// TestProduct 定义一个实体type TestProduct struct &#123; // gorm.Model 提供了基础实体的定义，包含了id, CreatedAt, UpdatedAt, DeletedAt 字段 gorm.Model // Name 商品名称 Name string // Price 商品价格 Price uint&#125;// 测试 ORM 框架 —— 连接 MySQL https://github.com/go-gorm/gormfunc main() &#123; // 连接信息，字符串中内容分别为：用户名:密码@连接方式(Host:Port)/数据库名?字符集&amp;解析时间&amp;默认时间 // 更多参数详见：https://github.com/go-sql-driver/mysql#parameters dsn := &quot;root:root@tcp(127.0.0.1:3306)/star-im?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot; // 连接数据库，并设置基本的配置 db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;) if err != nil &#123; // 如果连接有异常则打印 fmt.Println(&quot;连接数据库失败：&quot;, err) &#125; // 迁移 schema，如果数据库该表没有则创建表 err = db.AutoMigrate(&amp;TestProduct&#123;&#125;) if err != nil &#123; fmt.Println(&quot;创建数据库表异常：&quot;, err) &#125; // Create 创建记录 // 定义实体 product := &amp;TestProduct&#123;Name: &quot;奶茶&quot;, Price: 100&#125; // 创建记录 result := db.Create(product) // 创建成功后会返回插入数据的主键给实体赋值 ID fmt.Println(&quot;ID为：&quot;, product.ID) fmt.Println(&quot;如果有异常，则会输出：&quot;, result.Error) fmt.Println(&quot;返回插入记录的条数：&quot;, result.RowsAffected) // Find 查询 prod := db.First(&amp;product, &quot;name = ?&quot;, &quot;奶茶&quot;) fmt.Println(&quot;查询数:&quot;, prod.RowsAffected) // 查找后返回实体 prod2 := TestProduct&#123;&#125; db.Where(&quot;name = ?&quot;, &quot;奶茶&quot;).First(&amp;prod2) fmt.Println(&quot;实体：&quot;, prod2) // Update - 修改 // 将 product 的 price 更新为 200 db.Model(&amp;product).Update(&quot;Price&quot;, 200) // Update - 更新多个字段 db.Model(&amp;product).Updates(TestProduct&#123;Price: 200, Name: &quot;蛋糕&quot;&#125;) // 仅更新非零值字段 db.Model(&amp;product).Updates(map[string]interface&#123;&#125;&#123;&quot;Price&quot;: 200, &quot;Name&quot;: &quot;蛋糕&quot;&#125;) // Delete - 逻辑删除 product，会修改 deleted_at，标记为删除 db.Delete(&amp;product, 1)&#125; 执行程序后在控制台输出如下结果： 12345ID为： 1如果有异常，则会输出： &lt;nil&gt;返回插入记录的条数： 1查询数: 1实体： &#123;&#123;1 2022-11-22 16:53:58.969 +0800 CST 2022-11-22 16:53:58.969 +0800 CST &#123;0001-01-01 00:00:00 +0000 UTC false&#125;&#125; 奶茶 100&#125; 其他更多操作请参考 GORM中文网 ，以及 约束、连接池 、日志 等配置可根据自身需求学习设置。我在后续过程中也会讲解并设置。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"gorm","slug":"gorm","permalink":"http://blog.heyb.top/tags/gorm/"}]},{"title":"「Go」Go 组件系列文章2-viper","slug":"技术/go/「Go」Go 组件系列文章2-viper","date":"2022-11-21T11:41:20.000Z","updated":"2022-12-25T14:28:33.077Z","comments":true,"path":"2022/11/21/go-go-component-series-2-viper.html","link":"","permalink":"http://blog.heyb.top/2022/11/21/go-go-component-series-2-viper.html","excerpt":"","text":"简介 Viper是一个完整的Go应用程序配置解决方案，可以用于读取 JSON、TOML、YAML、HCL、env file和Java properties 配置文件。可以使用简单的方法来读取和设置配置值，并且可以设置默认值和类型转换器来确保程序始终能够读取到有效的配置值。 我们通常将一些配置信息，如数据库的访问路径，端口号等存放在配置文件中方便统一修改。 在 Java 中通常为 application.yml 或者 applicatiton.properties 文件，然后在 springboot 框架下使 用 @ConfigurationProperties(prefix=”setting_name”) 或者 @Value(“valueStr”) 的形式来读取。 Viper 就是 go 用于做这一部分的工作类库 相关链接： GitHub PKG 安装 在项目中打开命令行执行如下命令 1go get github.com/spf13/viper 使用 在 项目根目录/src/resource 资源目录下新建一个 app.yml 配置文件，并写入以下配置项 1234settings: server: url: localhost port: 8081 注：我们现在约定 settings 为配置项根节点，之后新增例如 settings:database之类的节点，则是在settings下新增一个 database 节点，而不是重复设置多一个 settings。 其他新增/修改项也遵循此说法。 如在settings下新增 database 内容， 并修改 server下的端口号为9999，示例如下： 正确示例为： 123456settings: server: url: localhost port: 9999 database: type: mysql 错误示例为： 12345678910settings: server: url: localhost port: 8081 server: port: 9999settings: database: type: mysql 测试 在 项目根目录/src/test 目录下新建一个 pkg 目录，用于测试引入的第三方类库。在目录下新建 test_viper.go 测试文件 12345678910111213141516171819202122232425262728293031323334// main 方法必须使用 main 包package main// 引入依赖import ( &quot;fmt&quot; &quot;github.com/spf13/viper&quot;)// 主要执行的方法func main() &#123; // 配置文件名(不带扩展名，即 app.yml 只需要app这部分) viper.SetConfigName(&quot;app&quot;) // 如果配置文件名称中没有扩展名，则为必填项 viper.SetConfigType(&quot;yaml&quot;) // 在其中查找配置文件的路径 viper.AddConfigPath(&quot;src/resource/&quot;) // 查找并读取配置文件 err := viper.ReadInConfig() if err != nil &#123; // 处理读取配置文件时出现的错误 panic(fmt.Errorf(&quot;读取配置异常，原因为: %w&quot;, err)) &#125; // 打印内容到控制台 fmt.Println(&quot;初始化 app 配置成功&quot;) // 获取配置文件中的参数 url := viper.GetString(&quot;settings.server.url&quot;) port := viper.GetString(&quot;settings.server.port&quot;) // 打印参数 fmt.Printf(&quot;配置中的服务器地址及端口号为：%s:%s&quot;, url, port)&#125; 执行程序后在控制台输出如下结果： 12初始化 app 配置成功配置中的服务器地址及端口号为：localhost:8081","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"viper","slug":"viper","permalink":"http://blog.heyb.top/tags/viper/"}]},{"title":"「Go」Go 组件系列文章1-modules","slug":"技术/go/「Go」Go 组件系列文章1-modules","date":"2022-11-21T11:28:20.000Z","updated":"2022-12-25T14:28:00.543Z","comments":true,"path":"2022/11/21/go-go-component-series-1-modules.html","link":"","permalink":"http://blog.heyb.top/2022/11/21/go-go-component-series-1-modules.html","excerpt":"","text":"简介 模块是一组发布和版本化为单个单元的 Go 包。modules是源代码交换和版本控制的单元。go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。 go mod 是 Go 编程语言中用于管理模块依赖关系的一个命令。 go mod 允许您轻松地在 Go 项目中添加、删除和更新依赖项，以及管理依赖项的版本，以确保兼容性和可重复性。 go modules 可以理解为 maven / gradle 等工具 官方文档及介绍 使用 在使用 go mod 前，需要在项目目录下执行 go mod init &lt;name&gt; 命令来初始化模块。 例如，我们以项目 star-im 为例进行初始化，在项目根目录（star-im/）中执行 1go mod init star-im 会在根目录生成一个 go.mod 的文件来进行包依赖的管理，其中会包含我们所需要的依赖及版本内容，此外某些依赖后面会有 indirect 字样，表示该依赖为传递依赖，也就是非直接依赖。 其他命令如： 123456789go mod &lt;command&gt;download download modules to local cache -- 将模块下载到本地缓存edit edit go.mod from tools or scripts -- 从工具或脚本编辑 go.mod 以编辑依赖关系graph print module requirement graph -- 查看依赖关系图init initialize new module in current directory -- 初始化当前目录中的新模块tidy add missing and remove unused modules -- 添加缺少的模块并删除未使用的模块vendor make vendored copy of dependencies -- 制作依赖项的供应商副本verify verify dependencies have expected content -- 验证依赖项是否具有预期内容why explain why packages or modules are needed -- 解释为什么需要包或模块 比较常用的是 init, tidy, edit ，当我们引入依赖包的之后，可以使用 go mod tidy 来命令来整理依赖模块。其他更多内容可参考：go mod使用 | 全网最详细 或者参考官方文档 可以使用命令 go list -m -u all 来检查可以升级的package 依赖包仓库地址：https://pkg.go.dev/（相当于maven的 https://mvnrepository.com/），搜索需要的依赖包可以访问此链接，里面也包含了依赖包的使用事项等。 目前 go web 似乎没有比较成型的 web 开发标准，因此我沿用了 Java 的习惯 在根目录中新增 src 目录，以及 main、resource、test 三个下级目录，用于存放主要程序文件、资源设置文件、测试文件。 12345star-im └── src ├── main ├── resource └── test","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"go mod","slug":"go-mod","permalink":"http://blog.heyb.top/tags/go-mod/"}]},{"title":"「Python」Mac 系统切换Python版本","slug":"技术/python/「Python」Mac 系统切换Python版本","date":"2022-11-21T02:23:00.000Z","updated":"2022-12-25T14:31:00.631Z","comments":true,"path":"2022/11/21/python-mac-system-switches-python-version.html","link":"","permalink":"http://blog.heyb.top/2022/11/21/python-mac-system-switches-python-version.html","excerpt":"","text":"从MacOS 12.4 Beta版(21F5048e) 开始，可以通过pyenv在intel和Apple芯片中安装python2。 例如在M1中安装 2.7.18 版本的 python2。 首先在系统上安装 pyenv 12# 下载 pyenvbrew install pyenv 接下来，使用 pyenv 安装您想要使用的 Python 版本。例如，要安装 Python 2.7.18 版本，可以在终端中输入以下命令： 12# 下载指定版本pyenv install 2.7.18 安装完成后，可以使用 pyenv 的 global 命令来设置当前系统的默认 Python 版本。例如，设置默认版本为 2.7.18，可以在终端中输入以下命令： 12# 切换指定版本pyenv global 2.7.18 如果执行pyenv不生效可以手动将其加入到系统环境变量（非必须） 12# 加入到环境变量export PATH=&quot;$(pyenv root)/shims:$&#123;PATH&#125;&quot; 最后，可以通过输入 python --version 命令来检查当前使用的 Python 版本是否已经切换成功。 12# 打印python版本python --version 如果一切顺利，将可以看到Python 2.8.18的输出。 此方法可以与brew install python3方式安装的python3共存。 如果想要临时切换到其他版本的 Python，可以在执行 Python 命令时，使用 pyenv run 命令来指定要使用的 Python 版本。 例如，要在当前终端会话中临时使用 Python 3.6.5 版本，可以在终端中输入以下命令： 1pyenv run python3.6.5 如果您想要在当前目录下的所有 Python 脚本中临时使用指定的 Python 版本，可以使用 pyenv local 命令来设置当前目录的 Python 版本。 如果遇到VS(Visual Studio Code)无法使用code命令，可以参阅博文：《MacOS 12.3 无法正常使用code命令的解决方法》。 参考 brew安装python2","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"}]},{"title":"「Java」macOS切换JDK版本","slug":"技术/java/「Java」macOS切换JDK版本","date":"2022-10-25T03:59:00.000Z","updated":"2022-12-25T14:30:41.977Z","comments":true,"path":"2022/10/25/java-macos-switches-jdk-version.html","link":"","permalink":"http://blog.heyb.top/2022/10/25/java-macos-switches-jdk-version.html","excerpt":"","text":"在 Mac 系统上切换 JDK 版本，可以使用以下步骤： 使用 Finder 或其他文件管理工具，打开系统根目录（通常是 /）。 找到 Library/Java/JavaVirtualMachines 目录，该目录下存放着系统安装的所有 JDK 版本。 找到您想要使用的 JDK 版本，例如 jdk1.8.0_261.jdk。 在该 JDK 版本目录下，找到 Contents/Home 目录，该目录下存放着 JDK 安装的核心文件。 将该目录的完整路径（例如 /Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home）复制到剪贴板。 也可以通过命令打印 Java home 1/usr/libexec/java_home -V 打印如下： 12345678910horustech@Horuss-MacBook-Pro booking % /usr/libexec/java_home -VMatching Java Virtual Machines (7): 17.0.1 (x86_64) &quot;Eclipse Temurin&quot; - &quot;Eclipse Temurin 17&quot; /Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home 16.0.2 (x86_64) &quot;Amazon.com Inc.&quot; - &quot;Amazon Corretto 16&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-16.0.2/Contents/Home 15.0.2 (x86_64) &quot;Amazon.com Inc.&quot; - &quot;Amazon Corretto 15&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-15.0.2/Contents/Home 1.8.321.07 (x86_64) &quot;Oracle Corporation&quot; - &quot;Java&quot; /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home 1.8.0_312 (x86_64) &quot;Amazon&quot; - &quot;Amazon Corretto 8&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-1.8.0_312/Contents/Home 1.8.0_312 (x86_64) &quot;Eclipse Temurin&quot; - &quot;Eclipse Temurin 8&quot; /Library/Java/JavaVirtualMachines/temurin-8.jdk/Contents/Home 1.8.0_311 (x86_64) &quot;Oracle Corporation&quot; - &quot;Java SE 8&quot; /Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home 使用终端（Terminal）工具，执行以下命令来修改 JDK 版本： 1$ export JAVA_HOME=&lt;JDK路径&gt; 例如： 1$ export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home 或者手动编辑文件添加： 打开bash_profile文件加入JAVA_HOME 1open ~/.bash_profile 添加最后一行， export JAVA_HOME=&quot;这里填刚才的路径&quot; 执行以下命令来使修改生效： 1$ source ~/.bash_profile 执行以下命令来检查 JDK 版本是否已成功切换： 1$ java -version 如果您更改了 .bashrc 或其他配置文件，请按照实际情况进行调整。 此外，您还可以使用 alternatives 命令来管理系统中安装的 JDK 版本。该命令可以让您方便地在多个 JDK 版本之间进行切换，并且可以保证系统中只有一个默认的 JDK 版本。如果您想要了解更多关于 alternatives 命令的信息，可以在终端中执行 man alternatives 命令查看相关帮助文档。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Java","slug":"技术/Java","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Java/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Java","slug":"Java","permalink":"http://blog.heyb.top/tags/Java/"}]},{"title":"「Python」PPT 转 Markdown","slug":"技术/python/「Python」PPT 转 Markdown","date":"2022-10-21T09:11:21.000Z","updated":"2022-12-25T14:31:13.060Z","comments":true,"path":"2022/10/21/[python]-ppt-to-markdown.html","link":"","permalink":"http://blog.heyb.top/2022/10/21/[python]-ppt-to-markdown.html","excerpt":"","text":"背景 最近在学习学科类课程，教师提供的课件都是PPT的形式。我自己想整理转成Markdown就需要一个个ppt去复制里面的文本，在洗澡的时候就想着能不能直接通过脚本来一键转换，然后搜了一下类库就开始操作。 开始 我检索到当前比较适合的类库——python-pptx 以下是相关网站 PYPI Github 官方文档 官方文档示例 从官方文档可以找到到获取文本的示例：官方文档 123456789101112131415161718192021222324252627# Extract all text from slides in presentation# 从演示文稿中的幻灯片中提取所有文本from pptx import Presentation# 打开 pptprs = Presentation(path_to_presentation)# text_runs will be populated with a list of strings,# one for each text run in presentationtext_runs = []# 获取 Slide 幻灯片for slide in prs.slides: # 获取形状 Shape for shape in slide.shapes: # 判断是否有文字框 text_frame if not shape.has_text_frame: continue # 获取文字框中的段落 paragraphs for paragraph in shape.text_frame.paragraphs: # 文字块 run for run in paragraph.runs: # 获取文字并加到字符串数组中 text_runs.append(run.text) # 打印测试结果 print(text_runs) 思路 创建 result 结果列表，最后我们会将全部信息存储到 result 列表中，并写入一个 md 文档当中。 ppt这个库的逻辑是逐页（page）读取每个形状（shape） 我们的程序是首先判断遇到的形状是否是文本框，如果是文本框的话，直接将全部文本信息写入results。 如果不是文本框的话再判断这个形状是不是图片对象。如果是的话，新建一个文件夹，将这个图片存储到这个文件夹中。最后将存储到本地的图片的存储路径标准化为markdown格式写入results内。 完整代码 单ppt文件转换markdown 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import collections.abc# 此处是用的是python-pptx 包# pip3 install python-pptxfrom pptx import Presentation# 操作系统（用于生产文件）import os# 正则匹配import re# PPT 文件相对路径 filepathfilepath = &quot;这里写入 ppt 的路径名称.pptx&quot;# 文件名（截取文件名开头至文件名末尾倒数 5 位）file_name = filepath[:-5]# 实例化ppt对象prs = Presentation(filepath)# 结果文本数组results = []# 获取 Slide 幻灯片for slide in prs.slides: # 获取形状 Shape for shape in slide.shapes: # 判断是否有文字框 text_frame if shape.has_text_frame: # 获取文字框中的段落 paragraphs for paragraph in shape.text_frame.paragraphs: part = [] # 文字块 run for run in paragraph.runs: text = run.text # 如果匹配 第x章，则设置为主标题 # 第一章 if re.search(&#x27;第.+章&#x27;, text): text = &#x27;# &#x27; + text # 如果匹配 一、二、三、之类的，则设置为副标题 # 一、 elif re.search(&#x27;[一二三四五六七八九十]+、&#x27;, text): text = &#x27;## &#x27; + text # 如果匹配格式为数字+小数点，类似 1.1.1 elif re.search(&#x27;\\d\\.&#x27;, text): # 则设置副标题 例如 #### 1.1.1 text = (&#x27;#&#x27; * (text.count(&#x27;.&#x27;) + 2)) + &#x27; &#x27; + text # 获取文字块并加到字符串数组中 part.append(text) results.append(&#x27;&#x27;.join(part)) # 否则判断是否为图片 else: try: imdata = shape.image.blob # 判断文件后缀类型 imagetype = shape.image.content_type typekey = imagetype.find(&#x27;/&#x27;) + 1 imtype = imagetype[typekey:] # 创建image文件夹保存抽出图片 path = &quot;图片文件夹/&#123;&#125;_image/&quot;.format(file_name) if not os.path.exists(path): os.makedirs(path) # 图片生成 image_file = path + shape.name + &quot;.&quot; + imtype name = shape.name file_str = open(image_file, &#x27;wb&#x27;) file_str.write(imdata) file_str.close() # 标准化为markdown图片格式 results.append(&#x27;![&#123;&#125;](&#123;&#125;)&#x27;.format(name, image_file)) except: pass# 去掉多余空格results = [line for line in results if line.strip()]# 写入全部results信息with open(&#x27;&#123;&#125;.md&#x27;.format(file_name), &#x27;w&#x27;) as f: f.write(&#x27;\\n&#x27;.join(results)) 如果批量操作，只需要循环目录下的文件进行操作即可 指定目录下面所有ppt转换markdown 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import collections.abc# 此处是用的是python-pptx 包# pip3 install python-pptxfrom pptx import Presentation# 操作系统（用于生产文件）import os# 正则匹配import re# 目录dir = &#x27;./课件&#x27;# 遍历目录下面的文件item = os.listdir(dir)# 遍历文件for file in item: # 如果文件名包含.pptx 则执行转换代码 if &#x27;.pptx&#x27; in file: # PPT 文件相对路径 filepath filepath = dir + &#x27;/&#x27; + file # 文件名（截取文件名开头至文件名末尾倒数 5 位） file_name = filepath[:-5] # 实例化ppt对象 prs = Presentation(filepath) # 结果文本数组 results = [] # 获取 Slide 幻灯片 for slide in prs.slides: # 获取形状 Shape for shape in slide.shapes: # 判断是否有文字框 text_frame if shape.has_text_frame: # 获取文字框中的段落 paragraphs for paragraph in shape.text_frame.paragraphs: part = [] # 文字块 run for run in paragraph.runs: text = run.text # 如果匹配 第x章，则设置为主标题 # 第一章 if re.search(&#x27;第.+章&#x27;, text): text = &#x27;# &#x27; + text # 如果匹配 一、二、三、之类的，则设置为副标题 # 一、 elif re.search(&#x27;[一二三四五六七八九十]+、&#x27;, text): text = &#x27;## &#x27; + text # 如果匹配格式为数字+小数点，类似 1.1.1 elif re.search(&#x27;\\d\\.&#x27;, text): # 则设置副标题 例如 #### 1.1.1 text = (&#x27;#&#x27; * (text.count(&#x27;.&#x27;) + 2)) + &#x27; &#x27; + text # 获取文字块并加到字符串数组中 part.append(text) results.append(&#x27;&#x27;.join(part)) # 否则判断是否为图片 else: try: imdata = shape.image.blob # 判断文件后缀类型 imagetype = shape.image.content_type typekey = imagetype.find(&#x27;/&#x27;) + 1 imtype = imagetype[typekey:] # 创建image文件夹保存抽出图片 path = &quot;图片文件夹/&#123;&#125;_image/&quot;.format(file_name) if not os.path.exists(path): os.makedirs(path) # 图片生成 image_file = path + shape.name + &quot;.&quot; + imtype name = shape.name file_str = open(image_file, &#x27;wb&#x27;) file_str.write(imdata) file_str.close() # 标准化为markdown图片格式 results.append(&#x27;![&#123;&#125;](&#123;&#125;)&#x27;.format(name, image_file)) except: pass # 去掉多余空格 results = [line for line in results if line.strip()] # 写入全部results信息 with open(&#x27;&#123;&#125;.md&#x27;.format(file_name), &#x27;w&#x27;) as f: f.write(&#x27;\\n&#x27;.join(results)) 更好的做法是将转换的代码抽离成一个函数，提供调用，这里不做展开，欢迎自己探索。 异常 如果运行代码出现 AttributeError: module 'collections' has no attribute 'abc’ 异常 123456789101112131415161718192021Traceback (most recent call last): File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/compat/__init__.py&quot;, line 10, in &lt;module&gt; Container = collections.abc.ContainerAttributeError: module &#x27;collections&#x27; has no attribute &#x27;abc&#x27;During handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;/Users/用户名/workspace/python/smallScript/office/ppt2markdown.py&quot;, line 3, in &lt;module&gt; from pptx import Presentation File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/__init__.py&quot;, line 14, in &lt;module&gt; from pptx.api import Presentation # noqa File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/api.py&quot;, line 15, in &lt;module&gt; from .package import Package File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/package.py&quot;, line 6, in &lt;module&gt; from pptx.opc.package import OpcPackage File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/opc/package.py&quot;, line 11, in &lt;module&gt; from pptx.compat import is_string, Mapping File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/compat/__init__.py&quot;, line 14, in &lt;module&gt; Container = collections.ContainerAttributeError: module &#x27;collections&#x27; has no attribute &#x27;Container&#x27; 则在python文件前引入依赖 import collections.abc 即可 参考 官方文档 看完这篇Python操作PPT总结，从此使用Python玩转Office全家桶就没有压力了！ 【python自动化】读取ppt内全部文本和图片信息并导出markdown文档","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"},{"name":"PPT","slug":"PPT","permalink":"http://blog.heyb.top/tags/PPT/"}]},{"title":"「Docker」Docker 安装 SQL Server2019","slug":"技术/容器/docker/「Docker」Docker 安装 SQL Server2019","date":"2022-10-20T15:18:10.000Z","updated":"2022-12-25T14:32:18.874Z","comments":true,"path":"2022/10/20/[docker]-docker-installation-sql-server-2019.html","link":"","permalink":"http://blog.heyb.top/2022/10/20/[docker]-docker-installation-sql-server-2019.html","excerpt":"","text":"安装 在其他分发 Docker Hub 上的 Linux 容器映像 中可以参考更多的Docker安装的内容 当前稳定版本为 2019， 预览版为 2022，这里我们使用稳定版本。 可以在 Docker 命令行界面中输入以下命令来拉取 SQL Server 2019 的镜像 1docker pull mcr.microsoft.com/mssql/server:2019-latest 这条命令会从 Microsoft 的官方镜像仓库中拉取最新版本的 SQL Server 2019 镜像 启动 拉取完成后，您可以使用以下命令来创建运行 SQL Server 2019 容器，这里密码必须为复杂密码（建议大小写英文+数字+特殊符号，这里举例为 @Password），否则无法启动。 -p 为映射端口，这里默认为 1433，可以自行修改 1docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=@Password&quot; -p 1433:1433 -d mcr.microsoft.com/mssql/server:2019-latest 这条命令会在 Docker 中运行一个 SQL Server 2019 容器，并且会把容器的 1433 端口映射到主机的 1433 端口上。然后你就可以使用预设的用户名sa，密码@Password 进行登录 此外，还有一些额外的步骤，你可以在 SQL Server 的 Docker 容器中执行。例如，你可以使用 Docker 命令行工具来进入容器，并在其中执行各种 SQL 脚本。有关更多信息，建议你参阅 Docker 官方文档。 参考 官方文档：https://www.microsoft.com/zh-cn/evalcenter/evaluate-sql-server-2019?filetype=EXE","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"技术/容器","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"技术/容器/Docker","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"容器","permalink":"http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.heyb.top/tags/Docker/"}]},{"title":"「Hexo」1-使用Hexo搭建个人博客","slug":"写作/hexo/「Hexo」1-使用Hexo搭建个人博客","date":"2022-09-09T16:00:00.000Z","updated":"2022-12-06T05:11:40.626Z","comments":true,"path":"2022/09/10/hexo-1---use-hexo-to-build-a-personal-blog.html","link":"","permalink":"http://blog.heyb.top/2022/09/10/hexo-1---use-hexo-to-build-a-personal-blog.html","excerpt":"","text":"前言 如首篇文章所说的，在很久之前我就想搭建自己的个人博客网站，以前在 csdn 的博客不知道为啥就被封禁了，懒得去申诉了。我也有想过自己开发一个，但是奈何审美水平不高，做一个好的前端页面自觉要花费很多功夫，搭建完成之后还要购买服务器来进行维护，都是比较耗费尽力的，后来找了一轮相关的资料，就找到 Hexo 这个博客的框架。觉得各方面都比较符合我的期望，下面会做一些入门的介绍。 什么是Hexo Hexo 是是一个快速、简洁且高效的静态博客框架，基于 Node.js 渲染，支持 Markdown 语法且能通过命令行一键部署到 github、heroku、coding 等网站。拥有免费且丰富的主题和插件，可以让你轻松定制你的博客网站。还阿提供了方便的命令行工具，可以帮助你快速搭建、生成和部署你的博客网站。此外文章的本体可以留存在本地备份随时修改。这一点是我比较喜欢的。 官方网站：https://hexo.io/zh-cn/ Github: https://github.com/hexojs/hexo 优点和不足 Hexo 的优点如下： 免费；轻量 基于 Node.js，易于安装和使用。 支持 Markdown 语法，使写作更加简单。 提供丰富的插件和主题，让你可以轻松定制你的博客。 提供方便的命令行工具，可以快速搭建、生成和部署你的博客网站。 原文内容在本地，迁移方便； Hexo 的缺点如下： 依赖本地环境，不太适用于不同设备上随心发布； 只支持静态网站，不支持动态网站。 对于复杂的网站，可能不太适用。 在某些情况下，它的性能可能不如其他静态网站生成器。 相对于其他类似工具，它的社区支持可能不太完善。 安装前置环境 安装前提： Github | Gitee| Coding ：资源/代码存放的仓库，目前他们均提供了相关的 pages —— 一种免费的静态站点托管服务，让我们可以在仓库里托管和发布自己的静态网站页面。 Nodejs ：Hexo 是基于 Node.js 平台开发的，所以你需要先安装 Node.js。（Node 各系统安装教程：【NODE】NODE.JS 安装配置(转)） ，建议使用 Node.js 12.0 及以上版本 Git：Hexo 使用 Git 来管理项目，将本地的 Hexo 内容提交到 Github 上去 如果你没有安装这些前置环境，建议你参阅官方文档，了解如何在你的系统上安装这些软件。 准备 Github Pages 仓库 注册Github帐号 已经有Github帐号跳过此步，首先进入Github进行注册，用户名、邮箱和密码之后都需要用到，自己记好。 在 Shell 中本地全局设置用户名和邮箱 12git config --global user.name &quot;GitHub 用户名&quot;git config --global user.email &quot;GitHub 邮箱&quot; 创建 SSH 密钥 在 Shell 中运行以下命令并多次回车 1ssh-keygen -t rsa -C &quot;Github 邮箱&quot; 然后键入以下指令： 1ssh-agent -s 出现echo Agent pid xxxxx; 继续输入指令： 1ssh-add ~/.ssh/id_rsa 如果提示错误：Could not open a connection to your authentication agent.则输入以下指令： 12eval &#x27;ssh-agent -s&#x27;ssh-add 会出现如：Identity added: /c/Users/用户/.ssh/id_rsa (/c/users/用户/.ssh/id_rsa) 到了这一步，就可以添加SSH key到你的Github账户了。输入以下指令，拷贝Key（或者进入 [C:\\Users\\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。)： 1clip &lt; ~/.ssh/id_rsa.pub 然后到Github里面，点击右上角个人头像——Settings，在左边菜单栏找到SSH and GPG keys，点击New SSH key，Title 随便命名，Key就粘贴上刚才复制的key，然后点Add SSH key，最后会让你重新输入下gitHub的密码即可 添加完成之后在自己电脑上执行 shell 命令进行测试 1ssh -T git@github.com 可能会看到有警告，没事，输入“yes”就好 出现类似：Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.就表示SSH配置好了 创建repository repository相当于一个仓库，用来放置你的代码文件。首先，登陆进入Github，并进入个人页面——右上角自己的头像 —— Your repositories，然后选择Repositories，点击New，新建一个repository 创建时，只需要填写Repository name即可，这个名字的格式必须为 [你的github名称].github.io，例如我的为biuhe.github.io，点击Create repository 即可创建 安装 Hexo 安装好 Node 之后，输入安装 hexo 命令： 1npm install -g hexo 安装完成后，在自己选定的文件夹下（如 D:\\Hexo），执行以下指令 1hexo init &lt;blog-name&gt; Hexo 会进行初始化，在目标文件夹建立博客所需要的文件，随后我们安装依赖包： 1npm install 就已经安装好了，我们可以通过 hexo help (或者 hexo h )来查看 hexo 支持的命令 以下为常用命令： 12345678hexo help # 帮助hexo new &quot;文章名称&quot; # 新建文章hexo new page &quot;页面名称&quot; # 新建页面hexo g # 完整命令为 hexo generate，用于生成静态文件hexo d # 完整命令为 hexo deploy，用于将本地文件发布到 github 上hexo s # 完整命令为 hexo server，用于启动服务器，主要用来本地预览hexo n # 完整命令为 hexo new，用于新建一篇文章hexo clean # 清楚缓存文件等 你可以使用以下命令启动本地服务器，浏览并预览你的博客： 1hexo s 然后用浏览器访问 http://localhost:4000 就可以在本地预览到博客内容了，hexo3.0使用的默认主题是landscape。 如果页面无法加载可能是端口被占用了，可以先在刚才命令窗口Ctrl+C 关闭服务器，使用 hexo server -p 端口号 ，如hexo server -p 5000 指定运行端口为 5000， 然后通过 http://localhost:5000进行访问 Hexo 博客目录文件结构如下： 12345678910.├── _config.yml # 网站配置信息├── db.json # 数据├── node_modules # node下载的依赖模块（npm install生成的）├── package-lock.json # 锁定 node 安装模块的版本号├── package.json # node 依赖模块信息├── public # 网站文件├── scaffolds # 模板文件├── source # 用户资源（存放markdown文档）└── themes # 主题 部署github 编辑刚才创建的hexo目录下的 _config.yml 文件，在 _config.yml 最下方，添加如下配置(命令中的第一个biuhe为Github的用户名，第二个biuhe为之前New的Repository的名字，记得改成自己的。另外记得一点，hexo的配置文件中任何冒号后面都是带一个空格的，否则会出现异常：ERROR Deployer not found : github） 详细可参考：https://hexo.io/docs/one-command-deployment 1234deploy: type: git repo: github: git@github.com:biuhe/biuhe.github.io.git,master 配置 _config.yml 并保存，执行以下命令部署到Github上。 首选生成静态网页。如果你想要将你的博客部署到网站上，你需要生成静态网页。你可以使用以下命令生成静态网页 1hexo g 在通过 deploy 命令部署到网站 1hexo d 如果执行hexo d命令报下名错：ERROR Deployer not found: git 就需要安装一下 hexo-deployer-git 这个模块： 1npm install hexo-deployer-git --save 安装好了继续执行hexo d部署命令，输入 github 的账号密码，就可以访问了。我的是： biuhe.github.io 发表一篇文章 1.在Git Bash执行命令： 1hexo new &quot;my new post&quot; 2.在创建的hexo目录下source/_posts 文件中打开 my-new-post.md 1234567title: my new post #可以改成中文的，如“新文章”date: 2016-02-21 16:04:09 #发表日期，一般不改动categories: blog #文章文类tags: [文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上&lt;!--more--&gt;，在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，你可以使用 hexo g 生成静态文件。 hexo s 在本地预览效果 hexo d 同步到 github，然后使用http://github用户名.github.io 进行访问 总结 到这里，就算初步搭好了一个属于自己的独立博客，后续就是本地写文章然后部署最后发布就行。当然这只是最基本的流程，hexo提供了许多好看的主题，后续会进行讲解。 参考 本文摘自：嘟嘟独立 官方中文文档：https://hexo.io/zh-cn/docs/","categories":[{"name":"写作","slug":"写作","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/"},{"name":"博客","slug":"写作/博客","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"写作/博客/Hexo","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://blog.heyb.top/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.heyb.top/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.heyb.top/tags/Hexo/"}]},{"title":"「Node」Node.js 版本管理升降级","slug":"技术/node/「Node」Node.js 版本管理升降级","date":"2022-08-19T10:04:23.000Z","updated":"2022-12-25T14:23:03.739Z","comments":true,"path":"2022/08/19/[node]-node.js-version-management-upgrade.html","link":"","permalink":"http://blog.heyb.top/2022/08/19/[node]-node.js-version-management-upgrade.html","excerpt":"","text":"背景 因为 Node 版本不兼容，导致 npm install 或者 npm run dev 等操作报错。因此我们需要降级或者使用指定版本的 Node。 版本管理模块 N N 是一个轻量级的 Node.js 版本管理工具。它可以让开发人员快速地安装、切换和卸载不同版本的 Node.js。 安装 Node 版本管理模块 1npm install -g n 安装完成后，可以使用以下命令来查看可用的 Node.js 版本： 1n ls 要安装指定版本的 Node.js，可以使用以下命令： 1n &lt;version&gt; 其中，&lt;version&gt; 是要安装的 Node.js 版本。例如，要安装最新的 LTS 版本的 Node.js，可以使用以下命令： 1n lts 安装完成后，可以使用以下命令来切换到指定版本的 Node.js： 1n use &lt;version&gt; 其中，&lt;version&gt; 是要切换到的 Node.js 版本。 需要注意的是，N 工具并不会自动切换到新安装的 Node.js 版本，需要手动运行 n use 命令来切换到新版本。 此外，N 还提供了其他实用的命令，例如可以使用 n rm 命令来卸载指定版本的 Node.js，使用 n latest 命令来安装最新版本的 Node.js 等。可以使用 n --help 命令来查看所有可用的命令。 版本管理工具 NVM （推荐） nvm （Node Version Manager）是 Node.js 版本管理器，允许通过命令行快速安装和使用不同版本的节点 github: https://github.com/nvm-sh/nvm 详细内容建议通过官方 readme.md 文档来进行学习 Windows github: https://github.com/coreybutler/nvm-windows 下载地址到发布页进行下载 exe 结尾的安装程序进行安装：https://github.com/coreybutler/nvm-windows/releases macOS 推荐使用 brew 进行下载管理 安装 1brew install nvm 在安装完成后，可以使用以下命令来安装指定版本的 Node.js： 1nvm install &lt;version&gt; 其中，&lt;version&gt; 是要安装的 Node.js 版本。 如果安装成功仍然无法执行，则配置环境变量 1echo &quot;source $(brew --prefix nvm)/nvm.sh&quot; &gt;&gt; .bash_profile; 使环境变量生效 1~/.bash_profile 要安装最新的 LTS 版本的 Node.js，可以使用以下命令： 1nvm install --lts 安装完成后，可以使用以下命令来切换到指定版本的 Node.js： 1nvm use &lt;version&gt; 其中，&lt;version&gt; 是要切换到的 Node.js 版本。如 nvm use 12.13.0 即可安装指定版本 需要注意的是，在使用 nvm 安装的某个版本的 Node.js 时，需要在终端中运行 nvm 命令来切换到该版本。如果不运行 nvm 命令，则终端默认使用系统中默认安装的 Node.js 版本。 NVM 其他命令 123456789101112131415161718192021nvm list 是查找本电脑上所有的node版本 - nvm list 查看已经安装的版本 - nvm list installed 查看已经安装的版本 - nvm list available 查看网络可以安装的版本nvm install &lt;version&gt; 安装指定版本nodenvm use &lt;version&gt; 切换使用指定的版本nodenvm ls 列出所有版本nvm current显示当前版本nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包nvm on 打开nodejs控制nvm off 关闭nodejs控制nvm proxy 查看设置与代理nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.nvm uninstall &lt;version&gt; 卸载制定的版本nvm use [version] [arch] 切换制定的node版本和位数nvm root [path] 设置和查看root路径nvm version 查看当前的版本","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"技术/前端/Node","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Node/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.heyb.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"Node","permalink":"http://blog.heyb.top/tags/Node/"},{"name":"NVM","slug":"NVM","permalink":"http://blog.heyb.top/tags/NVM/"}]},{"title":"「Go」解决go编译出现timeout的问题","slug":"技术/go/「Go」解决go编译出现timeout的问题","date":"2022-08-15T15:12:31.000Z","updated":"2022-12-25T14:27:44.003Z","comments":true,"path":"2022/08/15/go-solves-the-timeout-problem-in-go-compilation.html","link":"","permalink":"http://blog.heyb.top/2022/08/15/go-solves-the-timeout-problem-in-go-compilation.html","excerpt":"","text":"背景 Go 编译时无法连接其网站，有如以下报错： Windows的报错 12go: downloading github.com/xiecat/xhttp v0.0.0-20220117022559-2545617efd91main.go:8:2: github.com/kataras/golog@v0.1.7: Get &quot;https://proxy.golang.org/github.com/kataras/golog/@v/v0.1.7.zip&quot;: dial tcp 172.217.163.49:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond Linux的报错 1main.go:8:2: github.com/kataras/golog@v0.1.7: Get &quot;https://proxy.golang.org/github.com/kataras/golog/@v/v0.1.7.zip&quot;: dial tcp 172.217.160.113:443: i/o timeout 解决办法 Windows 10 设置国内代理地址 12set GOPROXY=https://goproxy.cnset GO111MODULE=on Linux &amp; ubuntu 设置代理 1go env -w GOPROXY=https://goproxy.cn 先执行上面的命令，然后再重新执行编译命令就行了。 参考 https://www.sssins.com/2022/08/14/37991.html","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"}]},{"title":"「Go」Golang","slug":"技术/go/「Go」Golang","date":"2022-08-14T09:11:21.000Z","updated":"2022-12-25T14:35:39.965Z","comments":true,"path":"2022/08/14/「go」golang.html","link":"","permalink":"http://blog.heyb.top/2022/08/14/%E3%80%8Cgo%E3%80%8Dgolang.html","excerpt":"","text":"简介 Go 是一种开源的编程语言，它由 Google 公司的工程师们在 2007 年提出，并在 2009 年开源。Go 是一种静态类型、编译型、并发型的语言。 Go 的主要目标是提供一种简单、可扩展、快速、可靠的编程语言，它既适用于大型项目，也适用于小型项目。Go 语言的设计目标是让程序员快速开发出高质量的程序，同时也能使这些程序运行得更快。 Go 语言提供了丰富的内置类型、结构体、接口、函数等 如果你想学习 Go 语言，下面是一些建议： 首先，你应该去 Go 语言官网（https://golang.org/）下载并安装 Go 语言的开发工具。Go 语言官网还提供了完整的 Go 语言文档，可以作为参考手册。 然后，你可以通过学习 Go 语言的官方教程（https://tour.golang.org/）来了解 Go 语言的基本语法和用法。这个教程提供了许多在线实例，可以让你在线实时编写和执行 Go 代码。 在学习完基本语法后，你可以阅读 Go 语言官方文档（https://golang.org/doc/）中的“Effective Go”一章，了解 Go 语言的设计哲学和编码规范。 随后，你可以阅读 Go 语言官方文档中的其他章节，了解 Go 语言的标准库、工具和其他特性。 最后，你可以在网上搜索 Go 语言的相关书籍和教程，找到适合你的学习方式 特点 静态类型：Go 语言是一种静态类型语言，它的类型系统严格，能够检查出许多类型错误。 并发型：Go 语言提供了丰富的并发模型，原生支持并发编程，提供了 goroutine 和 channel，可以方便地编写多核、高并发的程序。 简单易学：Go 语言的语法简单易懂，可以轻松上手，适合初学者。 编译速度快：Go 语言的编译速度快，生成的可执行文件体积小，可以提高开发效率。 内存管理好：Go 语言内置了垃圾回收机制，可以自动管理内存，避免内存泄漏问题。 功能强大的标准库：Go 语言拥有丰富的标准库，可以方便地实现常见的功能。 支持多种操作系统：Go 语言可以运行在多种操作系统上，包括 Windows、Mac OS、Linux 等。 缺点 异常处理不够完善：Go 语言的异常处理机制不够完善，不能像其他语言那样抛出和捕获异常。 运行速度不够快：Go 语言的运行速度不如 C++ 和 Java 等其他语言。 编译速度慢：Go 的编译速度相对于其他语言比较慢，这对于快速迭代和开发来说不太方便。 文档与社区支持不足：Go 的文档和社区支持相对于其他流行的语言来说还不够完善，第三方函数库暂时没有主流编程语言多 单进程限制：Go 语言默认的是单进程，如果需要多进程的话，需要手动编写代码来实现。 数据类型与类型转换限制：Go 语言在数据类型和类型转换方面比较严格，不太适合大型项目开发。 静态类型语言限制：Go 语言是一门静态类型语言，这对于一些动态语言的程序员来说不太习惯。 对于并发编程的限制：Go 语言的并发模型相对于其他语言来说比较特殊，不太适合熟悉其他语言的程序员。 安装与下载 其他系统版本参考官方链接进行下载安装：https://go.dev/doc/install 无法访问的用户可以通过中文网的下载地址进行安装：https://studygolang.com/dl Linux 下需要设置 4 个环境变量：GoRoot、GoPath、GoBin及Path 到profile文件中（~/.bash_profile（单一用户）或/etc/profile（所有用户）） GOROOT：该环境变量的值应该为Go语言的当前安装目录,例如: export GOROOT =/usr/local/go GOPATH：该环境变量的值应该为Go语言的工作区的集合，例如： export GOPATH=~/golib:~/goproject GOBIN：它的值应该是你想存放Go程序的可执行文件的目录，例如： export GOBIN=~/gobin PATH：为了方便使用Go语言命令和Go程序的可执行文件，需要追加其值，如： export PATH=$PATH:$GOROOT/bin:$GOBIN 然后通过source 命令使文件生效，如source ~/.bash_profile macOS 下可使用brew 安装 超找 go 1brew search go 下载安装指定版本 1brew install go@1.19 查看安装版本验证安装结果 1go version 设置模块代理 参考 https://goproxy.cn/ macOS 或 Linux 12export GO111MODULE=onexport GOPROXY=https://goproxy.cn Windows 打开你的 PowerShell 并执行 12$env:GO111MODULE = &quot;on&quot;$env:GOPROXY = &quot;https://goproxy.cn&quot; 编写 新建一个 .go 结尾的文件 写入一下内容 helloworld.go 1234567891011121314// 声明文件所在包，每个 go 文件必须有归属的包package main// 引入程序中需要用到的包，以使用包中的函数/方法，例如 Println()import ( &quot;fmt&quot;)// 主函数 程序入口func main() &#123; // 含有格式化输出、接收输入的函数 // 在控制台中输出一句话，双引号中的内容（字符串）会原样输出 fmt.Println(&quot;Hello World&quot;) &#125; 编译 &amp; 执行 在go文件目录下打开命令行执行以下命令即可编译成可执行的二进制文件 1go build 此外，在不同平台环境中编译其他平台命令如下： macOS Mac下编译Linux, Windows平台的64位可执行程序 Linux 1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build helloworld.go Windows 1CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build helloworld.go Linux Linux下编译Mac, Windows平台的64位可执行程序 macOS 1CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build helloworld.go Windows 1CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build helloworld.go Windows Windows下编译Mac, Linux平台的64位可执行程序 macOS 1234SET CGO_ENABLED=0SET GOOS=darwin3SET GOARCH=amd64go build helloworld.go Linux 1234SET CGO_ENABLED=0SET GOOS=linuxSET GOARCH=amd64go build helloworld.go 语义如下： GOOS：目标可执行程序运行操作系统，支持 darwin，freebsd，linux，windows GOARCH：目标可执行程序操作系统构架，包括 386，amd64，arm 执行 也可以通过 go run helloworld.go 来直接编译运行 基本语法 变量定义：在 Go 语言中，变量需要在使用前进行定义。变量定义的语法格式为：var variable_name type。例如： 123Copy codevar name stringvar age int 常量定义：Go 语言支持常量定义，常量的值在程序运行期间不能被改变。常量定义的语法格式为：const constant_name = value。例如： 12Copy codeconst Pi = 3.14 运算符：Go 语言支持常见的算数、关系和逻辑运算符。例如，加法运算符为 +，减法运算符为 -，小于运算符为 &lt; 等。 控制语句：Go 语言支持常见的控制语句，包括 if、else、for、switch 等。例如，if 语句的语法格式为： 1234Copy codeif condition &#123; // code to be executed if condition is true&#125; 函数：Go 语言支持函数定义和调用。函数定义的语法格式为： 12345Copy codefunc function_name(parameter1 type1, parameter2 type2) return_type &#123; // code to be executed return value&#125; 函数调用的语法格式为： 12Copy codefunction_name(parameter1, parameter2) 下面是一个简单的Go语言程序，它演示了一些基础语法的用法： 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; // 定义一个变量 var a int = 10 var b int = 20 // 使用if语句 if a &lt; b &#123; // 使用fmt包的Println函数 fmt.Println(&quot;a is less than b&quot;) &#125; // 使用for循环 for i := 0; i &lt; 5; i++ &#123; fmt.Println(i) &#125; // 定义一个函数 func add(x int, y int) int &#123; return x + y &#125; // 调用函数 result := add(a, b) fmt.Println(result)&#125; 上面的程序定义了两个变量a和b，并使用if语句来比较它们的值。它还使用了for循环来打印一些数字，定义了一个函数来计算两个数的和，并调用了这个函数。 其他更多内容请参考网站进行扩展学习 参考 官网 Go语言中文网 Go语言圣经 Go语言高级编程 菜鸟教程网（推荐）","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"}]},{"title":"「Node」Node.js 安装配置","slug":"技术/node/「Node」Node.js 安装配置","date":"2022-08-11T16:00:00.000Z","updated":"2022-12-25T14:23:03.746Z","comments":true,"path":"2022/08/12/node-node.js-installation-configuration.html","link":"","permalink":"http://blog.heyb.top/2022/08/12/node-node.js-installation-configuration.html","excerpt":"","text":"本文摘自：https://www.runoob.com/nodejs/nodejs-install-setup.html 本章节我们将向大家介绍在 Windows 和 Linux 上安装 Node.js 的方法。 本安装教程以 Node.js v4.4.3 LTS(长期支持版本)版本为例。 Node.js 安装包及源码下载地址为：https://nodejs.org/en/download/。 你可以根据不同平台系统选择你需要的 Node.js 安装包。 Node.js 历史版本下载地址：https://nodejs.org/dist/ **注意：**Linux 上安装 Node.js 需要安装 Python 2.6 或 2.7 ，不建议安装 Python 3.0 以上版本。 Windows 上安装 Node.js 你可以采用以下两种方式来安装。 1、Windows 安装包(.msi) 32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi 64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi 本文实例以 v0.10.26 版本为例，其他版本类似， 安装步骤： 步骤 1 : 双击下载后的安装包 v0.10.26，如下所示： 步骤 2 : 点击以上的Run(运行)，将出现如下界面： 步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮 : 步骤 4 : Node.js默认安装目录为 &quot;C:\\Program Files\\nodejs&quot; , 你可以修改目录，并点击 next（下一步）： 步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步） 步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）： 安装过程： 点击 Finish（完成）按钮退出安装向导。 检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入&quot;cmd&quot; =&gt; 输入命令&quot;path&quot;，输出如下结果： 12345PATH=C:\\oraclexe\\app\\oracle\\product\\10.2.0\\server\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;c:\\python32\\python;C:\\MinGW\\bin;C:\\Program Files\\GTK2-Runtime\\lib;C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin;C:\\Program Files\\nodejs\\;C:\\Users\\rg\\AppData\\Roaming\\npm 我们可以看到环境变量中已经包含了C:\\Program Files\\nodejs\\ 检查Node.js版本，执行node --version 得到版本号如： v0.10.26 如果你获得以上输出结果，说明你已经成功安装了Node.js 2、Windows 二进制文件 (.exe)安装 32 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/node.exe 64 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/x64/node.exe 安装步骤 步骤 1 : 双击下载的安装包 Node.exe ，将出现如下界面 : 点击 Run（运行）按钮将出现命令行窗口： 版本测试 进入 node.exe 所在的目录，如下所示： 执行node --version 得到版本号如： v0.10.26 如果你获得以上输出结果，说明你已经成功安装了Node.js Linux 上安装 Node.js 直接使用已编译好的包 Node 官网已经把 linux 下载版本更改为已编译好的版本了，我们可以直接下载解压后使用： 12345# wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz // 下载# tar xf node-v10.9.0-linux-x64.tar.xz // 解压# cd node-v10.9.0-linux-x64/ // 进入解压目录# ./bin/node -v // 执行node命令 查看版本v10.9.0 解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接： 12ln -s /usr/software/nodejs/bin/npm /usr/local/bin/ ln -s /usr/software/nodejs/bin/node /usr/local/bin/ Ubuntu 源码安装 Node.js 以下部分我们将介绍在 Ubuntu Linux 下使用源码安装 Node.js 。 其他的 Linux 系统，如 Centos 等类似如下安装步骤。 在 Github 上获取 Node.js 源码： 12$ sudo git clone https://github.com/nodejs/node.gitCloning into &#x27;node&#x27;... 修改目录权限： 1$ sudo chmod -R 755 node 使用 ./configure 创建编译文件，并按照： 1234$ cd node$ sudo ./configure$ sudo make$ sudo make install 查看 node 版本： 12$ node --versionv0.10.25 Ubuntu apt-get命令安装 使用命令行工具打开终端，输入以下命令： 1curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash - 输入以下命令安装 Node.js： 12sudo apt-get install nodejssudo apt-get install npm 输入以下命令安装 build-essential 包： 1sudo apt-get install -y build-essential 输入以下命令检查 Node.js 是否安装成功： node -v 如果输出的版本号表明 Node.js 已经安装成功，则表示安装成功。 CentOS 下源码安装 Node.js 下载源码，你需要在 https://nodejs.org/en/download/ 下载最新的Nodejs版本，本文以v0.10.24为例: 12cd /usr/local/src/wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz 解压源码 1tar zxvf node-v0.10.24.tar.gz 编译安装 1234cd node-v0.10.24./configure --prefix=/usr/local/node/0.10.24makemake install 配置NODE_HOME，进入profile编辑环境变量 1vim /etc/profile 设置 nodejs 环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: 123#set for nodejsexport NODE_HOME=/usr/local/node/0.10.24export PATH=$NODE_HOME/bin:$PATH :wq保存并退出，编译/etc/profile 使配置生效 1source /etc/profile 验证是否安装配置成功 1node -v 输出 v0.10.24 表示配置成功 npm模块安装路径 1/usr/local/node/0.10.24/lib/node_modules/ **注：**Nodejs 官网提供了编译好的 Linux 二进制包，你也可以下载下来直接应用。 Mac OS 上安装 你可以通过以下两种方式在 Mac OS 上来安装 node： pkg 安装 在官方下载网站下载 pkg 安装包，直接点击安装即可。 卸载 1sudo rm -rf /usr/local/&#123;bin/&#123;node,npm&#125;,lib/node_modules/npm,lib/node,share/man/*/node.*&#125; brew 安装 1brew install node 验证是否安装配置成功 1node -v 卸载 1brew uninstall node --ignore-dependencies 如果提示异常 Error: No such keg: /usr/local/Cellar/node 则执行 1brew uninstall node --force 配置镜像 1234# 查看当前镜像npm config get registry# 设置镜像为 淘宝镜像npm config set registry http://registry.npm.taobao.org/","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"技术/前端/Node","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Node/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.heyb.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"Node","permalink":"http://blog.heyb.top/tags/Node/"}]},{"title":"hello hexo","slug":"个人/hello hexo","date":"2022-08-10T14:32:54.000Z","updated":"2022-08-12T07:05:12.018Z","comments":true,"path":"2022/08/10/hello-hexo.html","link":"","permalink":"http://blog.heyb.top/2022/08/10/hello-hexo.html","excerpt":"","text":"我刚洗好澡坐下来写下这一开篇文章，似乎已经很久很久没有这样安静下来的写一些东西了。 自工作以来，我总是不断的在吸收摄入知识，已经很久没有像以前初高中时候玩qq空间那样，写一些感想，输出一些内容了。这个时代不断的飞速发展，节奏越来越快，到处都是微博、短视频，甚至教学内容也都逐渐碎片化。我想是时候该慢一些，拾回当初的自己，也检视这十年的自己。 生活 毕业后什么都想尝试，买了很多杂七杂八的电子产品。到最近已经「没有那种世俗欲望了.jpg」，趋向于寻求稳定、适己的事物以及状态。 一直以来都想着自己从零开始开发一个博客系统。但是现实很骨感，一是除去了工作和睡觉并没有留给我太多的时间。二是学艺不精，想要实现前端的界面好的效果实在是太麻烦，总是想着要做就做到最好。但往往一个好的东西是需要时间去雕琢的，开发项目也是如此，现在知名的应用大多最初版本都不是尽善尽美的。现在安定下来，在自己的笔记本电脑上码字，让我有一种归属感，也重新拾起了搭建自己的小天地的想法。这博客可能更多的记录生活中的一些琐事，对生活的思考，和朋友的一些故事等等，也会整理和收纳在工作中遇到的一些技术上的问题以及一些有趣的文章。 可能文章内容没有别人的那么有趣，文笔流畅。但总算是个好的开始，写多了，慢慢拓展，总会比什么都不做得到的进步更多，是吧？ 感情 最近我常常有一种觉得自己处在一个舒适满意的环境中，我常和小环说我好舒服呀。 我觉得我们似乎开始步入了「长期稳定的亲密关系」之中。在一起近两年的时间了，除了逢年过节回老家，几乎每天都是面对面的在一起，我仍然想着每天下班第一时间见到她，每天仍然还有很多事情叭叭叭的想和她分享。大部分的时候我们的想法出奇的一致，喜好也大抵相同，所以不用特别花心思去磨合、迁就对方。 我自觉成长了很多，抱着学习、经营的心态，去维护我们这段感情。期望我们能步入下一个阶段 :) 学习 有些东西真的不去面对的话就会变成心结，甚至多年以后做梦还是会觉得遗憾当初没有好好把握。所以我现在仍要花费比之前在学校更多的努力才觉得能弥补自己一些。去年底开始报一些班课学习，等课程完结之后我再说出来吧。 不过我感觉毕业之后学习东西才开始快起来，对于一些新鲜的东西接纳远比之前在校的时候更快一些，我想也可能跟自己工作了这几年的经验有关系，能对于事物理解得更深刻。 今年更多的是学习学科方向，把以前落下的数学、英语知识补一补。今年比较混乱，忙着找工作（算是借口吧），技术上反而没有太多的长进。计划今年考取PMP资格认证。最近开始写博客后，打算把之前的知识点给整理一下，再查漏补缺。 感觉自己学的东西越多，就越觉得自己渺小。所以想把自己知道的东西整理下来，让别人少走一些弯路。 工作 今年是奔波的一年。去年离开了邮政从广州回到了南宁，期望在南宁能够长远发展。去了小环所在的教育集团当技术主管，本想着能施展自己所长，却因为双减政策导致集团转型，整个部门都被裁剪。后来经过总监介绍去了他朋友的一家电力外包公司，但是公司各方面都存在问题，恶性循环，到后面已经拖欠三四个月工资，已经不是凭我一己之力能够做出改变的，加之南宁的互联网大环境还是有待发展，所以考虑了还是先继续回到广州工作。 回广州面试了近一个半月，十几家公司，几经波折，最后找到一个在外企做服务支撑的公司。也感谢盛斌、陈鑫他们几个好友对我的鼓励，毕竟多年前我都未曾敢想象自己现在能拿到这个工资，从国企几年再出来已经不太清楚自己的市场定位了，是他们一直都跟我说可以再开高一些工资，让我觉得我的能力是值得的。 外国团队的领导对我们也很照顾，团队小伙伴的氛围也很好。各方面的工作安排都很合理，不像国内团队那么内卷，能留给自己的时间很充裕，这一点是让我最喜欢的地方。这能让我在业余时间做很多自己想要做的事情。甚至可以常态化 WFH（work for home居家办公）。 当然凡事是有两面性的，不好的地方就是和外国团队有时差，花费在沟通的时间比较多。整体而言做事效率比以前低了许多。开会聊天和文档也都是用英语，对自己英语考验还是挺大的。还有就是我们组缺少Tech Lead，很多问题只能去其他各组大佬来支持，很多流程不太熟悉，明明很简单的东西还要去咨询别人（很多时候只是需要别人确定是或者否），所以自己会有一种挫败感。 现在也知道，工作嘛，总是有开心和不如意的地方，调整好心态再继续努力了。自己觉得开心的一点是已经开始能够听得懂一些带口音的英语了，也开始逐渐尝试摆脱翻译工具，觉得学习英语也是一件不错的事情。 结束语 今年是一个平凡又不普通的一年，经历过这些才越觉得平凡的可贵。今年只剩一个季度，希望以后的日子自己和身边的人都能够健健康康快快乐乐的就足够了，不求风骚惊天下，但求猥琐动世人。","categories":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/tags/%E4%B8%AA%E4%BA%BA/"}]}],"categories":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/categories/%E4%B8%AA%E4%BA%BA/"},{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"技术/容器","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"技术/容器/Docker","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"},{"name":"其他","slug":"技术/其他","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/"},{"name":"AI","slug":"技术/其他/AI","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/"},{"name":"ChatGPT","slug":"技术/其他/AI/ChatGPT","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/ChatGPT/"},{"name":"RDS","slug":"技术/RDS","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/"},{"name":"华为云","slug":"技术/RDS/华为云","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"},{"name":"Windows","slug":"技术/Windows","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Windows/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"},{"name":"Java","slug":"技术/Java","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Java/"},{"name":"写作","slug":"写作","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/"},{"name":"博客","slug":"写作/博客","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"写作/博客/Hexo","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/Hexo/"},{"name":"前端","slug":"技术/前端","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"技术/前端/Node","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Node/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"容器","permalink":"http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.heyb.top/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://blog.heyb.top/tags/Dockerfile/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://blog.heyb.top/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://blog.heyb.top/tags/OpenAI/"},{"name":"华为云","slug":"华为云","permalink":"http://blog.heyb.top/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"RDS","slug":"RDS","permalink":"http://blog.heyb.top/tags/RDS/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.heyb.top/tags/Windows/"},{"name":"gin","slug":"gin","permalink":"http://blog.heyb.top/tags/gin/"},{"name":"gorm","slug":"gorm","permalink":"http://blog.heyb.top/tags/gorm/"},{"name":"viper","slug":"viper","permalink":"http://blog.heyb.top/tags/viper/"},{"name":"go mod","slug":"go-mod","permalink":"http://blog.heyb.top/tags/go-mod/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"http://blog.heyb.top/tags/Java/"},{"name":"PPT","slug":"PPT","permalink":"http://blog.heyb.top/tags/PPT/"},{"name":"博客","slug":"博客","permalink":"http://blog.heyb.top/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.heyb.top/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.heyb.top/tags/Hexo/"},{"name":"前端","slug":"前端","permalink":"http://blog.heyb.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"Node","permalink":"http://blog.heyb.top/tags/Node/"},{"name":"NVM","slug":"NVM","permalink":"http://blog.heyb.top/tags/NVM/"}]}