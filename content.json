{"meta":{"title":"Biu's Blog","subtitle":"","description":"","author":"He Yongbiao","url":"http://blog.heyb.top","root":"/"},"pages":[{"title":"About","date":"2022-08-07T14:46:31.562Z","updated":"2022-08-07T14:46:31.559Z","comments":false,"path":"about/index.html","permalink":"http://blog.heyb.top/about/index.html","excerpt":"","text":"联系我 邮箱：wsxc_0617@sina.cn 微信：biubiu20201001 GitHub: https://github.com/biuhe"},{"title":"categories","date":"2022-08-15T02:27:07.868Z","updated":"2022-08-07T10:43:28.631Z","comments":false,"path":"categories/index.html","permalink":"http://blog.heyb.top/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-08-15T02:27:07.846Z","updated":"2022-08-07T10:43:28.768Z","comments":false,"path":"repository/index.html","permalink":"http://blog.heyb.top/repository/index.html","excerpt":"","text":""},{"title":"Books","date":"2022-08-15T02:27:07.862Z","updated":"2022-08-08T09:52:08.744Z","comments":false,"path":"books/index.html","permalink":"http://blog.heyb.top/books/index.html","excerpt":"","text":""},{"title":"Links","date":"2022-08-15T02:27:07.867Z","updated":"2022-08-08T09:53:19.202Z","comments":false,"path":"links/index.html","permalink":"http://blog.heyb.top/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-08-15T02:27:07.865Z","updated":"2022-08-07T10:43:28.837Z","comments":false,"path":"tags/index.html","permalink":"http://blog.heyb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"「Stable-Diffusion」Stable-Diffusion-WebUI-For-Linux-安装教程","slug":"技术/stable_diffusion/「Stable-Diffusion」Stable-Diffusion-WebUI-For-Linux-安装教程","date":"2023-07-08T14:40:34.000Z","updated":"2023-07-16T15:08:43.940Z","comments":true,"path":"2023/07/08/stable-diffusion-webui-for-linux-installation-tutorial.html","link":"","permalink":"http://blog.heyb.top/2023/07/08/stable-diffusion-webui-for-linux-installation-tutorial.html","excerpt":"","text":"背景 之前我们讲解了如何在Mac 上搭建 Stable-Diffusion-WebUI，但是因为仅能使用CPU的原因，生成图片特别慢。 本文讲解如何在一台有GPU的Linux服务器上部署。 配置服务器 首先我们在云服务器商申请购买一台服务器，GPU建议使用 12GB 以上显存的。 系统镜像我这里选择的是公共镜像CentOS-64位-CentOS 8.4 64位。一定要选择后台自动安装GPU驱动，避免自己手动安装GPU驱动。然后等待一会等系统安装好驱动后再进行安装stable-diffusion-webui 带宽计费方式可以选择按使用流量计费，带宽值建议拉到 100Mbps，因为安装时需要下载的依赖和模型非常多，非常大，后续我们可以再动态调配带宽。 查看显卡驱动 1nvidia-smi 如果显示了一个表格，里面有NVIDIA、Driver Version、CUDA version等信息，则代表GPU驱动已经安装完成。 nvcc -V 也可以查看版本信息，在腾讯云中如果返回 nvcc: command not found 则需要配置一下环境变量。 进入环境配置 12# 进入环境配置vim ~/.bash_profile 添加 cuda 环境设置 1234# 在PATH 中添加 /usr/local/cuda/bin，如PATH=$PATH:/usr/local/cuda/binexport PATH 然后按 Esc 退出，输入 :wq 保存 bash_profile， 然后在输入 1source ~/.bash_profile 安装 Anaconda 官方仓库下载 1wget https://repo.anaconda.com/archive/Anaconda3-2023.03-Linux-x86_64.sh 通过清华镜像仓库下载 清华大学开源软件镜像站 Anaconda Archive 可以查看现在最新版本 1wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.03-Linux-x86_64.sh 如果遇到不能下载的，则在 wget 后添加参数 wget -U NoSuchBrowser，完整如下： 1wget -U NoSuchBrowser https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.03-Linux-x86_64.sh 下载后安装 1sh Anaconda3-2023.03-Linux-x86_64.sh 提示enter按回车，提示yes or no的地方全部输入yes即可，安装完成后执行 “bash”命令，重新载入bash终端，确保conda命令可用。安装后还可以配置 Conda 镜像（参考文章：anaconda 镜像站使用帮助） 验证安装，可以看到输出信息 1conda info 安装 PyTorch pytorch需要安装到anaconda的虚拟环境中，所以使用conda时需要先有一个虚拟环境并进入 12345#若还没有虚拟环境需要创建一个，&lt;env_name&gt;是环境名称，python选择指定的版本，sd需要的python&gt;3.10 #conda create -n &lt;env_name&gt; python=x.xx.xconda create -n sd python=3.10.11#启动虚拟环境，activate就是启动，sd是环境名称conda activate sd 去pytorch官网配置自己服务器所需要的pytorch：Start Locally | PyTorch Pytorch build选择stable稳定版，操作系统是linux，由于上面安装了anaconda所以package选择conda，语言python，服务器上 CUDA是12.0所以选择了CUDA11.8 选择完成之后下面会有提示的执行代码（Run this Command:），执行pytorch的安装： 1conda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia 如果出现提示需要升级conda版本的就输入，没有的话就跳过这步。 1conda update -n base -c defaults conda 验证安装结果 123456789101112131415161718192021#首先要启动我们的sd虚拟环境，因为我们所有与stable diffusion有关的配置环境都是建立在这个虚拟环境之下的python，pytorch等都是如此#进入虚拟环境conda activate sd#进入python环境python#导入torchimport torch#查看torch的版本torch.__version__ #各有两条下划线#查看cuda版本torch.version.cuda#查看GPU是否运行torch.cuda.is_available()#退出exit() 安装 Stable Diffusion-Web-UI 依赖安装 12sudo yum install mesa-libGL -ysudo yum install git -y 下载 web-ui 1bash &lt;(wget -qO- https://raw.githubusercontent.com/AUTOMATIC1111/stable-diffusion-webui/master/webui.sh) 或者通过 git 命令下载（此处使用了镜像源） 1git clone https://github.moeyy.xyz/https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 如果提示错误 OpenSSL SSL_read: Connection was reset, errno 10054 则需要关闭 git 的 https 证书验证，然后重新执行下载 1git config --global http.sslVerify false 预先配置 下载完成之后我们进行一些预先的配置，防止后面配置失败。 配置 pip 设置 pip 源，这里设置的是腾讯云内源 12pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simplepip config set global.trusted-host mirrors.cloud.tencent.com 更新 pip 版本 1pip install --upgrade pip 配置 SD 链接换源。打开 stable-diffusion-webui/modules/launch.until.py 文件 1torch_command = os.environ.get(&#x27;TORCH_COMMAND&#x27;, &quot;pip install torch==2.0.1 torchvision==0.15.2&quot;) 每个https://github.com/ （就在上一步的下面几行，每一个网址都要改）链接前面添加https://ghproxy.com/，替换为以下内容 12345678gfpgan_package = os.environ.get(&#x27;GFPGAN_PACKAGE&#x27;, &quot;https://ghproxy.com/https://github.com/TencentARC/GFPGAN/archive/8d2447a2d918f8eba5a4a01463fd48e45126a379.zip&quot;)clip_package = os.environ.get(&#x27;CLIP_PACKAGE&#x27;, &quot;https://ghproxy.com/https://github.com/openai/CLIP/archive/d50d76daa670286dd6cacf3bcd80b5e4823fc8e1.zip&quot;)openclip_package = os.environ.get(&#x27;OPENCLIP_PACKAGE&#x27;, &quot;https://ghproxy.com/https://github.com/mlfoundations/open_clip/archive/bb6e834e9c70d9c27d0dc3ecedeebeaeb1ffad6b.zip&quot;)stable_diffusion_repo = os.environ.get(&#x27;STABLE_DIFFUSION_REPO&#x27;, &quot;https://ghproxy.com/https://github.com/Stability-AI/stablediffusion.git&quot;)taming_transformers_repo = os.environ.get(&#x27;TAMING_TRANSFORMERS_REPO&#x27;, &quot;https://ghproxy.com/https://github.com/CompVis/taming-transformers.git&quot;)k_diffusion_repo = os.environ.get(&#x27;K_DIFFUSION_REPO&#x27;, &#x27;https://ghproxy.com/https://github.com/crowsonkb/k-diffusion.git&#x27;)codeformer_repo = os.environ.get(&#x27;CODEFORMER_REPO&#x27;, &#x27;https://ghproxy.com/https://github.com/sczhou/CodeFormer.git&#x27;)blip_repo = os.environ.get(&#x27;BLIP_REPO&#x27;, &#x27;https://ghproxy.com/https://github.com/salesforce/BLIP.git&#x27;) 配置用户 通常 SD 不允许使用 root 用户进行，我们需要额外创建一个用户 1234adduser sd （创建账户sd）passwd sd （创建密码）usermod -aG wheel sd （增加sudo权限）su - sd (切换为sd用户) 或者修改 stable-diffusion-webui 目录下的 webui.sh 文件，禁掉用户判断 12345678910111213141516171819# 修改 can_run_as_root 为 1# this script cannot be run as root by defaultcan_run_as_root=1# 或者找到下面的代码进行注释# Do not run as root# if [[ $(id -u) -eq 0 &amp;&amp; can_run_as_root -eq 0 ]]# then# printf &quot;\\n%s\\n&quot; &quot;$&#123;delimiter&#125;&quot;# printf &quot;\\e[1m\\e[31mERROR: This script must not be launched as root, aborting...\\e[0m&quot;# printf &quot;\\n%s\\n&quot; &quot;$&#123;delimiter&#125;&quot;# exit 1# else printf &quot;\\n%s\\n&quot; &quot;$&#123;delimiter&#125;&quot; printf &quot;Running on \\e[1m\\e[32m%s\\e[0m user&quot; &quot;$(whoami)&quot; printf &quot;\\n%s\\n&quot; &quot;$&#123;delimiter&#125;&quot;# fi 启动 cd 到 stable-diffusion-webui目录下执行 1./webui.sh --share -- share 会启动启动公网环境，给出一个随机的地址，每次启动都会随机生成。因此建议使用 --listen 参数，再做映射转发，这点后续再讲 第一次执行会自动下载基础模型，如果下载速度还行就耐心等待，如果网络慢的同学，可以先“ctrl+C”断开下载步骤，然后到C站随便下个大模型上传上去。 命令行中也会有提示安装的目录，通常是放在 stable-diffusion-webui/models/Stable-diffusion 中 启动成功后，出现http:/0.0.0.0:7860就说明已启动成功，如果是用share命令还会映射一个随机的外网访问地址。 例如：https://9ac95a343d5d32d1c6.gradio.live/ ，访问即可 参考 基于腾讯云CVM搭建stable-diffusion-webui环境-腾讯云开发者社区-腾讯云 (tencent.com) Stable Diffusion云服务器部署完整版教程 - 哔哩哔哩 (bilibili.com)","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"AI","slug":"技术/AI","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/AI/"},{"name":"Stable Diffusion","slug":"技术/AI/Stable-Diffusion","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/AI/Stable-Diffusion/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"AI","slug":"AI","permalink":"http://blog.heyb.top/tags/AI/"},{"name":"Stable Diffusion","slug":"Stable-Diffusion","permalink":"http://blog.heyb.top/tags/Stable-Diffusion/"}]},{"title":"「Stable Diffusion」Stable Diffusion Web UI 安装教程","slug":"技术/stable_diffusion/「Stable-Diffusion」Stable-Diffusion-WebUI-For-Mac-安装教程","date":"2023-06-27T14:40:34.000Z","updated":"2023-07-16T15:08:22.586Z","comments":true,"path":"2023/06/27/stable-diffusion-web-ui-installation-tutorial.html","link":"","permalink":"http://blog.heyb.top/2023/06/27/stable-diffusion-web-ui-installation-tutorial.html","excerpt":"","text":"介绍 什么是 Stable Diffusion CompVis/stable-diffusion 是一个开源项目，它实现了一种基于稳定扩散（Stable Diffusion）的生成对抗网络（GAN）训练方法。这个项目旨在提高 GAN 训练的稳定性和生成图像的质量。 该项目主要包括以下特点： 稳定扩散技术：通过引入噪声和扩散过程来平滑生成器和判别器之间的优化过程，从而提高训练稳定性。 高质量图像生成：利用稳定扩散技术，生成器能够产生更高质量、更真实的图像。 易于使用：项目提供了预训练模型和示例代码，方便用户快速上手和测试。 CompVis/stable-diffusion 可以应用于各种图像生成任务，如将文本描述转换为图像（Text2Img）、风格迁移、超分辨率等。这个项目对于研究人员和开发者来说是一个有价值的资源，可以帮助他们更好地理解和实践基于稳定扩散的 GAN 训练方法。 通俗一些说法是： Stable Diffusion是2022年发布的深度学习文本到图像生成模型，它主要用于根据文本的描述产生详细图像，尽管它也可以应用于其他任务，如内补绘制、外补绘制，以及在提示词（英语）指导下产生图生图的翻译。 该模型由互联网上数百万图像和文本描述对训练而来，通过理解文本描述与图像信息的内在关联，不断利用扩散过程进而得到满意的生成图片 根据维基百科的描述可以得知，Stable Diffusion主要用于 文本生成图像 的深度学习模型，也就是常说的txt2img的应用场景中：通过给定 文本提示词（text prompt），该模型会输出一张匹配提示词的图片。 例如输入文本提示词：“A cute cat”，Stable Diffusion会输出一张带有可爱猫咪的图片。 Github: CompVis/stable-diffusion: A latent text-to-image diffusion model (github.com) Stable Diffusion是基于“潜在扩散模型”（latent diffusion model；LDM）的模型，官方项目其实并不适合新手直接使用，好在有一些基于 stable-diffusion 封装的 webui 开源项目，可以通过界面交互的方式来使用，极大的降低了使用门槛，以下是几个比较火的 webui 项目： Stable-Diffusion-WebUI ： AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI Sygil-WebUI：Sygil-Dev/sygil-webui: Stable Diffusion web UI 下面我们主要使用的是 Stable-Diffusion-WebUI进行讲解安装和使用 安装 依赖环境 Git 、Python 3.10.6 在 Github 地址（ AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI）中下载项目到本地。 打开 stable-diffusion-webui/modules/launch.until.py 文件 1torch_command = os.environ.get(&#x27;TORCH_COMMAND&#x27;, &quot;pip install torch==2.0.1 torchvision==0.15.2&quot;) 每个https://github.com/ （就在上一步的下面几行，每一个网址都要改）链接前面添加https://ghproxy.com/，替换为以下内容 12345678gfpgan_package = os.environ.get(&#x27;GFPGAN_PACKAGE&#x27;, &quot;https://ghproxy.com/https://github.com/TencentARC/GFPGAN/archive/8d2447a2d918f8eba5a4a01463fd48e45126a379.zip&quot;)clip_package = os.environ.get(&#x27;CLIP_PACKAGE&#x27;, &quot;https://ghproxy.com/https://github.com/openai/CLIP/archive/d50d76daa670286dd6cacf3bcd80b5e4823fc8e1.zip&quot;)openclip_package = os.environ.get(&#x27;OPENCLIP_PACKAGE&#x27;, &quot;https://ghproxy.com/https://github.com/mlfoundations/open_clip/archive/bb6e834e9c70d9c27d0dc3ecedeebeaeb1ffad6b.zip&quot;)stable_diffusion_repo = os.environ.get(&#x27;STABLE_DIFFUSION_REPO&#x27;, &quot;https://ghproxy.com/https://github.com/Stability-AI/stablediffusion.git&quot;)taming_transformers_repo = os.environ.get(&#x27;TAMING_TRANSFORMERS_REPO&#x27;, &quot;https://ghproxy.com/https://github.com/CompVis/taming-transformers.git&quot;)k_diffusion_repo = os.environ.get(&#x27;K_DIFFUSION_REPO&#x27;, &#x27;https://ghproxy.com/https://github.com/crowsonkb/k-diffusion.git&#x27;)codeformer_repo = os.environ.get(&#x27;CODEFORMER_REPO&#x27;, &#x27;https://ghproxy.com/https://github.com/sczhou/CodeFormer.git&#x27;)blip_repo = os.environ.get(&#x27;BLIP_REPO&#x27;, &#x27;https://ghproxy.com/https://github.com/salesforce/BLIP.git&#x27;) 命令行进入到 stable-diffusion-webui 项目中下载依赖 1pip install requirements.txt 下载完成之后用命令行执行 1./webui.sh 等待启动完毕会提示 1Running on local URL: http://127.0.0.1:7860 访问 http://127.0.0.1:7860 网站即可 汉化 访问网页后找到 Extensions 菜单，选中 Available 标签，将 Hide extensions with tags 全部取消勾选，然后点击 Load From 重新加载扩展列表 在搜索框 Search 中搜索 zh_Hans 然后下载 zh_Hans Localization 下载后在 Installed 标签勾选 stable-diffusion-webui-localization-zh_Hans 插件，然后点击 Apply and restart UI 按钮。 然后到 Settings 菜单 -&gt; User interface -&gt; localization 中勾选 zh_CN ， 点击 Apply Settings， 然后 restart UI 重启完就变成中文界面了。 如果有直接下载汉化包的用户，可以将文件放置\\stable-diffusion-webui\\extensions这个目录下，之后重新载入网址，按照 Settings 设置步骤依次点击就可以变成中文版。 使用 在使用前我们需要下载不同的SD基础模型。 模型站： https://civitai.com/ https://huggingface.co/ https://www.liblibai.com/ https://www.liandange.com/ https://i-desai.com/#/ https://aigccafe.com/ 不用翻墙 以及基础模型 Models - Hugging Face https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt Checkpoint 模型文件通常以 .safetensors 或者 .ckpt 结尾，在模型站中会有标签标记，下载后放置在 stable-diffusion-webui/module/stable-diffusion-webui/ 目录下 Lora模型文件通常以 .safetensors结尾，下载后放置在stable-diffusion-webui/module/lora/ 目录下 安装完之后就可以愉快使用了 参考 Installation on Apple Silicon · AUTOMATIC1111/stable-diffusion-webui Wiki Stable Diffusion简介 - 知乎 喂饭级stable_diffusion_webUI使用教程 - 知乎","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"AI","slug":"技术/AI","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/AI/"},{"name":"Stable Diffusion","slug":"技术/AI/Stable-Diffusion","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/AI/Stable-Diffusion/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"AI","slug":"AI","permalink":"http://blog.heyb.top/tags/AI/"},{"name":"Stable Diffusion","slug":"Stable-Diffusion","permalink":"http://blog.heyb.top/tags/Stable-Diffusion/"}]},{"title":"「Python」Python基于OpenPose实现图片中人体姿态识别","slug":"技术/python/「Python」Python基于OpenPose实现图片中人体姿态识别","date":"2023-06-15T13:51:37.000Z","updated":"2023-06-27T13:13:23.501Z","comments":true,"path":"2023/06/15/python-implementation-of-human-posture-recognition-in-images-based-on-openpose.html","link":"","permalink":"http://blog.heyb.top/2023/06/15/python-implementation-of-human-posture-recognition-in-images-based-on-openpose.html","excerpt":"","text":"背景 合作公司有个小伙伴提到之前要处理图片中对人物裁剪的效果不好，之前仅识别到人脸做一个大概的图片裁切，无法针对半身图，全身图进行。因此希望能够有方式能够识别到人体的关节，识别到人的肩膀， 腰部，腿部等等。 我第一时间想到的是识别到人脸之后，获取到人脸宽高，再按比例去分割图片。例如我们常说九头身的模特身材，就是按人头大小去划分身体。第一个人脸高度为头部，第二个人脸高度为胸口，第三个人脸高度为腰部，这样类推。 不过想到网上应该会有更加成熟的解决方案，所以去网上搜了一下，有一个叫 OpenPose 的开源项目能够很好的满足人体姿态识别的需求。 介绍 OpenPose人体姿态识别项目是美国卡耐基梅隆大学（CMU）基于卷积神经网络和监督学习并以caffe为框架开发的开源库。可以实现人体动作、面部表情、手指运动等姿态估计。适用于单人和多人，具有极好的鲁棒性。是世界上首个基于深度学习的实时多人二维姿态估计应用，基于它的实例如雨后春笋般涌现。人体姿态估计技术在体育健身、动作采集、3D试衣、舆情监测等领域具有广阔的应用前景。 Github地址： https://github.com/CMU-Perceptual-Computing-Lab/openpose 这个项目有新手提供了很大的便利，在 Github Install档中有提供 Windows 安装的版本，或者仅需运行 OpenPose Demo即可（openpose/doc/01_demo.md），该 Demo 提供了处理图片、视频或者网络摄像头的视频流，并展示和后处理结果。 在 OpenPose 中，输入是一个或多个人的图像或视频，在这些图像中，OpenPose 会检测每个人的所有身体部位，并生成一个基于骨架的表示。OpenPose 使用两个深度卷积神经网络来实现此目的:Part Confidence Maps(PCM)和 Part Affinity Fields(PAFs)。PCM 预测每个像素属于人体部件的概率。PAFs则用于预测不同人体部位之间的连接情况。这两个网络都是基于ResNet架构的变形版本。一旦完成了所有部位的识别，OpenPose 将这些部位连接成一个完整的人体骨架，最终呈现出一个基于骨架的表示，呈现出每个人的不同身体部位和位置。 OpenPose 的应用非常广泛，例如自动化驾驶、娱乐、运动分析、医疗等领域，它在这些领域中都有着非常重要的应用。 使用 安装 我们需要通过 Python 来使用 OpenPose 的 API，因此要有Python环境 然后安装 OpenCV 库 1pip install opencv 下载模型 一般我们要加载OpenPose的本地模型来进行识别 模型分为 TensorFlow 模型（.pb 文件）和 Caffe 模型 TensorFlow 模型我没有找到下载和转换的方式，各位如果了解的可以补充一下 Caffe 模型需要拉取 Github 项目下来，在 Models 目录下执行 getModels.bat 或者 getModels.sh 来进行下载 caffemodel 文件 12345cd models.\\getModels.bat # 或者 ./getModels.sh 或者可以直接在网上搜索别人分享的文件，下载完成之后将模型中的 caffemodel 文件和 prototxt 文件一起放到自己项目目录中。 其中官方项目中的 models 目录下面 pose 文件夹，又分为 body_25、coco、MPI。 其中 body_25模型：这个模型是基于COCO数据集进行训练的，其中包含了25个关键点，可以检测出人体的各种姿势，如手臂、腿、头部等。它的训练数据集较大，适用于多种不同场景下的人体姿势估计任务。pose_iter_584000.caffemodel是该模型的网络权重文件。 coco模型：这个模型同样是基于COCO数据集进行训练的，但只包含了18个关键点，相对于body_25模型来说更简化了姿势表示。它的训练数据集中的标注数据是以COCO关键点标注为基础。pose_iter_440000.caffemodel是该模型的网络权重文件。 mpi模型：是基于 MPII 数据集进行训练的，该数据集包含了约 40,000 张单人姿势估计图像，检测出 15 个关键点，涵盖头部、躯干、手臂和腿部等主要部位。相对于COCO和body_25模型，MPI模型提供了更为简化的关键点表示。 我这边使用的是 COCO 模型，因此复制 COCO 目录下的 pose_deploy_linevec.prototxt 文件以及下载好的 pose_iter_440000.caffemodel 到项目目录中使用即可 示例代码 下面是一个示例代码，展示了如何使用 OpenPose 在 Python 中使用摄像头或视频文件获取图像实现多人姿态检测。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import cv2import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;--video&quot;, help=&quot;path to video file. If empty, camera&#x27;s stream will be used&quot;)args = parser.parse_args()cap = cv2.VideoCapture(args.video if args.video else 0)# 导入 OpenPose 模型#net = cv2.dnn.readNetFromTensorflow(&quot;models/pose/graph_opt.pb&quot;)cv2.dnn.readNetFromCaffe(&quot;data//pose/coco/pose_deploy_linevec.prototxt&quot;, &quot;data/pose/coco/pose_iter_440000.caffemodel&quot;) while True: # 从视频流中读取帧 ret, frame = cap.read() # 帧处理 if ret: # 将帧转换为 Blob blob = cv2.dnn.blobFromImage(frame, 1.0 / 255, (368, 368), (0, 0, 0), swapRB=False, crop=False) net.setInput(blob) # 运行前向传递 out = net.forward() # 处理输出 h, w, c = frame.shape points = [] for i in range(18): # 获取每个人体部位的可信度映射（PCM） heatMap = out[0, i, :, :] _, conf, _, point = cv2.minMaxLoc(heatMap) x = int(w * point[0] / out.shape[3]) y = int(h * point[1] / out.shape[2]) # 将部位添加到列表中 points.append((x, y) if conf &gt; 0.1 else None) for pair in POSE_PAIRS: partFrom = pair[0] partTo = pair[1] idFrom = BODY_PARTS_DICT[partFrom] idTo = BODY_PARTS_DICT[partTo] if points[idFrom] and points[idTo]: # 绘制连线 cv2.line(frame, points[idFrom], points[idTo], (0, 255, 0), 2) cv2.circle(frame, points[idFrom], 5, (0, 0, 255), thickness=-1, lineType=cv2.FILLED) # 显示结果 cv2.imshow(&quot;Output-Keypoints&quot;, frame) key = cv2.waitKey(1) if key == 27: breakcap.release()cv2.destroyAllWindows() 单人物人体姿态识别 我在这里实现了一个单人梯姿态识别代码，并且返回上下左右最顶端的坐标数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import cv2import numpy as np# 加载模型和配置文件models = [&#x27;models/pose/coco/pose_deploy_linevec.prototxt&#x27;, &#x27;models/pose/coco/pose_iter_440000.caffemodel&#x27;]net = cv2.dnn.readNetFromCaffe(*models)# 定义人体各部位的名称、颜色、连接关系和顺序body_parts = &#123;&#x27;Nose&#x27;: 0, &#x27;Neck&#x27;: 1, &#x27;RShoulder&#x27;: 2, &#x27;RElbow&#x27;: 3, &#x27;RWrist&#x27;: 4, &#x27;LShoulder&#x27;: 5, &#x27;LElbow&#x27;: 6, &#x27;LWrist&#x27;: 7, &#x27;RHip&#x27;: 8, &#x27;RKnee&#x27;: 9, &#x27;RAnkle&#x27;: 10, &#x27;LHip&#x27;: 11, &#x27;LKnee&#x27;: 12, &#x27;LAnkle&#x27;: 13, &#x27;REye&#x27;: 14, &#x27;LEye&#x27;: 15, &#x27;REar&#x27;: 16, &#x27;LEar&#x27;: 17&#125;colors = [[0, 255, 0], [0, 255, 255], [255, 255, 0], [255, 0, 255], [255, 0, 0], [100, 50, 0], [255, 255, 255], [100, 100, 100], [0, 125, 0], [0, 0, 125], [0, 255, 125], [125, 0, 0], [125, 0, 125], [125, 125, 0], [0, 0, 255], [125, 125, 125], [50, 100, 0], [0, 100, 50]]POSE_PAIRS = [[&#x27;Neck&#x27;, &#x27;RShoulder&#x27;], [&#x27;Neck&#x27;, &#x27;LShoulder&#x27;], [&#x27;RShoulder&#x27;, &#x27;RElbow&#x27;], [&#x27;RElbow&#x27;, &#x27;RWrist&#x27;], [&#x27;LShoulder&#x27;, &#x27;LElbow&#x27;], [&#x27;LElbow&#x27;, &#x27;LWrist&#x27;], [&#x27;Neck&#x27;, &#x27;RHip&#x27;], [&#x27;RHip&#x27;, &#x27;RKnee&#x27;], [&#x27;RKnee&#x27;, &#x27;RAnkle&#x27;], [&#x27;Neck&#x27;, &#x27;LHip&#x27;], [&#x27;LHip&#x27;, &#x27;LKnee&#x27;], [&#x27;LKnee&#x27;, &#x27;LAnkle&#x27;], [&#x27;Nose&#x27;, &#x27;REye&#x27;], [&#x27;REye&#x27;, &#x27;REar&#x27;], [&#x27;Nose&#x27;, &#x27;LEye&#x27;], [&#x27;LEye&#x27;, &#x27;LEar&#x27;], [&#x27;Neck&#x27;, &#x27;Nose&#x27;]]def pose_detection(image, inWidth=368, inHeight=368, scale=0.003922, mean=(0, 0, 0), swapRB=False, crop=False): &quot;&quot;&quot; :param image: 输入的图像数据 :param inWidth: 输入图像的宽度，默认为368 :param inHeight: 输入图像的高度，默认为368 :param scale: 图像缩放因子，默认为0.003922 :param mean: 图像均值，默认为(0, 0, 0) :param swapRB: 是否交换图像通道顺序，默认为False :param crop: 是否进行裁剪，默认为False :return: key_points：关键点坐标数组，get_vertex_coordinates(key_points)的结果：顶点坐标数组 &quot;&quot;&quot; # 读取输入的图像数据 image = cv2.imread(img_path) if image.shape[0] &gt; 800: # 如果图像的高度大于800，按比例缩放到高度为800 image = cv2.resize(image, (int(image.shape[1] * 800 / image.shape[0]), 800)) # 对输入图像进行预处理，生成blob对象 blob = cv2.dnn.blobFromImage(image, scale, (inWidth, inHeight), mean, swapRB, crop) # 输入blob到神经网络中进行推断 net.setInput(blob) # 获取输出结果 output = net.forward() # 显示检测结果并添加关键点名称 H = output.shape[2] W = output.shape[3] # 初始化关键点坐标数组 keypoints = [(0, 0)] * len(body_parts) # 遍历输出结果，获取每个关键点的置信度和坐标 for i, part_name in enumerate(body_parts): confidenceMap = output[0, i, :, :] _, conf, _, point = cv2.minMaxLoc(confidenceMap) x = int((image.shape[1] * point[0]) / W) y = int((image.shape[0] * point[1]) / H) if conf &gt; 0.1 and (x, y) != (0, 0): print((x, y)) # 将符合条件的关键点坐标保存到数组中 keypoints[i] = (x, y) # 在图像上显示关键点 cv2.circle(image, (x, y), 5, (0, 255, 255), -1) cv2.putText(image, &quot;&#123;&#125;&quot;.format(part_name), (x, y + 30), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1) cv2.putText(image, &quot;(&#123;&#125;, &#123;&#125;)&quot;.format(x, y), (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1) # 将关键点两两相连并绘制到图像中 for pair in POSE_PAIRS: part_a = pair[0] part_b = pair[1] if part_a in body_parts.keys() and part_b in body_parts.keys(): id_a = body_parts[part_a] id_b = body_parts[part_b] if keypoints[id_a][0] != 0 and keypoints[id_a][1] != 0 and keypoints[id_b][0] != 0 and keypoints[id_b][ 1] != 0: cv2.line(image, keypoints[id_a], keypoints[id_b], colors[id_a], 2) # 去除关键点数组中的无效点（坐标为(0, 0)） keypoints = [item for item in keypoints if item != (0, 0)] # 将关键点数组转换为NumPy数组 key_points = np.array(keypoints) # 显示处理后的图像 cv2.imshow(&quot;output&quot;, image) cv2.waitKey(0) cv2.destroyAllWindows() # 打印关键点数组的类型 print(type(key_points)) # 返回关键点数组和顶点坐标数组 return key_points, get_vertex_coordinates(key_points)def get_vertex_coordinates(arr): &quot;&quot;&quot; 获取坐标数组中的四个顶点坐标 :param arr: 包含坐标点的二维数组，行表示点的数量，列表示每个点的坐标轴数量 :return: arr 一个按照顺时针方向排列的四个顶点的坐标数组 &quot;&quot;&quot; # 找到最上、最下、最左、最右四个点的索引 # 找到y轴坐标最小的点的索引 top_idx = np.argmin(arr[:, 1]) # 找到y轴坐标最大的点的索引 bottom_idx = np.argmax(arr[:, 1]) # 找到x轴坐标最小的点的索引 left_idx = np.argmin(arr[:, 0]) # 找到x轴坐标最大的点的索引 right_idx = np.argmax(arr[:, 0]) # 输出最上、最下、最左和最右四个点的坐标 print(&quot;最上坐标为：(&#123;&#125;, &#123;&#125;)&quot;.format(arr[top_idx][0], arr[top_idx][1])) print(&quot;最下坐标为：(&#123;&#125;, &#123;&#125;)&quot;.format(arr[bottom_idx][0], arr[bottom_idx][1])) print(&quot;最左坐标为：(&#123;&#125;, &#123;&#125;)&quot;.format(arr[left_idx][0], arr[left_idx][1])) print(&quot;最右坐标为：(&#123;&#125;, &#123;&#125;)&quot;.format(arr[right_idx][0], arr[right_idx][1])) # 按上右下左顺时针方向创建一个包含四个顶点坐标的数组 coordinates = np.array([ [arr[top_idx][0], arr[top_idx][1]], [arr[right_idx][0], arr[right_idx][1]], [arr[bottom_idx][0], arr[bottom_idx][1]], [arr[left_idx][0], arr[left_idx][1]] ]) return coordinatesif __name__ == &#x27;__main__&#x27;: # 读取输入图像 img_path = &#x27;img/img.png&#x27; # 进行人体姿态估计 key_points, vertex_coordinates = pose_detection(image=img_path) print(&#x27;关键点坐标：&#x27;, key_points) print(&#x27;四个顶点坐标：&#x27;, vertex_coordinates) 这个代码可以满足单个人物的姿态识别，并且能够获取到每个关节点的坐标，可以依据坐标进行裁剪图片，但是存在多个人物的时候，会出现识别有误，效果并不是很理想。 多人物人体姿态识别 然后再找到了 LearnOpenCV 的一个多人姿态检测实现的文章（译文可见基于OpenCV使用OpenPose进行多个人体姿态估计 ）。 主要实现方式是识别多个人物的关键点（例如鼻子），再通过关键点查找有效连接点，例如某人鼻子的左肩通常为这个人的左肩，他右边识别到的左肩则应该为另外一个人的左肩。通过亲和性方向进行识别和连接然后组合就能识别出来不同人物的姿态组，再通过姿态组绘制骨骼图就得到最终我们想要的多人物姿态识别。感兴趣的朋友可以自行查阅原文。 以下是我实际可用的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377import argparseimport timeimport cv2import numpy as np&quot;&quot;&quot;该文件主要用于识别人体姿态并输出最边缘坐标主要函数为 detect_pose不需要预览结果请注释 cv2.imshow 等相关代码即可依赖库opencv-python~=4.7.0.72numpy~=1.24.2&quot;&quot;&quot;# 设定模型文件路径和关键点数量等信息# 模型结构文件protoFile = &quot;data//pose/coco/pose_deploy_linevec.prototxt&quot;# 训练好的参数文件weightsFile = &quot;data/pose/coco/pose_iter_440000.caffemodel&quot;# COCO 数据集中人体关键点的数量nPoints = 18# COCO 数据集中的人体关键点名称列表keypointsMapping = [&#x27;Nose&#x27;, &#x27;Neck&#x27;, &#x27;R-Shoulder&#x27;, &#x27;R-Elbow&#x27;, &#x27;R-Wrist&#x27;, &#x27;L-Shoulder&#x27;, &#x27;L-Elbow&#x27;, &#x27;L-Wrist&#x27;, &#x27;R-Hip&#x27;, &#x27;R-Knee&#x27;, &#x27;R-Ankle&#x27;, &#x27;L-Hip&#x27;, &#x27;L-Knee&#x27;, &#x27;L-Ankle&#x27;, &#x27;R-Eye&#x27;, &#x27;L-Eye&#x27;, &#x27;R-Ear&#x27;, &#x27;L-Ear&#x27;]# 定义连接不同关键点之间的线段，即人体的姿势# 在 COCO 输出格式中，关键点的编号从 0 开始，即第 0 个点表示 Nose，最后一个点是 L-EarPOSE_PAIRS = [[1, 2], [1, 5], [2, 3], [3, 4], [5, 6], [6, 7], [1, 8], [8, 9], [9, 10], [1, 11], [11, 12], [12, 13], [1, 0], [0, 14], [14, 16], [0, 15], [15, 17], [2, 17], [5, 16]]# 定义每个 POSE_PAIRS 对应的 PAF 在输出中的索引# pafs与POSE_PAIRS的索引，例如，对于POSE_PAIR（1,2），PAF位于输出的指数（31,32），类似，（1,5）-&gt;（39,40）等。# PAF 表示 Part Affinity Fields，即用于描述关键点之间连接情况的向量场# 在这里，使用了 COCO 数据集中提供的预训练模型，其输出结果包括关键点坐标和 PAFmapIdx = [[31, 32], [39, 40], [33, 34], [35, 36], [41, 42], [43, 44], [19, 20], [21, 22], [23, 24], [25, 26], [27, 28], [29, 30], [47, 48], [49, 50], [53, 54], [51, 52], [55, 56], [37, 38], [45, 46]]# # 定义用于绘制不同连接线段的颜色，根据定义的姿势连接线段，每个连接线段对应一种颜色colors = [[0, 100, 255], [0, 100, 255], [0, 255, 255], [0, 100, 255], [0, 255, 255], [0, 100, 255], [0, 255, 0], [255, 200, 100], [255, 0, 255], [0, 255, 0], [255, 200, 100], [255, 0, 255], [0, 0, 255], [255, 0, 0], [200, 200, 0], [255, 0, 0], [200, 200, 0], [0, 0, 0]]# 存储检测出来的所有关键点坐标列表，用于后续计算顶点points = []def detect_pose(image_path): &quot;&quot;&quot; 检测姿势 :param image_path: 图片路径 :return: 返回 pose, points 其中 pose 为 points 为 按照顺时针方向排列（即上右下左）的四个最顶点的坐标数组 调用函数例子如下： path = &quot;img/test.png&quot; pose, points = detect_pose(path) print(points) &quot;&quot;&quot; # 创建一个解析器 parser = argparse.ArgumentParser(description=&#x27;运行关键点检测&#x27;) # 添加参数 parser.add_argument(&quot;--device&quot;, default=&quot;cpu&quot;, help=&quot;推理设备&quot;) parser.add_argument(&quot;--image_file&quot;, default=image_path, help=&quot;输入图像&quot;) # 解析参数 args = parser.parse_args() # 读取输入图像 image1 = cv2.imread(args.image_file) def getKeypoints(probMap, threshold=0.1): &quot;&quot;&quot; 从输入的概率图（即 probMap）中提取关键点信息 :param probMap: 概率图 :param threshold: 二值化概率图时所采用的阈值，默认为 0.1 值较小时，可以提取出更多的关键点，但可能会包含一些噪声或冗余信息 值较大时，可以减少关键点的数量，但可能会漏掉一些有用信息 :return: 关键点列表 &quot;&quot;&quot; # 对概率图进行高斯模糊，以去除噪声。 mapSmooth = cv2.GaussianBlur(probMap, (3, 3), 0, 0) # 二值化概率图，生成一个二值掩模 mapMask = np.uint8(mapSmooth &gt; threshold) # 寻找轮廓 contours, _ = cv2.findContours(mapMask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) keypoints = [] # 针对每个轮廓寻找最大值 for cnt in contours: # 构造一个与原图大小一致的全黑图像 blobMask = np.zeros(mapMask.shape) # 在全黑图像上填充轮廓，轮廓内部的像素值为 1，其余像素值为 0 blobMask = cv2.fillConvexPoly(blobMask, cnt, 1) # 计算概率图中对应区域的最大值和坐标， 将概率图与二值图像相乘，得到关键点所在区域的图像 maskedProbMap = mapSmooth * blobMask # 在关键点所在区域的图像中，寻找最大值及其坐标，即关键点的位置 _, maxVal, _, maxLoc = cv2.minMaxLoc(maskedProbMap) # 在关键点列表中加入当前关键点的坐标和对应概率 keypoints.append(maxLoc + (probMap[maxLoc[1], maxLoc[0]],)) # 冗余存储各关键点坐标，用于下面计算顶点坐标 points.append(maxLoc) # 返回关键点列表 return keypoints def getValidPairs(output): &quot;&quot;&quot; 在所有检测到的人中，寻找有效连接关系 :param output: 检测到的人体内容 :return: 有效连接关系列表，无效连接关系列表 &quot;&quot;&quot; # 存储有效连接关系 valid_pairs = [] # 存储无效连接关系 invalid_pairs = [] # 插值采样点数目 n_interp_samples = 10 # PAF 对齐阈值 paf_score_th = 0.1 # 有效连接容忍度阈值 conf_th = 0.7 # 对于每个 POSE_PAIR 进行如下处理 for k in range(len(mapIdx)): # 获取该连线关系相关联的两个 PAF pafA = output[0, mapIdx[k][0], :, :] pafB = output[0, mapIdx[k][1], :, :] # 调整 PAF 的大小为原始图像的大小 pafA = cv2.resize(pafA, (frameWidth, frameHeight)) pafB = cv2.resize(pafB, (frameWidth, frameHeight)) # 获取第一条连线关系和第二条连线关系的关键点 candA = detected_keypoints[POSE_PAIRS[k][0]] candB = detected_keypoints[POSE_PAIRS[k][1]] # 连线关系的关键点数目 nA = len(candA) nB = len(candB) # 如果检测到了该连线关系的关键点，遍历所有关键点，计算距离向量并进行插值 # 最后根据公式计算连接得分，并判断连接是否有效 if (nA != 0 and nB != 0): valid_pair = np.zeros((0, 3)) for i in range(nA): max_j = -1 maxScore = -1 found = 0 for j in range(nB): # 计算两个关键点之间的向量 d_ij d_ij = np.subtract(candB[j][:2], candA[i][:2]) # 计算 d_ij 的模长 norm = np.linalg.norm(d_ij) if norm: # 归一化处理 d_ij = d_ij / norm else: continue # # 对连接中介进行插值，生成 n_interp_samples 个采样点 p(u) interp_coord = list(zip(np.linspace(candA[i][0], candB[j][0], num=n_interp_samples), np.linspace(candA[i][1], candB[j][1], num=n_interp_samples))) # # 查询 PAF 值 L(p(u)) paf_interp = [] for k in range(len(interp_coord)): paf_interp.append([pafA[int(round(interp_coord[k][1])), int(round(interp_coord[k][0]))], pafB[int(round(interp_coord[k][1])), int(round(interp_coord[k][0]))]]) # 计算连接得分 E paf_scores = np.dot(paf_interp, d_ij) avg_paf_score = sum(paf_scores) / len(paf_scores) # 如果插值采样点中对齐 PAF 向量的比例高于阈值，则判定为有效连接关系 if (len(np.where(paf_scores &gt; paf_score_th)[0]) / n_interp_samples) &gt; conf_th: if avg_paf_score &gt; maxScore: max_j = j maxScore = avg_paf_score found = 1 # 将有效连接信息添加到列表中 if found: valid_pair = np.append(valid_pair, [[candA[i][3], candB[max_j][3], maxScore]], axis=0) # 将有效连接信息存入全局列表中 valid_pairs.append(valid_pair) else: # 没有检测到关键点，说明连接无效 print(&quot;没有连接 : k = &#123;&#125;&quot;.format(k)) invalid_pairs.append(k) valid_pairs.append([]) # 返回有效连接关系列表和无效连接关系列表 return valid_pairs, invalid_pairs def getPersonwiseKeypoints(valid_pairs, invalid_pairs): &quot;&quot;&quot; 遍历所有有效连接关系，将其对应的关键点分配给不同的人，并计算出每个人在当前姿态下的得分。 这样可以更为合适地去描绘人体姿态，减少出现 A 的左眼连结到 B 的右眼的情况 :param valid_pairs: 有效连接关系列表 :param invalid_pairs: 无效连接关系列表 :return: 个性化关键点数组 &quot;&quot;&quot; # 每一行最后一个元素是总得分 personwiseKeypoints = -1 * np.ones((0, 19)) # 遍历所有有效连接关系 for k in range(len(mapIdx)): if k not in invalid_pairs: # partAs 和 partBs 分别是相互连接的两个关节点 partAs = valid_pairs[k][:, 0] partBs = valid_pairs[k][:, 1] indexA, indexB = np.array(POSE_PAIRS[k]) # 将 B 的分数加到 A 所在行的总得分中，或创建一个新行 for i in range(len(valid_pairs[k])): found = 0 person_idx = -1 # 在已有的姿态中查找 partA。 for j in range(len(personwiseKeypoints)): if personwiseKeypoints[j][indexA] == partAs[i]: person_idx = j found = 1 break # 如果在当前姿态中找到了与 partA 相关联的关键点，则将 partB 添加到该行。 if found: personwiseKeypoints[person_idx][indexB] = partBs[i] # 在该姿态下，添加 partB 的关键点分数以及连接得分到该行的总得分中。 personwiseKeypoints[person_idx][-1] += keypoints_list[partBs[i].astype(int), 2] + \\ valid_pairs[k][i][ 2] # 如果当前姿态中不存在与 partA 相关联的关键点，则创建一个新姿态 elif not found and k &lt; 17: row = -1 * np.ones(19) row[indexA] = partAs[i] row[indexB] = partBs[i] # 在该姿态下，将两个关键点的关键点分数 scores 以及连接得分加起来作为该行的总得分。 row[-1] = sum(keypoints_list[valid_pairs[k][i, :2].astype(int), 2]) + valid_pairs[k][i][2] personwiseKeypoints = np.vstack([personwiseKeypoints, row]) # 最终返回一个二维数组，每行代表一个人体姿态，每列代表一个关节点。 return personwiseKeypoints # 获取图像的宽度和高度 frameWidth = image1.shape[1] frameHeight = image1.shape[0] t = time.time() # 从磁盘上读取预训练模型 net = cv2.dnn.readNetFromCaffe(protoFile, weightsFile) # 指定运行模型的设备类型，如果使用CPU则设置为CPU，否则设置为GPU if args.device == &quot;cpu&quot;: net.setPreferableBackend(cv2.dnn.DNN_TARGET_CPU) print(&quot;使用 CPU&quot;) elif args.device == &quot;gpu&quot;: net.setPreferableBackend(cv2.dnn.DNN_BACKEND_CUDA) net.setPreferableTarget(cv2.dnn.DNN_TARGET_CUDA) print(&quot;使用 GPU&quot;) # 固定输入图像的高度，并根据图像的宽高比来计算输入的宽度 inHeight = 368 inWidth = int((inHeight / frameHeight) * frameWidth) # 将输入图像转换为Blob格式，并进行归一化和缩放 inpBlob = cv2.dnn.blobFromImage(image1, 1.0 / 255, (inWidth, inHeight), (0, 0, 0), swapRB=False, crop=False) # 将输入Blob传递给网络 net.setInput(inpBlob) # 运行前馈传递，可以获取到识别的人脸 output = net.forward() print(&quot;前馈传递所需时间 = &#123;&#125;&quot;.format(time.time() - t)) # 定义一个列表用于存储检测出的所有关键点 detected_keypoints = [] # 创建一个 shape 为 (0, 3) 的 numpy 数组，用于保存关键点的位置和 id keypoints_list = np.zeros((0, 3)) # 初始化关键点 id keypoint_id = 0 # 设置概率阈值 threshold = 0.1 # 遍历每个关键点 for part in range(nPoints): # 获取关键点对应的概率图，并将其 resize 到与输入图像相同的大小 probMap = output[0, part, :, :] probMap = cv2.resize(probMap, (image1.shape[1], image1.shape[0])) # 根据阈值获取该关键点的位置 keypoints = getKeypoints(probMap, threshold) # 输出该关键点的位置信息 print(&quot;Keypoints - &#123;&#125; : &#123;&#125;&quot;.format(keypointsMapping[part], keypoints)) # 存储关键点的位置和 id keypoints_with_id = [] for i in range(len(keypoints)): keypoints_with_id.append(keypoints[i] + (keypoint_id,)) keypoints_list = np.vstack([keypoints_list, keypoints[i]]) keypoint_id += 1 detected_keypoints.append(keypoints_with_id) # 在原始图像上绘制所有检测出的关键点和 id frameClone = image1.copy() for i in range(nPoints): for j in range(len(detected_keypoints[i])): # 输出关键点对应的坐标和名称 print(detected_keypoints[i][j][0:2]) cv2.putText(frameClone, &quot;&#123;&#125;&quot;.format(keypointsMapping[i]), detected_keypoints[i][j][0:2], cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1) cv2.putText(frameClone, &quot;(&#123;&#125;)&quot;.format(detected_keypoints[i][j]), detected_keypoints[i][j][0:2], cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1) cv2.circle(frameClone, detected_keypoints[i][j][0:2], 5, colors[i], -1, cv2.LINE_AA) # 在原始图像上绘制每条相邻关键点之间的连线，描绘人体的姿态 valid_pairs, invalid_pairs = getValidPairs(output) personwiseKeypoints = getPersonwiseKeypoints(valid_pairs, invalid_pairs) for i in range(17): for n in range(len(personwiseKeypoints)): index = personwiseKeypoints[n][np.array(POSE_PAIRS[i])] if -1 in index: continue B = np.int32(keypoints_list[index.astype(int), 0]) A = np.int32(keypoints_list[index.astype(int), 1]) cv2.line(frameClone, (B[0], A[0]), (B[1], A[1]), colors[i], 3, cv2.LINE_AA) # 可视化显示检测结果，仅供预览使用，这部分可注释 cv2.imshow(&quot;关键点&quot;, frameClone) cv2.imshow(&quot;姿态检测&quot;, frameClone) cv2.waitKey(0) # 返回检测到的人体关键点和身体姿态的信息 return personwiseKeypoints[0] if len(personwiseKeypoints) &gt; 0 else None, get_vertex_coordinates(points)def get_vertex_coordinates(arr): &quot;&quot;&quot; 获取坐标数组中的四个顶点坐标 :param arr: 包含坐标点的二维数组，行表示点的数量，列表示每个点的坐标轴数量 :return: arr 一个按照顺时针方向排列的四个顶点的坐标数组 &quot;&quot;&quot; arr = np.array(arr) # 找到最上、最下、最左、最右四个点的索引 # 找到y轴坐标最小的点的索引 top_idx = np.argmin(arr[:, 1]) # 找到y轴坐标最大的点的索引 bottom_idx = np.argmax(arr[:, 1]) # 找到x轴坐标最小的点的索引 left_idx = np.argmin(arr[:, 0]) # 找到x轴坐标最大的点的索引 right_idx = np.argmax(arr[:, 0]) # 输出最上、最下、最左和最右四个点的坐标 print(&quot;最上坐标为：(&#123;&#125;, &#123;&#125;)&quot;.format(arr[top_idx][0], arr[top_idx][1])) print(&quot;最下坐标为：(&#123;&#125;, &#123;&#125;)&quot;.format(arr[bottom_idx][0], arr[bottom_idx][1])) print(&quot;最左坐标为：(&#123;&#125;, &#123;&#125;)&quot;.format(arr[left_idx][0], arr[left_idx][1])) print(&quot;最右坐标为：(&#123;&#125;, &#123;&#125;)&quot;.format(arr[right_idx][0], arr[right_idx][1])) # 按上右下左顺时针方向创建一个包含四个顶点坐标的数组 coordinates = np.array([ [arr[top_idx][0], arr[top_idx][1]], [arr[right_idx][0], arr[right_idx][1]], [arr[bottom_idx][0], arr[bottom_idx][1]], [arr[left_idx][0], arr[left_idx][1]] ]) return coordinatesif __name__ == &#x27;__main__&#x27;: path = &quot;../data/result.png&quot; pose, points = detect_pose(path) print(&#x27;------------&#x27;) print(points) 结果返回了多个关键点和四个方向顶点坐标数组，可以看到效果还是很好的，可以满足业务需求了。 参考 Github开源人体姿态识别项目OpenPose中文文档 - 简书 基于OpenCV使用OpenPose进行多个人体姿态估计_qq_27158179的CSDN博客 Multi Person Pose Estimation in OpenCV using OpenPose (learnopencv.com)","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://blog.heyb.top/tags/OpenCV/"},{"name":"OpenPose","slug":"OpenPose","permalink":"http://blog.heyb.top/tags/OpenPose/"},{"name":"人体姿态识别","slug":"人体姿态识别","permalink":"http://blog.heyb.top/tags/%E4%BA%BA%E4%BD%93%E5%A7%BF%E6%80%81%E8%AF%86%E5%88%AB/"}]},{"title":"「Python」Python基于OpenCV实现图片中人脸识别","slug":"技术/python/「Python」Python基于OpenCV实现图片中人脸识别","date":"2023-06-11T14:20:48.000Z","updated":"2023-06-27T07:56:12.523Z","comments":true,"path":"2023/06/11/python-implementation-of-face-recognition-in-images-based-on-opencv.html","link":"","permalink":"http://blog.heyb.top/2023/06/11/python-implementation-of-face-recognition-in-images-based-on-opencv.html","excerpt":"","text":"背景 最近在和一家科技设计公司合作，需要从大量图片中挑选出含有人物的图片。因此考虑使用 OpenCV 进行人脸识别，有检测到人脸的图片再进额外的处理 介绍 OpenCV是一个跨平台的计算机视觉库，支持Windows、Linux、macOS等操作系统。它提供了丰富的接口和函数，包括图像处理、计算机视觉、模式识别、机器学习等领域，可用于多种计算机视觉应用，如人脸识别、行人检测、运动跟踪、医学图像处理、目标识别等。 Github仓库：https://github.com/opencv/opencv 安装 1pip install opencv-python 安装完成后，我们就可以开始使用OpenCV在Python中实现各种计算机视觉任务了。 图像处理 使用OpenCV读取和显示图像 1234567891011import cv2# 读取图像img = cv2.imread(&#x27;image.jpg&#x27;)# 显示图像。接受两个参数：窗口名称（在这里是&quot;Image&quot;）和要显示的图像。cv2.imshow(&#x27;Image&#x27;, img)# 等待按键输入的函数。它会暂停程序执行，直到用户按下任意键。括号中的参数0表示无限等待用户的键盘输入。cv2.waitKey(0)# 销毁所有创建的窗口的函数，会关闭显示图像的窗口。cv2.destroyAllWindows() 除了读取和显示图像外，OpenCV还提供了许多其他图像处理功能，如调整大小、旋转、裁剪、灰度化、边缘检测、过滤器、形态学运算等。 例如，下面的代码实现了将图像缩小一半，并进行灰度化和Canny边缘检测： 123456789101112131415161718import cv2# 读取图像img = cv2.imread(&#x27;image.jpg&#x27;)# 缩小图像。将图像缩小到原来尺寸的50%。这里通过设置fx=0.5和fy=0.5来实现等比例缩小。resized_img = cv2.resize(img, (0, 0), fx=0.5, fy=0.5)# 灰度化图像，将缩小后的彩色图像转换为灰度图像。这里使用cv2.COLOR_BGR2GRAY参数表示从BGR颜色空间转换为灰度颜色空间。gray = cv2.cvtColor(resized_img, cv2.COLOR_BGR2GRAY)# 使用Canny边缘检测算法，对灰度图像进行边缘检测。参数100和200分别表示边缘梯度的阈值edges = cv2.Canny(gray, 100, 200)# 显示边缘检测结果cv2.imshow(&#x27;Edges&#x27;, edges)cv2.waitKey(0)cv2.destroyAllWindows() 人脸检测 OpenCV提供了多种方法来实现人脸检测，其中一种常用的方法是使用Haar 特征 （Haar-like Features） Cascade分类器。下面的代码演示了如何使用OpenCV在Python中实现人脸检测： 12345678910111213141516171819202122import cv2# 加载Haar Cascade分类器模型face_cascade = cv2.CascadeClassifier(&#x27;haarcascade_frontalface_default.xml&#x27;)# 读取图像img = cv2.imread(&#x27;image.jpg&#x27;)# 将图像转换为灰度图像gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 调用Haar Cascade分类器检测人脸faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)# 在原始图像中绘制人脸框for (x, y, w, h) in faces: cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)# 显示图像cv2.imshow(&#x27;Faces&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 这个分类器模型可以在 OpenCV 的 Github 仓库中的 data/haarcascades 目录中找到并且下载 opencv/data/haarcascades 可以看到有 haarcascade_frontalface _default.xml 人脸检测级联分类器的默认模型。它对于一般情况下的人脸检测具有较好的效果，但在某些复杂场景下可能会有一些限制。 haarcascade_frontalface_alt.xml 用于检测正面人脸。它在一般情况下具有较好的检测性能，并且速度相对较快。 haarcascade_ frontalface_alt2.xml alt 的改进版本，对于一些复杂场景或具有不同角度的人脸也能进行较好的检测。 haarcascade_ frontalface_alt_tree.xml 在 alt 的基础上使用了更复杂的级联结构，提高了人脸检测的准确性和鲁棒性。它通常对于复杂背景和表情变化较大的人脸具有更好的效果，但相应的检测速度可能会稍慢一些。 通常我们使用 alt2 就可以取得很好的效果 使用 我们可以看到 detectMultiScale 函数中有需要传入 scaleFactor 和 minNeighbors 参数。 scaleFactor 用于指定在图像金字塔中采用多大的步长搜索人脸。它的值越小，搜索所花费的时间和检测精度都会增加。一般情况下，值在 1.01 到 1.5 之间逐步增加可以获得比较理想的效果。 minNeighbors 是指人脸矩形相邻两个矩形之间的最小有效距离，也就是当检测到一个人脸时，如果该矩形周围有比它更小的矩形，则认为该矩形并非人脸矩形，会被过滤掉。这个参数的值越大，过滤掉的矩形就越多，同时漏检率也会增加，而值越小，检出的矩形较多，但误检率也会增加。一般情况下，建议在 3-6 之间取值。 我们也可以通过跟踪当前检测到的人脸数量和大小与预期值之间的差距，然后根据差距来自动调整检测器的参数。例如，当检测到的人脸数量过少时，可以尝试减小 minNeighbors 参数或增加 scaleFactor 参数，以扩大检测范围；而当检测到的人脸数量过多时，则可以尝试增加 minSize 参数，以过滤掉小尺寸的误检测。 动态调整参数可以使用反馈控制的方法。具体来说，可以根据当前检测到人脸的数量和大小与预期值之间的差距，自动调整检测器的参数，以达到更好的检测效果。 下面是完整代码，请留意 while True 部分代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import cv2def dynamic_face_detection(img_path, target_count=1, min_width=50, min_height=50, scale_factor=1.1, min_neighbors=3): &quot;&quot;&quot; 动态人脸检测函数 :param img_path: 输入图像的文件路径 :param target_count: 目标检测到的人脸数量，默认为4 :param min_width: 最小人脸宽度，默认为50 :param min_height: 最小人脸高度，默认为50 :param scale_factor: 窗口缩放比例因子，默认为1.1 :param min_neighbors: 每个候选矩形应该保留的邻居数，默认为3 :return: faces_vertices 检测到的人脸顶点坐标数组，格式为[((x1, y1), (x2, y2), (x3, y3), (x4, y4)), ...] &quot;&quot;&quot; # 读取输入图像 img = cv2.imread(img_path) # 转换为灰度图像 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 初始化人脸检测器 face_cascade = cv2.CascadeClassifier(&#x27;./models/cv/haarcascades/haarcascade_frontalface_alt2.xml&#x27;) # 初始化参数 while True: # 调用人脸检测器 faces = face_cascade.detectMultiScale(gray, scaleFactor=scale_factor, minNeighbors=min_neighbors, minSize=(min_width, min_height)) # 检测到目标数量，终止算法 if len(faces) == target_count: break # 计算当前平均人脸大小 total_width = sum([f[2] for f in faces]) total_height = sum([f[3] for f in faces]) avg_width = total_width / len(faces) avg_height = total_height / len(faces) # 针对检测结果进行参数调整 if len(faces) &lt; target_count: # 当检测到人脸数量过少时，减小 min_neighbors 或者增加 scaleFactor if min_neighbors &gt; 1: min_neighbors -= 1 else: scale_factor += 0.1 elif len(faces) &gt; target_count: # 当检测到人脸数量过多时，增加 min_width 或者 min_height min_width = int(avg_width * 1.1) min_height = int(avg_height * 1.1) # 避免参数过大或过小 scale_factor = max(1, min(scale_factor, 2)) min_neighbors = max(1, min(min_neighbors, 10)) min_width = max(20, min(min_width, 200)) min_height = max(20, min(min_height, 200)) faces_vertices = [] # 在图像中绘制检测到的人脸矩形 for (x, y, w, h) in faces: # 绘制人脸矩形 cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2) # 绘制顶点像素位置 # 第一个参数是输入图像，第二个参数是要添加的文本，第三个参数是文本要显示的位置，第四个参数是字体，第五个参数是字体大小，第六个参数是颜色，第七个参数是文本厚度 cv2.putText(img, f&quot;(&#123;x&#125;, &#123;y&#125;)&quot;, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (0, 0, 255), 2) cv2.putText(img, f&quot;(&#123;x + w&#125;, &#123;y&#125;)&quot;, (x + w, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (0, 0, 255), 2) cv2.putText(img, f&quot;(&#123;x&#125;, &#123;y + h&#125;)&quot;, (x, y + h + 40), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (0, 0, 255), 2) cv2.putText(img, f&quot;(&#123;x + w&#125;, &#123;y + h&#125;)&quot;, (x + w, y + h + 40), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (0, 0, 255), 2) # 添加顶点到数组中 top_left = (x, y) top_right = (x + w, y) bottom_right = (x + w, y + h) bottom_left = (x, y + h) vertices = (top_left, top_right, bottom_right, bottom_left) faces_vertices.append(vertices) # 预览检测结果 cv2.imshow(&#x27;Dynamic Face Detection&#x27;, img) cv2.waitKey(0) cv2.destroyAllWindows() # 返回检测到的人脸顶点坐标数组 return faces_verticesif __name__ == &#x27;__main__&#x27;: url = &#x27;./img/img2.png&#x27; dynamic_face_detection(url) 总结 通过本文，我们了解了OpenCV的功能及应用领域、如何在Python中使用OpenCV实现图像处理和人脸检测等计算机视觉任务。OpenCV还支持多种其他计算机视觉操作，例如目标跟踪、形态学运算、特征提取和机器学习等。 需要注意的是，在实际使用过程中，应根据具体要求和数据集选用不同的算法和模型，并对其进行调优和优化，以充分发挥OpenCV的性能和应用优势。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://blog.heyb.top/tags/OpenCV/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://blog.heyb.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"}]},{"title":"「Python」Python实现提取图片中的主要配色方案","slug":"技术/python/「Python」Python实现提取图片中的主要配色方案","date":"2023-06-07T06:42:11.000Z","updated":"2023-06-07T07:52:11.285Z","comments":true,"path":"2023/06/07/python-implementation-for-extracting-the-main-color-schemes-in-images.html","link":"","permalink":"http://blog.heyb.top/2023/06/07/python-implementation-for-extracting-the-main-color-schemes-in-images.html","excerpt":"","text":"背景 当我们设计图片或网页时，配色方案是非常重要的一环。一个好的配色可以为我们的作品增添美感和视觉冲击力。因此，我们可以参考一些出色作品的配色方案来寻求灵感。 Haishoku 是一个基于 Python 的开源色彩分析库，可用于提取图像中的主要颜色和色调。其可以读取图片文件，自动提取出其中的主色调、辅助色和背景色等颜色，并将其以 RGB 和 HEX 等格式输出。Haishoku 还提供了示例代码和 API 文档，方便用户进行使用和二次开发。通过 Haishoku，我们可以方便地获取图片的主色调和配色方案，为我们的设计等工作提供便利。 介绍 Github仓库：LanceGin/haishoku Haishoku 是一个用来获取图片主色调和主要配色方案的python库，依赖于python3和pillow。 功能 获取图片的 主色调 获取图片的 配色方案 从v1.1.4版本开始，可以直接从网络url生成Haishoku对象 安装 1pip3 install haishoku 如果提示没有pip3，可能需要按以下方式安装： 1python3 -m pip install haishoku API • loadHaishoku( image ) 12from haishoku.haishoku import Haishokuhaishoku = Haishoku.loadHaishoku(image) 接口会返回一个Haishoku实例，你可以通过实例属性haishoku.dominant 和 haishoku.palette直接获取到对应的主色调 和 配色方案 当然，也提供了更加直接的接口用来获取对应颜色的值以及临时预览颜色，如下： • getDominant( image ) 12from haishoku.haishoku import Haishokudominant = Haishoku.getDominant(image) 返回结构为 (R, G, B) 的一个 元组 • showDominant( image ) 12from haishoku.haishoku import HaishokuHaishoku.showDominant( image ) 接口会打开一个临时文件用来预览主色调的颜色。（不会保存在本地） • getPalette( image ) 12from haishoku.haishoku import Haishokupalette = Haishoku.getPalette( image ) 返回一个结构为： [(percentage, (R, G, B)), (percentage, (R, G, B)), …] 最大长度为8的数组 • showPalette( image） 12from haishoku.haishoku import HaishokuHaishoku.showPalette(image) 接口会打开一个临时文件用来预览图片配色方案。（不会保存在本地） 使用 我们获取配色方案的核心代码其实就两行 1234# 载入图片的颜色信息haishoku = Haishoku.loadHaishoku(img_path)# 返回配色方案的数组，内容格式为 [(颜色占据的百分比, (红,绿,蓝的RGB色值))]haishoku.palette 剩下的我们只需要处理 haishoku.palette 数据，获取到里面的 RGB 色值，然后另外绘制到新的图片中即可。 总体思路为新建一个空白背景，并将图片等比缩放指定的像素，填入到背景当中，然后再将配色方案绘制成为色块，填充到图片下方即可。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import osfrom PIL import Image, ImageDrawfrom haishoku.haishoku import Haishokudef get_color_schema(img_path): &quot;&quot;&quot; 生成图片的配色方案，并返回一张新的图片，其中包含原图和配色方案 此方法的作用是为传入的图片生成配色方案，并将原图和配色方案合并成一张新图片，最后以添加前缀 &quot;color_schema_&quot; 的方式保存。 其中，使用 Haishoku.loadHaishoku(img_path) 方法获取图片的颜色信息， 使用 Image.open(img_path) 方法打开图片文件，使用 .size 获取图片大小，计算缩放后的大小， 使用 .resize(new_size) 进行缩放。 然后计算配色方案中的每行应显示的颜色块数量，计算每个颜色块的宽度和高度，新建白色背景图片并将原始图片贴到新图片顶部。 接着，获取配色方案，并使用 Image.new() 方法新建一张图片，绘制矩形块表示颜色，并添加颜色名称， 最后在新图片上绘制原图和配色方案。使用 add_prefix(img_path) 方法为新图片路径添加前缀 &quot;color_schema_&quot; 并保存新图片。 :param img_path: 原始图片路径 :return: None &quot;&quot;&quot; # 载入图片的颜色信息 haishoku = Haishoku.loadHaishoku(img_path) with Image.open(img_path) as img: # 获取图片大小，并计算缩放后的大小 width, height = img.size scale_factor = 500 / width new_size = (500, int(height * scale_factor)) img = img.resize(new_size) # 计算配色方案中每行应显示的颜色块数量 colors_num = len(haishoku.palette) if colors_num &lt; 5: colors_per_row = colors_num else: colors_per_row = 5 # 计算每个颜色块的宽度和高度 color_block_width = 500 // colors_per_row color_block_height = 40 # 新建一张白色背景的图片 new_img = Image.new(&#x27;RGB&#x27;, (img.width, img.height + color_block_height + 20), (255, 255, 255)) # 将原始图片贴到新图片顶部 new_img.paste(img, (0, 0)) # 获取配色方案 colors = haishoku.palette[:colors_num] # 绘制矩形块表示颜色，并添加颜色名称 palette_size = (500, int(len(colors) / colors_per_row) * color_block_height + 60) colors_img = Image.new(&#x27;RGB&#x27;, palette_size, (255, 255, 255)) draw_colors = ImageDraw.Draw(colors_img) for i, color in enumerate(colors): # 绘制色块 x = i % colors_per_row * color_block_width y = i // colors_per_row * color_block_height draw_colors.rectangle((x, y, x + color_block_width, y + color_block_height), fill=tuple(color[1])) # 写上十六进制颜色值 draw_colors.text((x + color_block_width // 2, y + color_block_height // 2), f&quot;#&#123;color[1][0]:02x&#125;&#123;color[1][1]:02x&#125;&#123;color[1][2]:02x&#125;&quot;.upper(), anchor=&#x27;mm&#x27;, fill=(235, 235, 235)) # 在新图片上绘制原图和配色方案 new_img = Image.new(&#x27;RGB&#x27;, (500, new_size[1] + palette_size[1] + 20), (255, 255, 255)) new_img.paste(img, (0, 0)) new_img.paste(colors_img, (0, new_size[1] + 20)) # 保存新图片 new_img.save(add_prefix(img_path))def add_prefix(file_path): &quot;&quot;&quot; 为文件路径添加前缀 &quot;color_schema_&quot; :param file_path: 原始文件路径，包含目录路径、文件名和扩展名 :return: 添加前缀后的新文件路径 &quot;&quot;&quot; # 分离出目录路径、文件名和扩展名 dir_path, file_name = os.path.split(file_path) name, ext = os.path.splitext(file_name) # 在文件名前加上 &quot;color_schema_&quot; 前缀 new_name = &quot;color_schema_&quot; + name # 重新拼接路径、文件名和扩展名 new_path = os.path.join(dir_path, new_name + ext) return new_pathif __name__ == &#x27;__main__&#x27;: get_color_schema(&#x27;img/img1.png&#x27;) get_color_schema(&#x27;img/img2.png&#x27;) get_color_schema(&#x27;img/img3.png&#x27;) 除去注释，核心代码大概在 40 行左右，整个类库使用非常方便。通过这篇文章的分享，相信大家对于 Haishoku 工具有了更深入的了解，并且也可以从中学到一些有用的编程技巧和实践经验 参考 Haishoku Github中文文档","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"},{"name":"Haishoku","slug":"Haishoku","permalink":"http://blog.heyb.top/tags/Haishoku/"},{"name":"配色方案","slug":"配色方案","permalink":"http://blog.heyb.top/tags/%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/"}]},{"title":"「Python」Python将PDF转Word","slug":"技术/python/「Python」Python将PDF转Word","date":"2023-02-05T09:01:27.000Z","updated":"2023-04-03T15:14:15.551Z","comments":true,"path":"2023/02/05/python-convert-pdf-to-word.html","link":"","permalink":"http://blog.heyb.top/2023/02/05/python-convert-pdf-to-word.html","excerpt":"","text":"背景 PDF 作为一种电子文档，对于阅读和查看是很方便的，但先要编辑却很麻烦。因此将 PDF 转换为可编辑的 Word 文档就变得尤为重要。 通过 Python 的 PDF2Docx 可以比较轻松的做到这点。具体的思路是通过文档元素和内容解析： 基于 PyMuPDF 提取文本、图片、矢量等原始数据 基于规则解析章节、段落、表格、图片、文本等布局及样式 基于 python-docx 创建Word文档 当然也有基于机器学习/计算机视觉方法训练模型（尤其是针对扫描的PDF文档）的，在这里暂不扩展。 特点 简单易用：PDF2DOCX 库提供了简洁明了的函数和接口，方便用户快速上手。 快速高效：该库采用高效的算法和技术，实现了在较短时间内完成 PDF 到 DOCX 的转换。 无损转换：在保持文件结构和布局完整的同时，将 PDF 转换为 DOCX，尽量减少转换过程中可能出现的失真或遗漏。 跨平台：支持 Windows，Mac 和 Linux 等多种操作系统，为用户提供全方位的支持。 限制 目前暂不支持扫描PDF文字识别 仅支持从左向右书写的语言（因此不支持阿拉伯语） 不支持旋转的文字 基于规则的解析无法保证100%还原PDF样式 使用方法 安装依赖项： 1pip install pdf2docx 转换 PDF 到 DOCX 12345678910from pdf2docx import Converter# 创建转换器对象converter = Converter(&#x27;path/to/input.pdf&#x27;)# 转换 PDF 到 DOCXconverter.convert(&#x27;path/to/output.docx&#x27;, start=1, end=None)# 关闭转换器converter.close() 其中，start 和 end 参数可以用于指定转换的开始和结束页码，默认为全部转换。 注意：由于PDF文档中的元素位置可能会因为解析引擎不同而有所偏差，因此建议在导出Word文档后再进行必要的手动调整。 除了基本的转换功能之外，pdf2docx 还提供了一些其他的功能来方便用户进行更高级的操作。 解析 PDF 内容 pdf2docx 可以将 PDF 中的不同元素（如文本、表格、图片）解析为 Python 对象，以便进一步分析和处理。 1234567891011121314151617pythonCopy Codefrom pdf2docx import Parser# 创建解析器对象parser = Parser(&#x27;path/to/input.pdf&#x27;)# 解析 PDF 内容pages = parser.parse()# 遍历每一页的内容for page in pages: # 遍历页面中的所有元素 for element in page.elements: # 处理元素 pass# 关闭解析器parser.close() 其中，pages 是一个包含所有页面对象的列表，每个页面对象都包含了该页面中所有的元素。 每个元素可以是以下类型之一： TextElement: 表示纯文本。 ImageElement: 表示图片。 TableElement: 表示表格。 每个元素都具有一些属性，例如位置、大小、样式等，可以用于进一步处理。 自定义样式 用户可以通过创建自定义样式对象来修改生成的 Word 文档的样式。 12345678910111213141516171819pythonCopy Codefrom pdf2docx.styles import ParagraphStyle, RunStyle# 创建段落样式my_para_style = ParagraphStyle(&#x27;MyParaStyle&#x27;)my_para_style.font.name = &#x27;Calibri&#x27;my_para_style.font.size = 12my_para_style.font.bold = True# 创建文本样式my_run_style = RunStyle(&#x27;MyRunStyle&#x27;)my_run_style.font.color.rgb = (255, 0, 0)# 在段落样式中使用文本样式my_para_style.run_style = my_run_style# 使用自定义样式进行转换converter = Converter(&#x27;path/to/input.pdf&#x27;, para_style=my_para_style)converter.convert(&#x27;path/to/output.docx&#x27;)converter.close() 在上面的示例中，创建了一个名为 MyParaStyle 的自定义段落样式，并将字体设置为 Calibri、字号设置为 12、加粗。然后又创建了一个名为 MyRunStyle 的自定义文本样式，并将字体颜色设置为红色。最后，在段落样式中使用了该文本样式。 当转换 PDF 到 DOCX 时，指定了 para_style=my_para_style 参数，即使用了上述创建的自定义样式。 多进程转换 pdf2docx 支持多进程转换，可以提高转换速度。 12345678910pythonCopy Codefrom pdf2docx import MultiConverter# 创建多进程转换器对象mconverter = MultiConverter(&#x27;path/to/input.pdf&#x27;, num_processes=4)# 转换 PDF 到 DOCXmconverter.convert(&#x27;path/to/output.docx&#x27;)# 关闭转换器mconverter.close() 在上面的示例中，创建了一个名为 MultiConverter 的多进程转换器对象，并将 num_processes 参数设置为 4，表示同时使用 4 个进程进行转换。 注意：使用多进程转换时，请确保您的计算机具有足够的 CPU 和内存资源，以避免出现不必要的问题。 实际运用 下面是一段使用第三方库pdf2docx实现pdf转docx的代码。 该代码将pdf文件「英语4000单词本.pdf」转换成docx文件 wordBook.docx 1234567891011121314from pdf2docx import Converter# 安装类库 pip install pdf2docx# DPF文件路径pdf_file = &#x27;英语4000单词本.pdf&#x27;# 输出Docx文件路径docx_file = &#x27;wordBook.docx&#x27;# 实例化cv = Converter(pdf_file)# 执行转换cv.convert(docx_file, start=0, end=None, multiprocessing=True)# 关闭cv.close() convert 函数的 start 和 end 参数代表需要转换的pdf页数的起始和结束位置，也可以通过pages指定不连续的页面，例如pages=[1,3,5]。 multiprocessing 参数代表是否启用多进程进行转换，如果设置为True则会使用多个进程进行转换 通过上面 5 行代码我们就可以进行将PDF转换为WORD文件了，也可以直接通过命令行来执行： 1pdf2docx convert 批地艾抚.pdf 沃的.docx 同理可以通过--start、--end或者--pages指定页面范围。 参考 pdf2docx：Python实现PDF转Word","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"},{"name":"Word","slug":"Word","permalink":"http://blog.heyb.top/tags/Word/"}]},{"title":"「Python」requirement 依赖管理.md","slug":"技术/python/「Python」requirement 依赖管理","date":"2023-01-08T04:33:00.000Z","updated":"2023-04-04T09:00:22.908Z","comments":true,"path":"2023/01/08/python-requirement-dependency-management.-md.html","link":"","permalink":"http://blog.heyb.top/2023/01/08/python-requirement-dependency-management.-md.html","excerpt":"","text":"背景 Python 的 requirement.txt 文件是一种常用的依赖管理方式，可以很方便地记录和管理项目所需的 Python 包及其版本。在开发和部署 Python 项目时，使用 requirement.txt 文件可以帮助我们轻松地安装和更新依赖，提高项目的稳定性和可维护性。 本文将介绍如何生成 Python 的 requirement.txt 文件，并说明它的主要作用和使用方法。 介绍 Python 的 requirement.txt 文件是一种文本文件，通常包含了项目所需要的 Python 包及其版本信息。这些信息可以由 pip 工具自动生成，也可以手动编写。一个典型的 requirement.txt 文件如下所示： 1234复制代码numpy==1.19.1pandas==1.0.5matplotlib==3.2.2scikit-learn==0.23.1 在这个例子中，每一行都记录了一个 Python 包及其版本信息，用等号连接包名和版本号，中间没有空格。这些信息可以让 pip 工具自动下载和安装指定版本的包，从而满足项目的依赖关系。 作用 Python 的 requirement.txt 文件具有如下作用： 记录项目的依赖关系。通过 requirement.txt 文件，我们可以清楚地了解项目所需要的 Python 包及其版本信息，方便我们管理和维护项目。 方便部署和安装。在部署和运行项目时，只需要简单地执行 pip install -r requirements.txt 命令，即可自动安装和更新所有需要的 Python 包，减少了手动下载和安装依赖的工作量。 提高项目的稳定性和可维护性。通过 requirement.txt 文件，我们可以保证项目的依赖关系是清晰和明确的，并且不受其他因素（如开发环境、操作系统等）的影响。这有助于提高项目的稳定性和可维护性。 生成 在日常开发和维护 Python 项目时，我们通常需要生成 requirement.txt 文件来记录项目的依赖关系。有以下两种方法可以生成 requirement.txt 文件： 使用 pip freeze 命令 pip 是 Python 的包管理工具，经常被用来安装和更新 Python 包。pip freeze 命令可以列出当前环境中已安装的所有 Python 包及其版本信息，将它们输出到屏幕上或者保存到文件中。我们可以使用以下命令生成 requirement.txt 文件： 1pip freeze &gt; requirements.txt 这个命令会将当前环境中所有已安装的 Python 包及其版本信息，保存到当前目录下的 requirements.txt 文件中。如果当前环境中没有安装任何 Python 包，则生成的文件会是空的。 手动编辑 requirements.txt 文件 如果您需要手动管理项目的依赖关系，也可以手动编写 requirements.txt 文件。您可以在 requirements.txt 文件中按照前面提到的格式，逐行记录需要的 Python 包和版本信息。例如： 1234复制代码numpy==1.19.1pandas==1.0.5matplotlib==3.2.2scikit-learn==0.23.1 在编写完 requirements.txt 文件后，可以使用以下命令安装指定版本的 Python 包： 1复制代码pip install -r requirements.txt PyCharm 生成 PyCharm 是一款强大的 Python IDE，它提供了方便的方式来生成 requirement.txt 文件。下面是使用 PyCharm 生成 requirement.txt 文件的步骤： 打开 PyCharm，并打开您的项目。 在主菜单中选择 Tools &gt; Sync Python Requirements… 选择生成路径和配置，点击OK之后，选择的根目录会有会文件产生。这个文件里的依赖包要准确的多。 另外，如果想在终端中使用 pip freeze 命令来生成 requirements.txt 文件，也可以在 PyCharm 中使用 Terminal 工具来执行该命令。只需要在主菜单中选择 “View” -&gt; “Tool Windows” -&gt; “Terminal”，然后在终端中输入以下命令即可生成 requirements.txt 文件： 1pip freeze &gt; requirements.txt 使用 PyCharm 来生成 requirements.txt 文件非常方便，可以极大地提高项目的管理和维护效率。 使用 在开发和维护 Python 项目时，使用 requirement.txt 文件是一个好习惯。您可以按照下面的步骤来使用 requirement.txt 文件： 创建或更新 requirements.txt 文件。可以使用 pip freeze 命令或手动编写文件的方式来创建或更新 requirements.txt 文件。 将 requirements.txt 文件提交到版本控制系统。建议将 requirements.txt 文件提交到同样的版本控制系统中，以便其他开发者或管理员可以看到项目的依赖关系。 安装或更新依赖。在部署或运行项目时，可以使用 pip install -r requirements.txt 命令安装或更新所有需要的 Python 包。建议在虚拟环境中进行操作，避免与其他项目产生干扰。 综上所述，Python 的 requirement.txt 文件是一个方便管理和维护项目依赖关系的工具。无论是在开发、测试还是部署环节，都可以帮助我们减少工作量，提高项目的稳定性和可维护性。如果您还没有使用 requirement.txt 文件来管理 Python 项目的依赖关系，不妨尝试一下。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"}]},{"title":"「OCR」paddleOCR","slug":"技术/其他/「OCR」paddleOCR","date":"2023-01-06T08:57:00.000Z","updated":"2023-04-04T08:25:25.065Z","comments":true,"path":"2023/01/06/ocr-paddleocr.html","link":"","permalink":"http://blog.heyb.top/2023/01/06/ocr-paddleocr.html","excerpt":"","text":"背景 paddleOCR 是百度基于 PaddlePaddle 开发的一款开源 OCR（Optical Character Recognition 光学字符识别） 工具集，旨在提供高精度、高效率的文字识别和文本检测服务，支持包括中英文在内的多种语言。本文将介绍 PaddleOCR 的主要特点和使用方法。 网站 官网： https://www.paddlepaddle.org.cn/ Github： https://github.com/PaddlePaddle/PaddleOCR 特点 高精度识别：PaddleOCR 提供多种预训练模型，可以处理各种不同类型的文档和图片，包括通用场景、特定行业领域、手写体等。它还支持 FineTune 模式，可以让用户自行训练模型以适应特定场景的需求。 多种文本检测算法：PaddleOCR 支持 EAST、DB、SAST、PSENet 等多种文本检测算法，可以适应不同类型的文档和图片，并提供多种参数配置和优化选项，以满足不同场景的需求。 多种输出格式：PaddleOCR 支持输出多种格式的识别结果，包括 bbox、quad、mask 等，可以方便地进行后续处理和分析。 快速和高效：PaddleOCR 基于 PaddlePaddle 深度学习框架，提供了高效、可扩展的计算能力，在保证识别精度的同时，也可以快速地处理大量数据。 使用 PaddleOCR 的使用方法非常简单，只需要三步即可完成文本识别和检测任务： 安装 PaddleOCR：可以通过 pip 或源码编译的方式安装 PaddleOCR。具体的安装方法可以参考 PaddleOCR 的官方文档。 加载模型：PaddleOCR 提供多个预训练模型可供选择，包括通用场景 OCR、身份证 OCR、车牌 OCR 等。可以使用 PaddleOCR 的 API 加载所需的模型。 进行文本识别和检测：加载模型后，就可以调用相应的 API 对文本进行识别和检测了。 安装 paddlepaddle 1pip install paddlepaddle -i https://pypi.tuna.tsinghua.edu.cn/simple\\ 安装PaddleOCR whl包 1pip install &quot;paddleocr&gt;=2.0.1&quot; # 推荐使用2.0.1+版本 图片 在图片目录中使用命令行执行识别： 1paddleocr --image_dir ./imgs/示例图片.jpg --use_angle_cls true --use_gpu false 检测+方向分类器+识别全流程：--use_angle_cls true设置使用方向分类器识别180度旋转文字，--use_gpu false设置不使用GPU PDF 1paddleocr --image_dir ./xxx.pdf --use_angle_cls true --use_gpu false --page_num 2 可以通过指定参数page_num来控制推理前面几页，默认为0，表示推理所有页。 如需新增自己训练的模型，可以在paddleocr中增加模型链接和字段，重新编译即可。 更多whl包使用可参考whl包文档 多语言 1paddleocr --image_dir ./imgs_en/254.jpg --lang=en PaddleOCR目前支持80个语种，可以通过修改--lang参数进行切换，对于英文模型，指定--lang=en。 常用的多语言简写包括 语种 缩写 语种 缩写 语种 缩写 中文 ch 法文 fr 日文 japan 英文 en 德文 german 韩文 korean 繁体中文 chinese_cht 意大利文 it 俄罗斯文 ru 全部语种及其对应的缩写列表可查看多语言模型教程 Python 入门 可以使用以下 Python 代码来进行通用 OCR 识别： 12345import paddleocrocr = paddleocr.OCR()result = ocr.ocr(&#x27;image.jpg&#x27;)for line in result: print(line) 以上代码将加载通用 OCR 模型，并对名为 image.jpg 的图片进行识别。识别结果将以列表形式返回，每个元素表示一行文字。 图片 检测+方向分类器+识别全流程 1234567891011121314151617181920212223from paddleocr import PaddleOCR, draw_ocr# Paddleocr目前支持的多语言语种可以通过修改lang参数进行切换# 例如`ch`, `en`, `fr`, `german`, `korean`, `japan`ocr = PaddleOCR(use_angle_cls=True, lang=&quot;ch&quot;) # need to run only once to download and load model into memoryimg_path = &#x27;./imgs/11.jpg&#x27;result = ocr.ocr(img_path, cls=True)for idx in range(len(result)): res = result[idx] for line in res: print(line)# 显示结果# 如果本地没有simfang.ttf，可以在doc/fonts目录下下载from PIL import Imageresult = result[0]image = Image.open(img_path).convert(&#x27;RGB&#x27;)boxes = [line[0] for line in result]txts = [line[1][0] for line in result]scores = [line[1][1] for line in result]im_show = draw_ocr(image, boxes, txts, scores, font_path=&#x27;doc/fonts/simfang.ttf&#x27;)im_show = Image.fromarray(im_show)im_show.save(&#x27;result.jpg&#x27;) 可以将这个方法包装成函数，提供给接口调用，返回 res 结果 123456789101112from paddleocr import PaddleOCRdef read(filePath): # Paddleocr目前支持的多语言语种可以通过修改lang参数进行切换 # 例如`ch`, `en`, `fr`, `german`, `korean`, `japan` ocr = PaddleOCR(use_angle_cls=True, lang=&quot;ch&quot;) # need to run only once to download and load model into memory img_path = filePath result = ocr.ocr(img_path, cls=True) res = [] for idx in range(len(result)): res = result[idx] return res PDF 123456789101112131415161718192021222324252627282930313233343536373839from paddleocr import PaddleOCR, draw_ocr# Paddleocr目前支持的多语言语种可以通过修改lang参数进行切换# 例如`ch`, `en`, `fr`, `german`, `korean`, `japan`ocr = PaddleOCR(use_angle_cls=True, lang=&quot;ch&quot;, page_num=2) # need to run only once to download and load model into memoryimg_path = &#x27;./xxx.pdf&#x27;result = ocr.ocr(img_path, cls=True)for idx in range(len(result)): res = result[idx] for line in res: print(line)# 显示结果import fitzfrom PIL import Imageimport cv2import numpy as npimgs = []with fitz.open(img_path) as pdf: for pg in range(0, pdf.pageCount): page = pdf[pg] mat = fitz.Matrix(2, 2) pm = page.getPixmap(matrix=mat, alpha=False) # if width or height &gt; 2000 pixels, don&#x27;t enlarge the image if pm.width &gt; 2000 or pm.height &gt; 2000: pm = page.getPixmap(matrix=fitz.Matrix(1, 1), alpha=False) img = Image.frombytes(&quot;RGB&quot;, [pm.width, pm.height], pm.samples) img = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR) imgs.append(img)for idx in range(len(result)): res = result[idx] image = imgs[idx] boxes = [line[0] for line in res] txts = [line[1][0] for line in res] scores = [line[1][1] for line in res] im_show = draw_ocr(image, boxes, txts, scores, font_path=&#x27;doc/fonts/simfang.ttf&#x27;) im_show = Image.fromarray(im_show) im_show.save(&#x27;result_page_&#123;&#125;.jpg&#x27;.format(idx)) 其他 稳定版本：python 3.7.9，numpy 要指定安装 1.19.3 及以下版本 1pip install numpy==1.19.3 提示 ModuleNotFoundError: No module named 'common' 异常 123456789import common, dual, tight, data, prox ModuleNotFoundError: No module named &#x27;common&#x27; [end of output] note: This error originates from a subprocess, and is likely not a problem with pip.error: metadata-generation-failed× Encountered error while generating package metadata.╰─&gt; See above for output. 需要安装common、dual、tight、data、prox模块： 12345pip install common -i https://pypi.tuna.tsinghua.edu.cn/simplepip install dual -i https://pypi.tuna.tsinghua.edu.cn/simplepip install tight -i https://pypi.tuna.tsinghua.edu.cn/simplepip install data -i https://pypi.tuna.tsinghua.edu.cn/simplepip install prox -i https://pypi.tuna.tsinghua.edu.cn/simple 提示 ModuleNotFoundError: No module named 'paddle’ 或者 No module named ‘paddle.fluid’ 重新安装依赖包 Image \\ paddleOCR 12pip install Image -i https://pypi.tuna.tsinghua.edu.cn/simplepip install paddleocr -i https://pypi.tuna.tsinghua.edu.cn/simple 总结 PaddleOCR 是一款高精度、高效率的 OCR 工具集，可以适应不同类型的文档和图片，并支持多种输出格式。通过简单的 API 调用就可以进行文本识别和检测，并在实际应用中发挥重要作用。 参考 PaddleOCR 快速开始","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"OCR","slug":"技术/OCR","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/OCR/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"OCR","slug":"OCR","permalink":"http://blog.heyb.top/tags/OCR/"}]},{"title":"「Markdown」Markdown常用数学公式","slug":"写作/markdown/「Markdown」Markdown常用数学公式","date":"2023-01-05T03:39:31.000Z","updated":"2023-01-05T03:39:32.339Z","comments":true,"path":"2023/01/05/markdown-common-formula-of-markdown.html","link":"","permalink":"http://blog.heyb.top/2023/01/05/markdown-common-formula-of-markdown.html","excerpt":"","text":"很多情况下，markdown编辑器都自带Latex的公式解析功能，因此我们可以直接使用Latex公式来展示数学公式的内容。 行内&amp;独行公式 公式 显示效果 语法 示例 行内公式，将公式插入到本行内 x=y+1x = y + 1x=y+1 $ 内容 $ $x=y+1$ 独行公式，将公式插入到新的一行内，并且居中 $$x=y+1$$ $$ 内容 $$ $$x=y+1$$ 行内公式显示效果： $ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ 示例： 1$ J_\\alpha(x) = \\sum_&#123;m=0&#125;^\\infty \\frac&#123;(-1)^m&#125;&#123;m! \\Gamma (m + \\alpha + 1)&#125; &#123;\\left(&#123; \\frac&#123;x&#125;&#123;2&#125; &#125;\\right)&#125;^&#123;2m + \\alpha&#125; \\text &#123;，行内公式示例&#125; $ 独行公式显示效果： x=y+1x=y+1 x=y+1 示例： 123$$x=y+1$$ 角标（上下标等） 公式/符号 显示效果 语法 示例 上标符号 xmx^mx​m​​ ^ $x^m$ 下标符号 x1x_1x​1​​ _ $x_1$ 组合符号 xmnx_{mn}x​mn​​ { } $x_{mn}$ 左右上下标 $ \\sideset{1_2}{3_4}\\bigotimes $ \\sideset{^左上标_左下标}{^右上标_右下标} $ \\sideset{1_2}{3_4}\\bigotimes $ 汉字与格式 公式/符号 显示效果 语法 示例 汉字形式 V_{\\mbox{初始}} \\mbox{} $V_{\\mbox{初始}}$ 普通 x+yy+z\\frac{x+y}{y+z}​y+z​​x+y​​ $\\frac{x+y}{y+z}$ 字体控制 x+yy+z\\displaystyle \\frac{x+y}{y+z}​y+z​​x+y​​ \\displaystyle $\\displaystyle \\frac{x+y}{y+z}$ 下划线 x+y‾\\underline {x+y}​​x+y​​ \\underline $\\underline {x+y}$ 上大括号 \\overbrace{a+b+c+d}^{2.0} \\overbrace{算式} $\\overbrace{a+b+c+d}^{2.0}$ 下大括号 a+\\underbrace{b+c}_{1.0}+d \\underbrace{算式} $a+\\underbrace{b+c}_{1.0}+d$ 上位符号 \\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n} \\stackrel{上位符号}{基位符号} $\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}$ 标签，语法：算式 \\tag{数字}，显示效果如下： x+y \\tag{10} 占位符 公式/符号 显示效果 语法 示例 正常 xyxyxy $xy$ 紧贴 xyx\\!yxy \\! $x!y$ 小空格 xyx\\,yxy \\, $x,y$ 中空格 xyx \\: yxy \\: $x:y$ 大空格 x yx \\ yx y \\ $x \\ y$ quad空格 xyx\\quad yxy \\quad $x\\quad y$ 两个quad空格 xyx\\qquad yxy \\qquad $x\\qquad y$ 定界符与组合 公式/符号 显示效果 语法 示例 括号 (x)y(x)y(x)y () $(x)y$ 中-括号 (x)y\\big(x \\big) y(x)y \\big( \\big) 其他符号以此类推 $\\big(x \\big) y$ 大-括号 (x)y\\Big(x \\Big) y(x)y \\Big( \\Big) 其他符号以此类推 $\\Big(x \\Big) y$ 加大-括号 (x)y\\bigg(x \\bigg)y(x)y \\bigg( \\bigg) 其他符号以此类推 $\\bigg(x \\bigg)y$ 特大-括号 (x)y\\Bigg( x \\Bigg) y(x)y \\Bigg( \\Bigg) 其他符号以此类推 $\\Bigg( x \\Bigg) y$ 中括号 [x]y[x]y[x]y [] $[x]y$ 大括号 {x}+y\\{x\\}+y{x}+y \\{ \\} ${x}+y$ 自适应括号 $\\left( x \\right) y $ \\left( \\right) $\\left( x \\right) y $ 括号组合公式 (n+1k)=(nk)+(nk−1){n+1 \\choose k} = {n \\choose k} + {n \\choose k-1}(​k​n+1​​)=(​k​n​​)+(​k−1​n​​) {上位公式 \\choose 下位公式} ${n+1 \\choose k} = {n \\choose k} + {n \\choose k-1}$ 组合公式 ${\\sum_{k_0, K-1,\\ldots&gt;0 \\atop k_0+k_1+\\cdots=n} A_{k_0} A_{k_1} \\cdots} $ {上位公式 \\atop 下位公式} ${\\sum_{k_0, K-1,\\ldots&gt;0 \\atop k_0+k_1+\\cdots=n} A_{k_0} A_{k_1} \\cdots} $ 括号组合公式 (n+1k)=(nk)+(nk−1){n+1 \\choose k} = {n \\choose k} + {n \\choose k-1}(​k​n+1​​)=(​k​n​​)+(​k−1​n​​) {上位公式 \\choose 下位公式} ${n+1 \\choose k} = {n \\choose k} + {n \\choose k-1}$ 分段函数 y:{x+y=1x−y=0y :\\begin{cases} x+y=1\\\\ x-y = 0 \\end{cases}y:{​x+y=1​x−y=0​​ \\begin&#123;cases&#125;和\\end&#123;cases&#125;来构造分段函数，中间则用\\\\来分段 $y :\\begin{cases} x+y=1\\ x-y = 0 \\end{cases}$ 左下角 └\\llcorner└ \\llcorner $\\llcorner$ 右下角 ┘\\lrcorner┘ \\lrcorner $\\lrcorner$ 左上角 ┌\\ulcorner┌ \\ulcorner $\\ulcorner$ 右上角 ┐\\urcorner┐ \\urcorner $\\urcorner$ 四则运算 公式/符号 显示效果 语法 示例 加法运算 x+y=zx+y=zx+y=z + $x+y=z$ 减法运算 x−y=zx - y = zx−y=z - $x - y = z$ 加减运算 x±y=zx \\pm y=zx±y=z \\pm $x \\pm y=z$ 减加运算 x∓y=zx \\mp y=zx∓y=z \\mp $x \\mp y=z$ 乘法运算 x×y=zx \\times y=zx×y=z \\times $x \\times y=z$ 点乘运算 x⋅y=zx \\cdot y = zx⋅y=z \\cdot $x \\cdot y = z$ 除法运算 x÷y=zx \\div y = zx÷y=z \\div $x \\div y = z$ 斜杠除法运算 x/y=zx / y =zx/y=z / $x / y =z$ 分式表示 xy=z\\frac{x}{y} = z​y​​x​​=z \\frac{分子}{分母} $\\frac{x}{y} = z$ 分式表示 xyz{x}\\over{y} z​yz​​x​​ {分子} \\voer {分母} ${x}\\over{y} z$ 绝对值表示 $ x+y $ 高级运算 公式/符号 显示效果 语法 示例 平均数运算 xyz‾\\overline{xyz}​xyz​​​ \\overline $\\overline{xyz}$ 开平方运算 x\\sqrt x√​x​​​ \\sqrt $\\sqrt x$ 开方（根式）运算 x+y5\\sqrt[5]{x+y}​5​​√​x+y​​​ \\sqrt[开方数]{被开放数} x+y5\\sqrt[5]{x+y}​5​​√​x+y​​​ 对数运算 log(x)\\log(x)log(x) \\log $\\log(x)$ 对数符号 ln\\lnln \\ln $\\ln$ 对数符号 lg\\lglg \\lg $\\lg$ 极限运算 limy→0x→∞xy\\lim^{x \\to \\infty}_{y \\to 0} {\\frac{x}{y}}lim​y→0​x→∞​​​y​​x​​ \\lim $\\lim^{x \\to \\infty}_{y \\to 0} {\\frac{x}{y}}$ 极限运算 limy→0x→∞xy\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0} {\\frac{x}{y}}​y→0​lim​x→∞​​​y​​x​​ \\displaystyle \\lim $\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0} {\\frac{x}{y}}$ 求和/累加运算 ∑y→0x→∞xy\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}∑​y→0​x→∞​​​y​​x​​ \\sum $\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和/累加运算 ∑y→0x→∞xy\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}​y→0​∑​x→∞​​​y​​x​​ \\displaystyle \\sum $\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 积分运算 ∫−∞01xdx{\\int_{-\\infty}^0\\frac{1}{x}dx}∫​−∞​0​​​x​​1​​dx \\int ${\\int_{-\\infty}^0\\frac{1}{x}dx}$ 积分运算 ∫−∞01xdx{\\displaystyle \\int_{-\\infty}^0\\frac{1}{x}dx}∫​−∞​0​​​x​​1​​dx \\displaystyle \\int ${\\displaystyle \\int_{-\\infty}^0\\frac{1}{x}dx}$ 双重积分运算 ∬\\iint∬ \\iint $\\iint$ 三重积分运算 ∭\\iiint∭ \\iiint $\\iiint$ 求导 y′y\\primey′ \\prime \\prime 曲线积分 ∮\\oint∮ \\oint $\\oint$ 微分运算 ∂x∂y\\frac{\\partial x}{\\partial y}​∂y​​∂x​​ \\partial $\\frac{\\partial x}{\\partial y}$ 求积/累乘运算 ∏i=0n\\prod^n_{i=0}∏​i=0​n​​ \\prod $\\prod^n_{i=0}$ 求商/累除运算 ∐\\coprod∐ \\coprod $\\coprod$ 三角函数 公式/符号 显示效果 语法 示例 垂直 ⊥\\bot⊥ \\bot $\\bot$ 角 ∠\\angle∠ \\angle $\\angle$ 测量 ∡\\measuredangle∡ \\measuredangle $\\measuredangle$ 球面角 ∢\\sphericalangle∢ \\sphericalangle $\\sphericalangle$ 三角 △\\triangle△ \\triangle $\\triangle$ 三角 △\\vartriangle△ \\vartriangle $\\vartriangle$ 黑色三角 ▲\\blacktriangle▲ \\blacktriangle $\\blacktriangle$ 倒三角 ▽\\triangledown▽ \\triangledown $\\triangledown$ 黑色倒三角 ▼\\blacktriangledown▼ \\blacktriangledown $\\blacktriangledown$ 正弦 sin\\sinsin \\sin $\\sin$ 余弦 cos\\coscos \\cos $\\cos$ 正切 tan\\tantan \\tan $\\tan$ 余切 cot\\cotcot \\cot $\\cot$ 正割 sec\\secsec \\sec $\\sec$ 矩阵运算 不带括号矩阵 显示效果 \\begin{matrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{matrix} \\tag{1} 示例 1234567$$ \\begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end&#123;matrix&#125; \\tag&#123;1&#125;$$ 带边框的矩阵 两种方式 a. 替换matrix 在起始、结束标记用下列词替换 matrix pmatrix：小括号边框 bmatrix：中括号边框 Bmatrix：大括号边框 vmatrix：单竖线边框 Vmatrix：双竖线边框 b. 使用left、right 在起始、结束标记外围增加 \\left、\\right标签 \\left(，\\right): 小括号边框 \\left[，\\right]: 中括号边框 \\left{，\\right}: 大括号边框 大括号 显示效果： \\begin{Bmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{Bmatrix} \\tag{1} 示例： 1234567$$\\begin&#123;Bmatrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;Bmatrix&#125; \\tag&#123;1&#125;$$ 或 123456789$$\\left\\&#123;\\begin&#123;matrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;matrix&#125;\\right\\&#125; \\tag&#123;1&#125;$$ 中括号 显示效果： \\left[ \\begin{matrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{matrix} \\right] \\tag{2} 示例： 123456789$$\\left[\\begin&#123;matrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;matrix&#125;\\right] \\tag&#123;2&#125;$$ 或： 1234567$$\\begin&#123;bmatrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;bmatrix&#125; \\tag&#123;2&#125;$$ 小括号 显示效果： \\left( \\begin{matrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{matrix} \\right) \\tag{3} 示例： 123456789$$\\left(\\begin&#123;matrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;matrix&#125;\\right) \\tag&#123;3&#125;$$ 或： 1234567$$\\begin&#123;pmatrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;pmatrix&#125; \\tag&#123;3&#125;$$ 竖线 显示效果： \\left| \\begin{matrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{matrix} \\right| \\tag{4} 示例： 123456789$$\\left|\\begin&#123;matrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;matrix&#125;\\right| \\tag&#123;4&#125;$$ 或 1234567$$\\begin&#123;vmatrix&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;vmatrix&#125; \\tag&#123;4&#125;$$ 省略元素 横省略号：\\cdots 竖省略号：\\vdots 斜省略号：\\ddots 显示效果： \\begin{bmatrix} {a_{11}}&{a_{12}}&{\\cdots}&{a_{1n}}\\\\ {a_{21}}&{a_{22}}&{\\cdots}&{a_{2n}}\\\\ {\\vdots}&{\\vdots}&{\\ddots}&{\\vdots}\\\\ {a_{m1}}&{a_{m2}}&{\\cdots}&{a_{mn}}\\\\ \\end{bmatrix} \\tag{5} 示例： 12345678$$\\begin&#123;bmatrix&#125;&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\\\&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\\\&#123;\\vdots&#125;&amp;&#123;\\vdots&#125;&amp;&#123;\\ddots&#125;&amp;&#123;\\vdots&#125;\\\\&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\\\\\end&#123;bmatrix&#125; \\tag&#123;5&#125;$$ 带参数的矩阵 需要array环境：起始、结束处以{array}声明 对齐方式：在{array}后以{}逐行统一声明 左对齐：l；居中：c；右对齐：r 竖直线：在声明对齐方式时，插入 | 建立竖直线 插入水平线：\\hline 简表 显示效果： \\begin{array}{c|lll} {↓}&{a}&{b}&{c}\\\\ \\hline {R_1}&{c}&{b}&{a}\\\\ {R_2}&{b}&{c}&{c}\\\\ \\end{array} \\tag{6} 示例： 12345678$$\\begin&#123;array&#125;&#123;c|lll&#125;&#123;↓&#125;&amp;&#123;a&#125;&amp;&#123;b&#125;&amp;&#123;c&#125;\\\\\\hline&#123;R_1&#125;&amp;&#123;c&#125;&amp;&#123;b&#125;&amp;&#123;a&#125;\\\\&#123;R_2&#125;&amp;&#123;b&#125;&amp;&#123;c&#125;&amp;&#123;c&#125;\\\\\\end&#123;array&#125; \\tag&#123;6&#125;$$ 强调某列 显示效果： \\left[ \\begin{array}{cc|c} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\end{array} \\right] \\tag{7} 示例： 123456789$$ \\left[\\begin&#123;array&#125;&#123;cc|c&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6\\end&#123;array&#125;\\right] \\tag&#123;7&#125;$$ 方程组 显示效果： \\begin{cases} a_1x+b_1y+c_1z=d_1\\\\ a_2x+b_2y+c_2z=d_2\\\\ a_3x+b_3y+c_3z=d_3\\\\ \\end{cases} \\tag{8} 示例： 1234567$$\\begin&#123;cases&#125;a_1x+b_1y+c_1z=d_1\\\\a_2x+b_2y+c_2z=d_2\\\\a_3x+b_3y+c_3z=d_3\\\\\\end&#123;cases&#125; \\tag&#123;8&#125;$$ 逻辑运算 公式/符号 显示效果 语法 示例 等于 x+y=zx+y=zx+y=z = $x + y = z$ 大于 x+y&gt;zx + y &gt; zx+y&gt;z &gt; $x + y &gt; z$ 小于 x+y&lt;zx + y &lt; zx+y&lt;z &lt; $x + y &lt; z$ 大于等于 x+y≥zx + y \\geq zx+y≥z \\geq $x + y \\geq z$ 小于等于 $ x+y \\leq z$ \\leq $ x+y \\leq z$ 不等于 x+y≠zx+y \\neq zx+y≠z \\neq $x+y \\neq z$ 不大于 等于 x + y \\not\\geq z \\not\\geq 或者 \\ngeq $x + y \\not\\geq z$ 不小于 等于 x+y≰zx + y \\nleq zx+y≰z \\not\\leq 或者 \\nleq $x + y \\nleq z$ 约等于 x+y≈zx+y \\approx zx+y≈z \\approx $x+y \\approx z$ 恒定等于 x+y≡zx + y \\equiv zx+y≡z \\equiv $x + y \\equiv z$ 集合运算 公式/符号 显示效果 语法 示例 属于 $ x \\in y$ \\in $ x \\in y$ 不属于 x∉yx \\notin yx∉y \\not \\in 或 \\notin $x \\notin y$ 子集 $ x \\subset y$ \\subset $ x \\subset y$ 子集 x⊃yx \\supset yx⊃y \\supset $x \\supset y$ 真子集 x⊆yx \\subseteq yx⊆y \\subseteq $x \\subseteq y$ 真子集 x⊇yx \\supseteq yx⊇y \\supseteq $x \\supseteq y$ 非真子集 x⊊yx \\subsetneq yx⊊y \\subsetneq $x \\subsetneq y$ 非真子集 x⊋yx \\supsetneq yx⊋y \\supsetneq $x \\supsetneq y$ 并集 x∪yx \\cup yx∪y \\cup $x \\cup y$ 交集 x∩yx \\cap yx∩y \\cap $x \\cap y$ 差集 x∖sx \\setminus sx∖s \\setminus $x \\setminus s$ 逻辑或 x⋁yx \\bigvee yx⋁y \\bigvee $x \\bigvee y$ 小的逻辑或 x∨yx \\vee yx∨y \\vee $x \\vee y$ 逻辑与 x⋀yx \\bigwedge yx⋀y \\bigwedge $x \\bigwedge y$ 小的逻辑与 x∧yx \\wedge yx∧y \\wedge $x \\wedge y$ x⊔yx \\sqcup yx⊔y \\sqcup $x \\sqcup y$ 同或运算 x⨀yx \\bigodot yx⨀y \\bigodot $x \\bigodot y$ 小的同或运算 x⊙yx \\odot yx⊙y \\odot $x \\odot y$ 同与运算 x⨂yx \\bigotimes yx⨂y \\bigotimes $x \\bigotimes y$ 小的同与运算 x⊗yx \\otimes yx⊗y \\otimes $x \\otimes y$ x⊕yx \\oplus yx⊕y \\oplus $x \\oplus y$ 实数集合 R\\mathbb{R}R \\mathbb{R} $\\mathbb{R}$ 自然数集合 Z\\mathbb{Z}Z \\mathbb{Z} $\\mathbb{Z}$ 空集 $ \\emptyset $ \\emptyset $ \\emptyset $ 数学符号 公式/符号 显示效果 语法 示例 无穷 ∞\\infty∞ \\infty $\\infty$ 虚数 ı\\imathı \\imath $\\imath$ 虚数 ȷ\\jmathȷ \\jmath $\\jmath$ ℓ\\ellℓ \\ell $\\ell$ 帽子符号 a^\\hat{a}​a​^​​ \\hat{算式} $\\hat{a}$ 宽帽子符号 \\widehat{abc} \\widehat{算式} $\\widehat{abc}$ 检查符号 aˇ\\check{a}​a​ˇ​​ \\bar{算式} $\\check{a}$ 短符号 a˘\\breve{a}​a​˘​​ \\breve{算式} $\\breve{a}$ 波浪纹符号 a~\\tilde{a}​a​~​​ \\tilde{算式} $\\tilde{a}$ 宽波浪纹符号 \\widetilde{abc} \\widetilde{算式} $\\widetilde{abc}$ 短杠符号 a¯\\bar{a}​a​¯​​ \\bar{算式} $\\bar{a}$ 向量符号 a⃗\\vec{a}​a​⃗​​ \\vec{算式} $\\vec{a}$ 锐音符 a´\\acute{a}​a​´​​ \\acute{算式} $\\acute{a}$ 沉音符 a`\\grave{a}​a​`​​ \\grave{算式} $\\grave{a}$ 环符号 \\mathring{a} \\mathring{算式} $\\mathring{a}$ 一阶导数 a˙\\dot{a}​a​˙​​ \\dot{算式} $\\dot{a}$ 二阶导数 a¨\\ddot{a}​a​¨​​ \\ddot{算式} $\\ddot{a}$ 上箭头 x↑yx \\uparrow yx↑y \\uparrow $x \\uparrow y$ 双上箭头 x⇑yx \\Uparrow yx⇑y \\Uparrow $x \\Uparrow y$ 下箭头 x↓yx \\downarrow yx↓y \\downarrow $x \\downarrow y$ 双下箭头 x⇓yx \\Downarrow yx⇓y \\Downarrow $x \\Downarrow y$ 左箭头 x←yx \\leftarrow yx←y \\leftarrow $x \\leftarrow y$ 双左箭头 x⇐yx \\Leftarrow yx⇐y \\Leftarrow $x \\Leftarrow y$ 右箭头 x→yx \\rightarrow yx→y \\rightarrow $x \\rightarrow y$ 双右箭头 x⇒yx \\Rightarrow yx⇒y \\Rightarrow $x \\Rightarrow y$ 顶部左箭头 \\overleftarrow{xyz} \\overleftarrow{算式} $\\overleftarrow{xyz}$ 顶部右箭头 \\overrightarrow{xyz} \\overrightarrow{算式} $\\overrightarrow{xyz}$ 底端对其省略号 1,2,…,n1,2,\\ldots,n1,2,…,n \\ldots $1,2,\\ldots,n$ 中线对齐省略号 x11+x22+⋯+xn2x_1^1 + x_2^2 + \\cdots + x_n^2x​1​1​​+x​2​2​​+⋯+x​n​2​​ \\cdots $x_1^1 + x_2^2 + \\cdots + x_n^2$ 竖直对齐省略号 x ⋮ yx \\ \\vdots \\ yx ⋮ y \\vdots $x \\ \\vdots \\ y$ 斜对齐对齐省略号 x⋱yx \\ddots yx⋱y \\ddots $x \\ddots y$ 字体 公式/符号 显示效果 语法 示例 字体 1 ABCabc123\\mathbf{ABCabc123}ABCabc123 \\mathbf{} $\\mathbf{ABCabc123}$ 字体 2 ABCabc123\\mathcal{ABCabc123}ABCabc123 \\mathcal{} $\\mathcal{ABCabc123}$ 字体 3 ABCabc123\\mathfrak{ABCabc123}ABCabc123 \\mathfrak{} $\\mathfrak{ABCabc123}$ 字体 4 ABCabc123\\mathsf{ABCabc123}ABCabc123 \\mathsf{} $\\mathsf{ABCabc123}$ 字体 5 ABCabc123\\mathbb{ABCabc123}ABCabc123 \\mathbb{} $\\mathbb{ABCabc123}$ 其他符号 公式/符号 显示效果 语法 示例 ∇\\nabla∇ \\nabla $\\nabla$ ð\\ethð \\eth $\\eth$ 梅花 ♣\\clubsuit♣ \\clubsuit $\\clubsuit$ 方块 ♢\\diamondsuit♢ \\diamondsuit $\\diamondsuit$ 红桃 ♡\\heartsuit♡ \\heartsuit $\\heartsuit$ 黑桃 ♠\\spadesuit♠ \\spadesuit $\\spadesuit$ ℑ\\Imℑ \\Im $\\Im$ ℜ\\Reℜ \\Re $\\Re$ ∀\\forall∀ \\forall $\\forall$ 存在 ∃\\exists∃ \\exists $\\exists$ 不存在 ∄\\nexists∄ \\nexists $\\nexists$ ∅\\varnothing∅ \\varnothing $\\varnothing$ ♯\\sharp♯ \\sharp $\\sharp$ ♭\\flat♭ \\flat $\\flat$ ♮\\natural♮ \\natural $\\natural$ k\\Bbbkk \\Bbbk $\\Bbbk$ ⋆\\star⋆ \\star $\\star$ ╲\\diagdown╲ \\diagdown $\\diagdown$ ╱\\diagup╱ \\diagup $\\diagup$ ◊\\Diamond◊ \\Diamond $\\Diamond$ Ⅎ\\FinvℲ \\Finv $\\Finv$ ⅁\\Game⅁ \\Game $\\Game$ ℏ\\hbarℏ \\hbar $\\hbar$ ℏ\\hslashℏ \\hslash $\\hslash$ ◊\\lozenge◊ \\lozenge $\\lozenge$ ⧫\\blacklozenge⧫ \\blacklozenge $\\blacklozenge$ ℧\\mho℧ \\mho $\\mho$ □\\square□ \\square $\\square$ ■\\blacksquare■ \\blacksquare $\\blacksquare$ √\\surd√ \\surd $\\surd$ ℘\\wp℘ \\wp $\\wp$ ∁\\complement∁ \\complement $\\complement$ Ⓢ\\circledSⓈ \\circledS $\\circledS$ 希腊字母（大写） 公式/符号 显示效果 语法 示例 阿尔法Alpha \\Alpha \\Alpha $\\Alpha$ 贝塔Beta \\Beta \\Beta $\\Beta$ 伽马Gamma Γ\\GammaΓ \\Gamma $\\Gamma$ 德尔塔Delte Δ\\DeltaΔ \\Delta $\\Delta$ 艾普西隆Epsilon \\Epsilon \\Epsilon $\\Epsilon$ 捷塔Zeta \\Zeta \\Zeta $\\Zeta$ 依塔Eta \\Eta \\Eta $\\Eta$ 西塔Theta Θ\\ThetaΘ \\Theta $\\Theta$ 艾欧塔Iota \\Iota \\Iota $\\Iota$ 卡帕Kappa \\Kappa \\Kappa $\\Kappa$ 让姆达Lambda Λ\\LambdaΛ \\Lambda $\\Lambda$ 谬Mu \\Mu \\Mu $\\Mu$ 纽Nu \\Nu \\Nu $\\Nu$ 克西Xi Ξ\\XiΞ \\Xi $\\Xi$ 奥密克戎Omicron \\Omicron \\Omicron $\\Omicron$ 派Pi Π\\PiΠ \\Pi $\\Pi$ 柔Rho \\Rho \\Rho $\\Rho$ 西格玛Sigma Σ\\SigmaΣ \\Sigma $\\Sigma$ 陶Tau \\Tau \\Tau $\\Tau$ 宇普西龙Upsilon Υ\\UpsilonΥ \\Upsilon $\\Upsilon$ 佛爱Phi Φ\\PhiΦ \\Phi $\\Phi$ 西Chi \\Chi \\Chi $\\Chi$ 普西Psi Ψ\\PsiΨ \\Psi $\\Psi$ 欧米伽Omega Ω\\OmegaΩ \\Omega $\\Omega$ 希腊字母（小写） 公式/符号 显示效果 语法 示例 Alpha α\\alphaα \\alpha $\\alpha$ Beta β\\betaβ \\beta $\\beta$ Gamma γ\\gammaγ \\gamma $\\gamma$ Delte δ\\deltaδ \\delta $\\delta$ Epsilon ϵ\\epsilonϵ \\epsilon $\\epsilon$ Zeta ζ\\zetaζ \\zeta $\\zeta$ Eta η\\etaη \\eta $\\eta$ Theta θ\\thetaθ \\theta $\\theta$ Iota ι\\iotaι \\iota $\\iota$ Kappa κ\\kappaκ \\kappa $\\kappa$ Lambda λ\\lambdaλ \\lambda $\\lambda$ Mu μ\\muμ \\mu $\\mu$ Nu ν\\nuν \\nu $\\nu$ Xi ξ\\xiξ \\xi $\\xi$ Omicron o\\omicrono \\omicron $\\omicron$ Pi π\\piπ \\pi $\\pi$ Rho ρ\\rhoρ \\rho $\\rho$ Sigma σ\\sigmaσ \\sigma $\\sigma$ Tau τ\\tauτ \\tau $\\tau$ Upsilon υ\\upsilonυ \\upsilon $\\upsilon$ Phi ϕ\\phiϕ \\phi $\\phi$ Chi χ\\chiχ \\chi $\\chi$ Psi ψ\\psiψ \\psi $\\psi$ Omega ω\\omegaω \\omega $\\omega$ 注： 有一些大写的希腊字母 其写法与相应的拉丁字母相同或十分相似，因而不会被使用，例如：A、B、E、Z、H、I、K、M、N、O、P、T、Y、X。除此之外，由于小写的 ι（iota），ο（omicron）和 υ（upsilon）跟拉丁字母中的 i、o 和 u 很相似，所以也很少被使用。 部分字母有变量专用形式，以 \\var 开头，如 epsilon - ε\\varepsilonε - \\varepsilon；theta - ϑ\\varthetaϑ - \\vartheta；rho- ϱ\\varrhoϱ -\\varrho； sigma - $\\varsigma $ - \\varsigma；phi - φ\\varphiφ -\\varphi 参考 studocu latex-sybols-pdf Markdown常用数学公式 lshort – A short introduction to LATEX 2e Markdown写矩阵 百度百科-希腊字母","categories":[{"name":"写作","slug":"写作","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/"},{"name":"Markdown","slug":"写作/Markdown","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://blog.heyb.top/tags/Markdown/"},{"name":"数学","slug":"数学","permalink":"http://blog.heyb.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"2022年总结","slug":"个人/2022年总结","date":"2022-12-31T15:59:59.000Z","updated":"2022-12-31T16:03:24.453Z","comments":true,"path":"2022/12/31/2022-summary.html","link":"","permalink":"http://blog.heyb.top/2022/12/31/2022-summary.html","excerpt":"","text":"在一声声咳嗽中，就要迎来了新的一年。 我以为不出门我可以苟进新冠决赛圈，没想到在却是在冬至的时候发了烧，一连着圣诞节都睡了过去。 这一年所拥有、失去、遗憾、成长。以前总希望时间能够过得快些，希望自己快点长大，现在却总想着能够慢一些，好多事情都似乎没来得及做，却已经结结实实地完结了一年。 学习 今年在技术上进展缓慢，工作中用到的框架并不是主流的，多是做配置文件串联API 的工作，多是基于 MuleSoft 框架做的，现在也逐渐向 Springboot 迁移。所以更多学习的重心还是放在业余自学上。 今年就着个项目倒腾了一下vue3、typeScript和vite ，不得不说，换了vite之后，速度是真的快，调试服务和打包的速度都比用webpack快了太多了。同一项目下调试从平均需要 35-40 秒缩短到了 2 秒左右，对于开发的体验来说真的太舒服了。 此外今年主要学习的新语言是 go，对比Java来说，我感觉更轻便更灵活，学习了一些基础语法之后就可以上手开发一个应用。感觉可以适用于一些更中小型的应用如文件系统，小工具等。新的一年我期望会投入go的精力会更多一些，同时也希望能在容器化的内容多学习一些。期望能够持续地构建自己的知识框架，形成一些可复用的、较优的、结构化的方法论，避免遇到同样的问题不断重复的踩坑。 感情 今年的身份又多了一层，变成了从柳小姐的男朋友转变成了柳小姐的丈夫，和别人介绍的时候还没适应过来，还是「这是我的男/女朋友」，只是我们的关系更安定了一些。小环说，我跟她在一起之后似乎没有失眠过了，都是一躺下没多久就开始打呼噜了。想想我们的关系的确变得更「简单」了，有什么事情都可以直接和对方坦诚布公。在这段感情中我学习到了很多，开始以长远关系和长期价值去思考婚姻和家庭，争取从一个不错的男朋友成为一个优秀的丈夫。新的一年也期待能够再加一层身份，能够带着一个迷你的小环。 其他 今年的时间多了，听的歌反而比去年少了很多（可能是因为在路上交通的时间少了），这里推荐三首我经常听的歌给大家：Bahamas - All The Time，JVKE - golden hour，伍佰 - 泪桥。 总觉得没有听到很抓耳的歌，刷了B站的 00-09 年百大华语金曲感慨以前的歌还是能打，也很庆幸自己经历过华语乐坛群星璀璨的年代。 今年和小环一起看了 55 部电影电视剧（加上我没跟她一起看的估计有 60+了） 大多时候我们都是刷了一些老剧，比较高分的有： 电影：无名之辈、我不是药神、Hello 树先生、让子弹飞、夏洛特烦恼，看不见的客人。 电视剧：庆余年、琅琊榜、国王:永远的君主、甄嬛传、寻秦记。 动漫：罗小黑、罗小黑战记。 这里我就不再做推荐了。 新的剧集有梦华录、风吹半夏，电影隐入尘烟都是今年值得一看的。 隐入尘烟看完，总感觉一口气郁结在心头，长叹一口气却也不能纾解。不由想起史铁生说的：“其实每时每刻我们都是幸运的，因为任何灾难的前面，都可能再加一个“更”字。” 最后 当下总是最好的时候，纵然有许多事情，我们唯有接受，努力，好好生活。 新的一年期望大家身体健康，平安喜乐，万事顺意。","categories":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/tags/%E4%B8%AA%E4%BA%BA/"}]},{"title":"「Docker」Docker 系列文章2 - Dockerfile","slug":"技术/容器/docker/「Docker」Docker 系列文章2 - Dockerfile","date":"2022-12-15T15:35:33.000Z","updated":"2022-12-25T14:32:51.782Z","comments":true,"path":"2022/12/15/docker-docker-series-2---dockerfile.html","link":"","permalink":"http://blog.heyb.top/2022/12/15/docker-docker-series-2---dockerfile.html","excerpt":"","text":"简介 Dockerfile是一个文本文件，其中包含创建 Docker 镜像所需的步骤和指令。主要分为基础镜像信息、维护者信息、镜像操作指令和容器启动时指令四个部分，并支持以 # 开头的注释行。这些指令告诉 Docker 如何设置应用程序的运行环境，通常包括安装软件包、复制文件和设置环境变量的命令。 用户可以使用 Dockerfile 与 docker build 命令一起使用，用于创建 Docker 自定义镜像，然后可以用该镜像创建 Docker 容器。 构建镜像 例如，假设我们想要创建一个基于 go-gin 的应用程序，并使用 Docker 运行它。可以使用 Dockerfile 来指定应用程序所需的依赖项、工作目录和启动命令。 以下是执行步骤 初始化 go 项目：在 Go 项目目录中初始化 go.mod 文件。在终端中输入 go mod init 并回车，这将创建 go.mod 文件。 安装 go-gin 框架：在项目中安装 Gin 框架。在终端中输入 go get github.com/gin-gonic/gin 并回车，这将安装 Gin 框架。 编写使用 Gin 框架的 Go 代码，gin.go 文件代码如下： 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)// 测试 http 框架 https://github.com/gin-gonic/ginfunc main() &#123; // 默认返回一个已连接日志记录器和恢复中间件的引擎实例。 r := gin.Default() // 绑定路由 /ping，访问后执行func的方法 r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; // 返回一个 json， 状态值为 200， H的内容为 map[string] c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;pong&quot;, &#125;) &#125;) // 在0.0.0.0：8080上侦听和服务(对于Windows“为 localhost：8080”) err := r.Run() if err != nil &#123; fmt.Println(&quot;启动服务异常：&quot;, err) &#125;&#125; 创建一个 Dockerfile 文件，并编写文件。 12345678910111213141516171819202122232425# 使用安装了Go的基本映像FROM golang:latest# 维护者信息MAINTAINER docker_user wsxc_0617@sina.cn# 镜像的操作指令# 将工作目录设置为项目根目录WORKDIR /app# 将Go代码复制到容器的工作目录COPY . .# 设置 go module 模式，并设置代理服务ENV GO111MODULE=onENV GOPROXY=https://goproxy.cn,direct# 构建Go代码RUN env GOOS=linux GOARCH=amd64 go build -o go-gin# 暴露应用程序的端口EXPOSE 8080# 当容器启动时运行Go代码ENTRYPOINT [&quot;./go-gin&quot;] 在这个文件中，第一行必须需要使用 FROM 命令来指定要使用的基础镜像 使用 COPY 命令将 Go 代码复制到镜像中 使用 ENV 设置环境变量，这里设置 go module 的代理服务，避免 Go 依赖包下载失败 使用 RUN go build 命令来构建 Go 代码，-o 表示指定打包后输出的文件名称 在 Dockerfile 中运行的 Go 代码。可以使用 CMD 或 ENTRYPOINT 命令来运行 Go 代码，一般是执行 go build 构建好的程序名 使用 docker build 命令来构建你的 Docker 镜像。在终端中输入 docker build -t &lt;image-name&gt; . 并回车，其中 &lt;image-name&gt; 是我们要为镜像指定的名称 1docker build -t go-gin . 在命令中 -t 指定镜像的名称和标记， 格式为 name:tag，如 go-gin:latest 命令末尾的 . 表示构建上下文，即 Dockerfile 和需要包含在镜像中的文件的位置。也可以通过将 . 替换为包含Dockerfile的目录路径来指定不同的目录作为上下文。例如： 1docker build -t myimage:latest /path/to/dir 这将使用 /path/to/dir 目录中的 Dockerfile 和所需文件构建镜像。 重要的是，上下文必须包括 Dockerfile 和构建镜像所需的所有文件。Docker 守护程序将使用上下文构建镜像，并为 Dockerfile 中的每条指令创建一个新层。 命令参考：https://docs.docker.com/engine/reference/commandline/build/ 构建完成后，我们可以通过 docker images 查看构建好的镜像 1docker images 可以看到如下信息： 12REPOSITORY TAG IMAGE ID CREATED SIZEgo-gin latest d82303fc77be 34 seconds ago 1.13GB 使用 docker run 命令来运行你的 Docker 镜像。在终端中输入 docker run -p 8080:8080 &lt;image-name&gt; 并回车，其中 8080 是你希望运行应用程序的端口。 我们运行 docker run -p 8080:8080 go-gin 来运行镜像。可以看到如下结果： 1234567891011[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] GET /ping --&gt; main.main.func1 (3 handlers)[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default[GIN-debug] Listening and serving HTTP on :8080 命令参考文档：https://docs.docker.com/engine/reference/run/ 通过浏览器访问 http://localhost:8080/ping 可以看到返回了信息 &#123;&quot;message&quot;:&quot;pong&quot;&#125; 分段构建 「Dockerfile 构建镜像太大了怎么处理」 在 Dockerfile 中，可以使用多个构建阶段来进行分段构建。分段构建的目的是为了在构建 Docker 镜像的过程中，更加高效地使用资源。 在 Dockerfile 中，每个构建阶段都是一个单独的上下文，在每个构建阶段中执行的操作都是独立的。在每个构建阶段结束时，Docker 会将其上下文打包成一个新的镜像层，并将其与前面的镜像层合并。 我们在上一步操作中可以看到我们的代码量很小，但是构建出来的镜像却有 1GB 大小。主要是因为依赖包等内容也一并打包到构建的镜像中去了，实际上我们仅需编译好 Go 的二进制文件即可运行。因此可以通过 Dockerfile 的分段构建来进行镜像的瘦身。 代码如下： 1234567891011121314151617181920212223242526272829303132333435# ---------- 构建 ---------- ## 使用安装了Go的基本映像【并且设置别名】FROM golang:latest as go_app_build# 维护者信息MAINTAINER docker_user wsxc_0617@sina.cn# 镜像的操作指令# 将工作目录设置为项目根目录WORKDIR /app# 将Go代码复制到容器COPY . .# 设置 go module的代理服务ENV GO111MODULE=onENV GOPROXY=https://goproxy.cn,direct# 构建Go代码RUN env GOOS=linux GOARCH=amd64 go build -o go-gin .# ---------- 运行 ---------- ## 运行环境设置为 alpineFROM alpine:latest as go_app_run# 【采用相同的目录为工作目录】WORKDIR /app# 【将构建镜像中编译好的二进制文件复制到运行镜像中】#COPY --from=go_app_build /app .COPY --from=0 /app .# 显示应用程序的端口EXPOSE 8080# 当容器启动时运行Go代码ENTRYPOINT [&quot;./go-gin&quot;] 在修改后的 Dockerfile 中，我们可以看到有两个构建阶段：“go_app_build” 和 “go_app_run”。 在 “go_app_build” 构建阶段中，我们执行了将 Go 代码复制到容器、设置 Go module 的代理服务以及构建 Go 代码的操作。 在 “go_app_run” 构建阶段中，我们执行了将编译好的二进制文件复制到运行镜像中的操作。 COPY 指令的 --from 选项允许你从其他构建阶段复制文件。可以使用 FROM 指令的名称来标识构建阶段，也可以使用数字来标识构建阶段。当使用数字标识构建阶段时，0 表示第一个构建阶段，1 表示第二个构建阶段，以此类推。 例如，在本例中，0 表示名为 “go_app_build” 的构建阶段，即在修改后的 Dockerfile 中的第一个构建阶段。 使用数字标识构建阶段的好处是，当我们添加、删除或重新排制构建阶段时，只需要更新相应的数字即可，而不需要更新所有的构建阶段名称。 例如，假设你在修改后的 Dockerfile 中再添加了一个构建阶段，那么只需要将这个新的构建阶段的标识符设置为 2，其他的构建阶段的标识符都不需要更改。这样可以避免出现因为构建阶段名称的更改而导致的潜在问题 我们使用 docker build -t go-gin2 . 命令，来构建名为 go-gin2 的镜像，并通过 docker images 查看构建好的镜像，结果如下： 12REPOSITORY TAG IMAGE ID CREATED SIZEgo-gin2 latest ddbe692c0268 56 minutes ago 36.1MB 可以看到我们构建出来的镜像比之前小了很多，主要因为 同一个 Dockerfile 文件的多个 FROM 是多个不同的image，不同的 image 之间数据隔离，包括环境变量，但是不同的 image 之间可以通过 --from 来传递数据 同一个 Dockerfile 的多个 FROM 只有最后一个FROM 才会生成最终的镜像，因此编译阶段的环境没有在第二阶段中，第二阶段只是引用了第一阶段的生成物：二进制文件，所以最终生成的镜像文件比写一个 FROM 要小得多 分段构建的优点是，当构建过程中的某个操作失败时，Docker 只需要重新构建失败的构建阶段，而不需要重新构建整个镜像。这样可以提高构建效率，并减少构建失败的风险。 总的来说，分段构建是一种非常有用的技术，可以帮助我们提高 Docker 镜像的构建效率，并减少构建失败的风险。建议在编写 Dockerfile 时尽量使用分段构建，以便更好地利用 Docker 的构建功能。 指令 Dockerfile 指令的一般格式为INSTRUCTION &lt;arguments&gt;，下面分别做详细介绍。 FROM 格式为FROM &lt;image&gt;或FROM &lt;image&gt;:&lt;tag&gt;。第一条指令必须为FROM指令，在同一个Dockerfile中创建多个镜像时可以使用多个FROM指令（每个镜像一次）。 MAINTAINER 格式为MAINTAINER &lt;name&gt;，指定维护者信息。 RUN 格式为RUN &lt;command&gt;或RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。前者将在shell终端中运行命令，即/bin/sh -c；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现。 1RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;] 每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，当命令较长时可使用\\来换行。 CMD 支持三种格式： CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]，使用exec执行，推荐方式。 CMD command param1 param2，在/bin/sh中执行，提供给需要交互的应用。 CMD [&quot;param1&quot;, &quot;param2&quot;]，提供给ENTRYPOINT的默认参数 指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时指定了运行的命令则会覆盖掉CMD指定的命令。 EXPOSE 格式为EXPOSE &lt;port&gt; [&lt;port&gt;...]，告诉Docker服务端容器暴露的端口号，供互联系统使用。 在启动容器时需要通过-P，Docker主机会自动分配一个端口转发到指定的端口；使用-p则可以具体指定哪个本地端口映射过来。 ENV 格式ENV &lt;key&gt; &lt;value&gt;，指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。 1234ENV PG_MAJOR 9.3ENV PG_VERSION 9.3.4RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgres &amp;&amp; ...ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH ADD 格式ADD &lt;src&gt; &lt;dest&gt;，复制指定的&lt;src&gt;到容器中的&lt;dest&gt;，其中&lt;src&gt;可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。 COPY 格式COPY &lt;src&gt; &lt;dest&gt;，复制本地主机的&lt;src&gt;（为Dockerfile所在目录的相对路径，文件或目录）为容器中的&lt;dest&gt;，目标路径不存在时会自动创建。 ENTRYPOINT 配置容器启动后执行的命令，且不可被docker run提供的参数覆盖。有两种格式： ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] ENTRYPOINT command param1 param2，shell中执行。 每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后一个生效。 VOLUME 格式VOLUME [&quot;/data&quot;]，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。 USER 格式USER daemon，指定运行容器时的用户名或UID，后续的RUN也会使用指定用户。 当服务不需要管理员权限时，可通过该命令指定运行用户，并可在之前创建所需要的用户。要临时获取管理员权限可使用gosu，而不推荐sudo。 WORKDIR 格式WORKDIR /path/to/workdir，为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。 可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。 12345WORKDIR /aWORKDIR bWORKDIR cRUN pwd# 最终路径为/a/b/c ONBUILD 格式ONBUILD [INSTRUCTION]，配置当前所创建的镜像作为其他新创建的基础镜像时所执行的操作指令。 镜像image-A Dockerfile 1234[...]ONBUILD ADD . /app/srcONBUILD RUN /usr/local/bin/python-build --dir /app/src[...] 基于image-A创建新镜像，新的Dockerfile中使用FROM images-A指定基础镜像时，会自动执行ONBUILD指令内容，等价于在后面添加了两条指令。 12345FROM images-A# Automatically run the following 等价于自动运行以下命令ADD . /app/srcRUN /usr/local/bin/python-build --dir /app/src 使用ONBUILD指令的镜像推荐在标签中注明。例如ruby:1.9-onbuild。 实用技巧： 如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。 例如上面的底是golang:latest，我们可以运行docker run -it -d golang:latest bash，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。 掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。 扩展 怎样上传到阿里云私有仓库？ 参考 官方文档 Docker安装与基本操作 Docker 快速入门-制作自己的镜像 go 构建最小的镜像","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"技术/容器","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"技术/容器/Docker","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"容器","permalink":"http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.heyb.top/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://blog.heyb.top/tags/Dockerfile/"}]},{"title":"「ChatGPT」OpenAI ChatGPT注册攻略","slug":"技术/其他/「ChatGPT」OpenAI ChatGPT注册攻略","date":"2022-12-08T09:22:20.000Z","updated":"2022-12-25T14:31:59.934Z","comments":true,"path":"2022/12/08/chatgpt-openai-chatgpt-registration-strategy.html","link":"","permalink":"http://blog.heyb.top/2022/12/08/chatgpt-openai-chatgpt-registration-strategy.html","excerpt":"","text":"简介 ChatGPT 是一种大型语言模型，由OpenAI训练而成。它的目的是通过对大量语言数据的学习，能够帮助人们更好地理解和生成自然语言。它可以用来完成各种自然语言处理任务，比如机器翻译 —— 将一段文本从一种语言翻译到另外一种语言，问答系统 —— 回答日常生活的常见问题、学术问题，文本生成 —— 生成文章、邮件，解释语言语法、语义等等。 以下是 chatGPT的使用案例，可以自己参考使用或摸索合适自己的方式 案例序号 案例名称 案例来源 1 生成AI Prompt https://twitter.com/GuyP/status/1598020781065527296 2 编写iOS SwiftUI APP https://twitter.com/avielgr/status/1598895550392197121 3 学习技术 https://twitter.com/HamelHusain/status/1598834924848836609 4 写出一个可以生成小鸟图片的Python脚本 https://twitter.com/bgavran3/status/1598857248536956928 5 写Javascript脚本 https://twitter.com/vertinski/status/1599099368472137729 6 参与SAT考试 https://twitter.com/davidtsong/status/1598767389390573569 7 自然语言转成Latex https://twitter.com/jdjkelly/status/1598021488795586561 8 解释代码 https://twitter.com/goodside/status/1598129631609380864 9 改写故事 https://twitter.com/raphaelmilliere/status/1598469100535259136 10 debugging代码 https://twitter.com/amasad/status/1598042665375105024 11 写计算机网络家庭作业 https://twitter.com/abhnvx/status/1598258353196929024 12 替代搜索引擎 https://twitter.com/RajJohri2019/status/1598492953764315137 13 创作短剧 https://twitter.com/rgodfrey/status/1598162900140445697 14 创作食谱 https://twitter.com/stephsmithio/status/1598920887029628928 15 反编译汇编代码 https://twitter.com/mahal0z/status/1598536939942006784 16 代写办公邮件 https://twitter.com/CubicleApril/status/1598753388895797282 17 写年度总结报告 https://twitter.com/shanselman/status/1599073011050872832 18 闲聊 https://twitter.com/t3dotgg/status/1598954493680713729 19 撰写技术博客 https://twitter.com/goodside/status/1598235521675038722 20 逻辑推理问题 https://twitter.com/Robdeprop/status/1598285166971351040 准备 留学代理，要求是非中国（及地区）的地址，如日韩、印度、新加坡、美国等 准备一个国外手机号或者用接码平台 sms-activate 开始 接码平台 打开接码平台 sms-activate.org，注册一个账号。注册后在右上角个人信息中进行充值，这里单位是卢布 接码OpenAi的一次费用是大概10卢布（约 1 块多人民币），不过只能充美金，充值0.2美元即可，充值时下滑可以选择支付宝进行支付。 充值完成后我们去注册openAI的账号 注册OpenAI账号 首先是打开ChatGPT的账户注册页面。谷歌注册或者邮箱注册都可以，这里用邮箱注册作为例子。 用邮箱注册后有个验证邮件，进去邮箱，点开链接。（如果无法打开链接的话要注意邮件中是否允许了可执行脚本） 如果出现提示说不能在当前国家服务： Not available OpenAI's services are not available in your country. 就是因为代理没有设置为全局，或者地区不对。 如果出现了这个提示，那么接下来怎么切换代理，都是没用的，可以在浏览器控制台清空状态 解决地区问题 首先要将代理地址切换到不是国内地区的代理（如港澳台） 然后，先复制下面这段代码 1javascript:window.localStorage.removeItem(Object.keys(window.localStorage).find(i=&gt;i.startsWith(&#x27;@@auth0spajs&#x27;))) 打开浏览器控制台粘贴进去，然后按下回车键，接着刷新页面，如果代理没问题，就可以正常看到注册页面了。 填写手机验证码 到我们的接码网站上去，在左侧菜单栏搜索OpenAi，然后选择巴西（经测试可用）或印度（更实惠但未经测试），点击小黄车购买。 然后在右侧主页面会出现购买好的手机号，点击复制后回到 openAI的验证界面-verify your phone number，选择了对应国家地区然后粘贴手机号选send code。 回到接码平台的手机号界面，等待一会儿网站会提示验证码，我们复制粘贴即可。 如果申请Send code发送短信时，总是出现发送短信请求次数过多，无法发送的问题。 这个应该是ChatGPT的用户突然暴增导致的，官方也给了说明，大家耐心等待一会应该就可以。 现在我们可以愉快的进行使用了 其他 需要注意的是 ChatGPT目前是不联网的状态，所以回答的内容也是2021年之前的。 ChatGPT的回答不是 100%准确，仅可以作为参考。并且也和提问的技巧有关系： 如：问它能说一下Java工作中遇到的问题吗？ 它会回答： 由于我是一个计算机程序，我没有工作，也没有遇到任何 Java 问题。我只能通过对已有信息的学习来回答问题。你可以提供一些关于 Java 的信息，我可以尝试为你解答问题。 如果问它：假设我是一名 多年经验的高级java开发程序员，你能尝试模拟说我在工作中遇到的问题吗 它就可以模拟情景来进行回答 ChatGPT使用英文提问会比使用中文提问效果会更好 参考 最强AI对话系统ChatGPT不完全使用指南——已发掘功能展览！","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"其他","slug":"技术/其他","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/"},{"name":"AI","slug":"技术/其他/AI","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/"},{"name":"ChatGPT","slug":"技术/其他/AI/ChatGPT","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/ChatGPT/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://blog.heyb.top/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://blog.heyb.top/tags/OpenAI/"}]},{"title":"「Docker」Docker 系列文章1 - 入门","slug":"技术/容器/docker/「Docker」Docker 系列文章1 - 入门","date":"2022-12-04T08:14:47.000Z","updated":"2022-12-25T14:32:35.853Z","comments":true,"path":"2022/12/04/docker-docker-series-1---getting-started.html","link":"","permalink":"http://blog.heyb.top/2022/12/04/docker-docker-series-1---getting-started.html","excerpt":"","text":"简介 Docker 是一个开源的容器管理平台，它允许开发人员在轻量级容器中运行应用程序。容器是一种轻量级的虚拟化技术，它允许将应用程序及其依赖项打包在一起，并在任何支持容器的环境中运行。这样，开发人员可以确保应用程序在不同的平台上保持一致，并且能够在任何地方快速部署和运行。 Docker可以简单理解为轻量级的虚拟机，但它使用独立于底层操作系统的容器来运行应用程序。与虚拟机相比，Docker 可以更快速地启动和运行应用程序，因为它不需要启动一个完整的操作系统来运行应用程序。这也使得 Docker 更容易在多个环境中进行部署，例如开发环境、测试环境和生产环境。 优点 轻量级：可以通过一行命令完成启动和停止，方便快捷。 可移植：可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意操作系统，在不同的环境中运行。 隔离：运行时利用沙箱机制形成隔离容器，各个应用互不干扰，可以有效地管理应用程序之间的依赖关系和资源限制。 Docker 的生态系统提供了丰富的工具，可以帮助开发人员构建、部署和管理容器化应用程序。 能做什么 快速部署，解决不同环境中系统差异的问题 在使用Docker前，我们在不同环境下（如开发环境、测试环境、生产环境等）需要安装、配置、维护不同的应用程序（如JDK、Tomcat、数据库等），不同应用在每个环境都需要做一遍同样的操作，工作量繁重。使用Docker可以自己创建空镜像从头构建（或使用公共仓库中构建好的镜像），直接能够在不同环境中一步到位搭建部署整套应用环境。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“代码在我机器上没问题啊”的情况。 解决依赖问题，多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0 大型项目中依赖关系复杂，依赖的组件非常多，不同组件之间部署时往往会产生依赖兼容性问题。 例如：一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项，甚至Node JS的版本都需要不相同，此时便会出现依赖兼容问题。Docker应用运行在容器中，使用沙箱机制可以将环境互相隔离。不同应用需要不同的版本我们就运行在不同的容器中即可。 更轻松的扩展和维护 基于上面的优点，使得Docker在应用复用更为容易，能够使得应用快速扩展，让服务弹性伸缩变得简单，能够轻松地完成动态管理的工作，根据业务需求实时扩展或拆除应用程序和服务。 快速安装测试/学习软件，用完就可以删除，不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK 概念 镜像（Image）：像是文件模板，可以理解为软件安装包，可以方便的进行传播和安装。一个镜像可以创建多个容器 容器（Container）：是由镜像创建的运行实例，可以理解为软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。 仓库（Repository）：集中存放镜像文件的场所，可以理解为 Maven、Git 的仓库，当我们需要镜像文件的时候，可以从远程仓库中拉取。官方镜像仓库：https://hub.docker.com/ 安装 桌面版：https://www.docker.com/products/docker-desktop 服务器版：https://docs.docker.com/engine/install/#server 问题 windows 打开桌面版的时候如果出现了如下问题 Hardware assisted virtualization and data execution protection must be enabled in the BIOS. 则需要开启 WSL2 功能 在控制面板-&gt;程序-&gt;启用或关闭 windows 功能，勾选Windows虚拟机监控程序平台和适用于Linux的Windows子系统，以开启 Windows 虚拟化和 Linux 子系统（WSL2) 如果出现 WSL 2 installation is incomplete. The WSL2 Linux kernel is now installed using a separate MSI update package. Please click the link and follow the instructions to install the kernel update: xxx 则需要安装最新版本的 WSL2： https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi 配置 镜像加速源 镜像加速器 镜像加速器地址 Docker 中国官方镜像 https://registry.docker-cn.com DaoCloud 镜像站 http://f1361db2.m.daocloud.io Azure 中国镜像 https://dockerhub.azk8s.cn 科大镜像站 https://docker.mirrors.ustc.edu.cn 阿里云 https://&lt;your_code&gt;.mirror.aliyuncs.com 七牛云 https://reg-mirror.qiniu.com 网易云 https://hub-mirror.c.163.com 腾讯云 https://mirror.ccs.tencentyun.com 安装软件 传统应用安装，可能需要先安装许多的依赖。例如我们安装WordPress （一个基于 PHP 和 MySQL 的免费和开源内容管理系统（CMS））的话，则需要先安装Apache、Php、MySQL等环境后才可以正常安装WordPress。同一系统下也不方便安装多个版本的软件，有些软件还卸载不干净。 相对比之下Dokcer安装更简洁，一个命令就可以快速安装和卸载。也没有系统兼容的问题，Linux专享的软件也可以在Windows下使用。 安装Redis 在Redis官方网站中并没有提供Docker相关的安装方式。 可以通过Docker官方镜像仓库查找Redis镜像：https://hub.docker.com/_/redis 通过命令 docker pull redis 来拉取镜像，也可以通过直接运行 docker run 来创建并运行容器： 1docker run -d -p 6379:6379 --name redis redis:latest 然后会返回一串容器id（我这里是1c8f24cddd1d7a4accac19e1ef8f7ab68e70f663c3a8f184bbc732fd50f43abd）， 就表示创建成功。如果有需要，我们也可以设置更多参数： 1docker run --restart=always --log-opt max-size=100m --log-opt max-file=2 -p 6379:6379 --name redis -d redis --appendonly yes --requirepass 123456 --restart=always 为开机启动 -log 为日志方面的设置 -p 为将内部端口映射到外部的端口，将6379端口挂载出去，前面为宿主机端口，后面为镜像内端口 -name 为容器名字 -d redis 表示后台启动redis -- appendonly yes 开启 redis 持久化 -- requirepass 为设置redis访问密码 注意：生产环境尽量不要使用 latest 版本，应使用指定版本号 查看状态 通过以下命令查看容器运行状态： 1docker ps -a |grep &lt;容器名&gt; 运行 docker ps -a |grep redis 得到以下结果： 11c8f24cddd1d redis &quot;docker-entrypoint.s…&quot; 47 seconds ago Up 45 seconds 0.0.0.0:6379-&gt;6379/tcp redis 或者通过容器 id 来查看状态如：docker ps -a | grep 1c8f 查看容器运行日志 1docker logs --since 30m &lt;容器名/id&gt; –since 30m 是查看此容器30分钟之内的日志情况。 运行docker logs --since 30m redis 或 docker logs --since 30m 1c8f 得到如下结果： 12345671:C 15 Dec 2022 08:23:37.361 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo1:C 15 Dec 2022 08:23:37.361 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started1:C 15 Dec 2022 08:23:37.361 # Configuration loaded1:M 15 Dec 2022 08:23:37.363 * monotonic clock: POSIX clock_gettime1:M 15 Dec 2022 08:23:37.366 * Running mode=standalone, port=6379.1:M 15 Dec 2022 08:23:37.366 # Server initialized1:M 15 Dec 2022 08:23:37.367 * Ready to accept connections 进入容器 1docker extc -it &lt;容器&gt; &lt;命令&gt; 运行 docker exec -it redis redis-cli 或 docker exec -it 1c8f redis-cli 就可以进入到redis 当中，刚才我们设置了密码，因此要用auth命令登录后才可以使用。 1234567127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; set abc 1OK127.0.0.1:6379&gt; get abc&quot;1&quot;127.0.0.1:6379&gt; exit 此时我们已经可以操作并查看到redis中的数据了，证明我们已经安装成功，接下来我们学习怎样停止或删除容器 删除容器 我们需要停止运行中的容器才可以删除 停止命令： 1docker stop &lt;容器名/id&gt; 运行 docker stop redis 或 docker stop 1c8f停止容器 删除命令： 1docker rm &lt;容器名/id&gt; 运行 docker rm redis 或 docker rm 1c8f 删除容器 通过 docker ps -a 查看 redis 容器已经被删除 删除镜像 查看全部镜像命令： 1docker images 删除镜像命令： 1docker rmi &lt;镜像id&gt; 运行 docker rmi 7614 删除镜像， 这里的7614是我的redis的镜像id 常用命令 镜像 获取镜像 docker pull IMAGE_NAME[:Tag] ：用于从 Docker 仓库下载镜像，如不显式指定TAG，则默认选择latest标签 查看信息 docker images列出本地主机上已有的镜像信息 docker inspect IMAGE_ID可以获取该镜像的详细信息。 标签镜像 docker tag REPOSITORY:TAG可为本地镜像添加新的标签，例如 docker tag ubuntu:latest latest_ubuntu:latest 搜索镜像 docker search IMAGE_NAME ：用于在 Docker 仓库中搜索镜像，例如 docker search mysql 可选参数： --automated=false 仅显示自动创建的镜像 --no-trunc=false 输出信息不截断显示 -s，–starts=0 指定仅显示评价为指定星级以上的镜像 删除镜像 docker rmi IMAGE[IMAGE...]IMAGE可以为标签或ID。使用镜像ID来删除时，会先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身。 注意：当有该镜像创建的容器存在时，镜像文件默认是无法被删除的。 docker ps -a命令可以看到本机上存在的所有容器。 强制删除镜像用docker rmi -f IMAGE命令。使用-f参数来强制删除一个存在容器依赖的镜像会造成一些遗留问题。正确做法是先删除依赖镜像的所有容器，再来删除镜像。删除容器用docker rm CONTAINER_ID命令。 创建镜像 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG] 基于已有镜像的容器创建 可选参数： -a，–author=“” 作者信息 -m，–message&quot;&quot; 提交信息 -p，–pause=true 提交时暂停容器运行 举例如下： 12345678910111213[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 dea1945146b9 6 weeks ago 188MB[root@localhost test]# docker run -ti ubuntu:14.04 /bin/bashroot@098ab9bc25f8:/# touch testroot@098ab9bc25f8:/# exitexit[root@localhost test]# docker commit -m &quot;Added a new file&quot; -a &quot;Docker Test&quot; 098ab9bc25f8 testsha256:68ceff3107a82641378dee544caeed48e6d544b4d74b525051381b7db7479d35[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest 68ceff3107a8 16 seconds ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB 基于本地模板导入使用cat 镜像压缩包 | docker import -REPOSITORY:TAG命令。 123456789[root@localhost test]# lsubuntu-14.04-x86_64-minimal.tar.gz[root@localhost test]# cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04-serversha256:ae63a9e87332075323de0e2cb3e12dd6ea8c6078e006dd937dc0d670c4a8773d[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04-server ae63a9e87332 12 seconds ago 215MBtest latest 68ceff3107a8 About an hour ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB 存储镜像 docker save -o 压缩包保存名 REPOSITORY:TAG 可存出镜像。 举例如下： 123456[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 dea1945146b9 6 weeks ago 188MB[root@localhost test]# docker save -o ubuntu_server.tar ubuntu:14.04[root@localhost test]# lsubuntu_server.tar 载入镜像 docker load --input 压缩包保存名或者docker load &lt; 压缩包保存名可从导出的文件中重新载入镜像。 举例如下： 1234567[root@localhost test]# lsubuntu_server.tar[root@localhost test]# docker load --input ubuntu_server.tar Loaded image: ubuntu:14.04[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 dea1945146b9 6 weeks ago 188MB 构建镜像 docker build：用于从 Dockerfile 创建一个新的镜像 上传镜像 可以使用docker push NAME[:TAG]上传镜像到仓库，默认上传到DockerHub官方仓库。第一次使用必须要先登录。 举例如下： 1234567891011121314151617181920212223242526[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04-server ae63a9e87332 4 minutes ago 215MBtest latest 68ceff3107a8 About an hour ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB[root@localhost test]# docker tag test:latest username/test:latest[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04-server ae63a9e87332 7 minutes ago 215MBusername/test latest 68ceff3107a8 About an hour ago 188MBtest latest 68ceff3107a8 About an hour ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB[root@localhost test]# docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.Username: usernamePassword: Login Succeeded[root@localhost test]# docker push username/test:latestThe push refers to a repository [docker.io/username/test]786a798121af: Pushed 7fb9ba64f896: Pushed 4e1e6ac5b9d6: Pushed 48daf661d621: Pushed bf59e7acf5c4: Pushed c47d9b229ca4: Pushed latest: digest: sha256:c46955d49b5b7cf15528b94d5c4fb7028b61c52cf00ee4d14073a92379e2237f size: 1566 容器 创建容器 docker create CONTAINER_NAME 命令来新建一个容器，新建的容器处于停止状态，可以使用docker start &lt;CONTAINER_ID&gt;命令来启动它。 启动容器 启动容器有两种方式： 将在终止状态的容器重新启动，命令为 docker start CONTAINER 基于镜像创建并运行一个新的容器，命令为 docker run CONTAINER ， 等价于先执行docker create，再执行docker start。 可选参数： -t，让Docker分配一个伪终端并绑定到容器的标准输入上 -i，则让容器的标准输入保持打开 -d，会让Docker容器在后台以守护形式运行，获取容器输出信息 例如 docker run -t -i ubuntu:14.04 /bin/bash 会启动一个bash终端，允许用户进行交互，举例如下： 123456789101112131415161718192021222324[root@localhost test]# docker run -t -i ubuntu:14.04 /bin/bashroot@eac23878c8bf:/# pwd/root@eac23878c8bf:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@eac23878c8bf:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 15 pts/0 00:00:00 psroot@eac23878c8bf:/# exitexit[root@localhost test]# docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello word; sleep 1; done&quot;2105fbb444b3b028a1b26ec5879d8d282ccc2fa7d0a9776a8a86e808d3414843[root@localhost test]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2105fbb444b3 ubuntu:14.04 &quot;/bin/sh -c &#x27;while...&quot; 11 seconds ago Up 10 seconds confident_payneeac23878c8bf ubuntu:14.04 &quot;/bin/bash&quot; 2 minutes ago Exited (0) 2 minutes ago adoring_shockley[root@localhost test]# docker logs 2105fbb444b3hello wordhello wordhello wordhello word...[root@localhost test]# docker stop 2105 停止容器 docker stop 命令用于停止一个正在运行的容器 可选参数： -t， 指定停止容器前等待的秒数。默认值是10秒 扩展： docker ps -a -q 命令为查看所有(-a)的容器ID(-q)，这条命令也可以提供给另外的命令组合使用，如下： docker stop $(docker ps -a -q) ，命令为停止所有容器 docker restart 将一个运行态的容器终止然后再重新启动它。 进入容器 在运行容器的时候使用-d参数，容器会进入后台，用户无法看到容器中的信息，需要通过命令来进入到容器中进行操作。 docker attach CONTAINER 它允许我们连接到正在运行的容器并在其中运行命令。可以使用它来在容器内部执行操作，例如查看容器的日志或运行容器内的应用程序。这条命令将会打开一个新的终端窗口，可以在容器内部运行命令。要退出容器，可以使用快捷键 Ctrl+P 和 Ctrl+Q。 注意，docker attach 命令只能用于连接正在运行的容器。如果要连接已停止的容器，我们需要使用 docker exec 命令。 docker exec 命令的语法如下： docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 其中，CONTAINER 是要连接的容器的名称或 ID，COMMAND 是要在容器内部运行的命令，ARG 是命令的参数。 例如，假设想要在名为 my_container 的容器内部运行命令 ls -l，可以使用下面的命令： 1docker exec my_container ls -l 要在容器中使用 bash，举例如下： 12345[root@localhost test]# docker exec -ti a0bb97c292d1 /bin/bashroot@a0bb97c292d1:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@a0bb97c292d1:/# exitexit 删除容器 可以使用docker rm [OPTIONS] CONTAINER [CONTAINER...]命令删除处于终止状态的容器。 可选参数： -f，–force=false 强行终止并删除一个运行中的容器 -l，–link=false 删除容器的连接，但保留容器 -v，–volumes=false 删除容器挂载的数据卷 扩展 docker rm $(docker ps -a -q)，删除所有容器 导入导出 导出容器是指导出一个已经创建好的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export CONTAINER命令。 12345678[root@localhost test]# docker run -tid ubuntu:14.04547e74d47ec3eb30736aee22c1b7bf2acd6e71470a1ade4561007a10b3b14a36[root@localhost test]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES547e74d47ec3 ubuntu:14.04 &quot;/bin/bash&quot; 6 seconds ago Up 5 seconds unruffled_jennings[root@localhost test]# docker export 547 &gt; test.tar[root@localhost test]# lstest.tar 导出的文件又可以使用docker import命令导入，成为镜像。 12345678910[root@localhost test]# lstest.tar[root@localhost test]# cat test.tar | docker import - test/ubuntu:v1.0sha256:1ab7c63a882a9bc13ff4673081a237ba8785d47ba69458bfe976c0e5fc7b9c99[root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/ubuntu v1.0 1ab7c63a882a 22 seconds ago 175MBubuntu 14.04-server ae63a9e87332 2 hours ago 215MBsecurityweekly/test latest 68ceff3107a8 3 hours ago 188MBubuntu 14.04 dea1945146b9 6 weeks ago 188MB 其他命令 docker --help 查看帮助命令 docker logs：用于查看容器的日志输出。 docker volume ls 查看 volume 列表 docker network ls 查看网络列表 这只是一些常用的 Docker 命令，Docker 还有很多其他的命令和功能。有关 Docker 命令的完整列表，可以参考 Docker 的官方文档 参考 Docker 快速入门 Docker安装与基本操作","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"技术/容器","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"技术/容器/Docker","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"容器","permalink":"http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.heyb.top/tags/Docker/"}]},{"title":"「RDS」华为云 RDS 恢复误删MySQL数据恢复流程","slug":"技术/云/「RDS」华为云 RDS 恢复误删MySQL数据恢复流程","date":"2022-11-30T16:00:00.000Z","updated":"2022-12-25T14:31:45.886Z","comments":true,"path":"2022/12/01/[rds]-huawei-cloud-rds-recovery-process-for-mistakenly-deleting-mysql-data.html","link":"","permalink":"http://blog.heyb.top/2022/12/01/[rds]-huawei-cloud-rds-recovery-process-for-mistakenly-deleting-mysql-data.html","excerpt":"","text":"背景 本文是记录 2021年4月25日云数据恢复操作 大致流程是通过 binlog 恢复 mysql 中的数据，我们购买的是华为云 RDS，所以直接在 RDS 进行操作。 RDS 它的恢复流程是会先将数据全量恢复到 指定日期，再重放 binlog 操作到指定时间点。 过程 登录华为云服务器管理后台 在「关注资源」（或者左边菜单栏） - 选中 「云数据库 RDS」 在 RDS 控制台中选中 「备份管理」，下载两个备份数据。一个是今天0425日的（是我服务器停机后手动备份的，时间点为：2021/04/25 14:57:39）， 一个是昨日RDS 自动备份的（时间点为2021/04/24 20:51:38） 在 RDS 控制台中选中「数据库管理服务（DAS）」，此时会新打开一个 DAS窗口 在 DAS 控制台菜单中选中「开发工具」，点击实例名称，如rds-001(192.168.10.20 在上菜单栏中选择「binlog」标签 =&gt; 「归档日志」-「起止时间」- 输入具体日期，如 2021/04/24 21:30:00 到 2021/04/24 23:59:59 点击解析日志，再点查看日志详细内容，找到我们具体注释操作（动作描述为数据表 xxx 发生 DDL 操作）的具体时间（变更时间）， 举个例子为 22 点整，我们记录下来，届时要回滚的操作就是要指定到这个**#时间点#** 回到 RDS 窗口，在 RDS 控制台中选中 「实例管理」，点击实例的名称 - 如rds -001 296ce7f544bd4e889d2e38b934bf80cain01 进入到具体实例的详情中 在左侧菜单选择「备份恢复」，选择 「binlog备份」标签 「恢复到指定时间点」是指整个库一起恢复，「表级时间点恢复」可以勾选具体表来进行恢复，我们依据需求进行选择，时间点设置到我们进行 DDL操作前的 #时间点#，然后进行恢复 恢复后我们要恢复对误操作时间点之后的系统操作（即普通用户操作），有两种方法，一种是直接比对时间点后的数据（如根据时间去查询数据，然后比对两份数据），另外一种是在 DAS 中解析 binlog，依据日志对数据重新进行设置值，直至最终恢复完毕","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"RDS","slug":"技术/RDS","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/"},{"name":"华为云","slug":"技术/RDS/华为云","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/%E5%8D%8E%E4%B8%BA%E4%BA%91/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"华为云","slug":"华为云","permalink":"http://blog.heyb.top/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"RDS","slug":"RDS","permalink":"http://blog.heyb.top/tags/RDS/"}]},{"title":"「Go」Go-搭建IM即时通讯系列文章1-搭建基础框架","slug":"技术/go/「Go」Go-搭建IM即时通讯系列文章1-搭建基础框架","date":"2022-11-27T15:06:20.000Z","updated":"2022-12-25T14:29:19.675Z","comments":true,"path":"2022/11/27/go-go---building-im-instant-messaging-series-1---building-the-infrastructure.html","link":"","permalink":"http://blog.heyb.top/2022/11/27/go-go---building-im-instant-messaging-series-1---building-the-infrastructure.html","excerpt":"","text":"通过「Go」Go 组件系列文章，我们已经了解了一些组件的基本使用。下面我们将以实现登录功能为目标来完整的搭建一个基础框架。 和上述步骤一样，我们从配置项搭建开始，在 项目根目录/src/main/ 目录下新建一个 config 目录，用于存放配置文件。在该目录下新建 database、settings 目录，并分别新建 database.go 和 settings.go 文件，用做初始化读取配置（viper）以及初始化数据库操作（grom）。 Viper 读取配置 settings.go 提供了读取配置并设置到全局实体提供给其他类使用，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// Package settings/**此文件用于读取配置文件 app.yml，并设置到对应实体，以提供给其他文件使用。因此该文件需要优先进行初始化操作*/package settingsimport ( &quot;fmt&quot; &quot;github.com/spf13/viper&quot; &quot;time&quot;)// 定义实体装载配置文件内容// Settings 设置type Settings struct &#123; Server Server `mapstructure:&quot;server&quot;` Database Database `mapstructure:&quot;db&quot;`&#125;var Setting = &amp;Settings&#123;&#125;// Server 服务type Server struct &#123; // Url 地址 Url string `mapstructure:&quot;url&quot;` // Port 端口 Port int `mapstructure:&quot;port&quot;` // ReadTimeout 读取超时 ReadTimeout time.Duration `mapstructure:&quot;readTimeout&quot;` // WriteTimeout 写入超时 WriteTimeout time.Duration `mapstructure:&quot;writeTimeout&quot;`&#125;var ServerSetting = &amp;Server&#123;&#125;// Database 数据库type Database struct &#123; // Type 类型 Type string `mapstructure:&quot;type&quot;` User string `mapstructure:&quot;user&quot;` Password string `mapstructure:&quot;password&quot;` Host string `mapstructure:&quot;host&quot;` Name string `mapstructure:&quot;name&quot;` TablePrefix string `mapstructure:&quot;prefix&quot;`&#125;var DatabaseSetting = &amp;Database&#123;&#125;// Setup 设置func Setup() &#123; // 配置文件名(不带扩展名，即 app.yml 只需要app这部分) viper.SetConfigName(&quot;app&quot;) // 如果配置文件名称中没有扩展名，则为必填项 viper.SetConfigType(&quot;yaml&quot;) // 在其中查找配置文件的路径 viper.AddConfigPath(&quot;src/resource/&quot;) // 查找并读取配置文件 err := viper.ReadInConfig() if err != nil &#123; // 处理读取配置文件时出现的错误 panic(fmt.Errorf(&quot;读取配置异常: %w&quot;, err)) &#125; fmt.Println(&quot;初始化配置文件成功&quot;) viper.WatchConfig() // 将配置信息解析为实体 err = viper.UnmarshalKey(&quot;settings&quot;, Setting) if err != nil &#123; panic(fmt.Errorf(&quot;读取配置异常，解析失败: %w&quot;, err)) &#125; // 设置为全局变量，后续有其他配置则新增实体和变量即可 ServerSetting = &amp;Setting.Server DatabaseSetting = &amp;Setting.Database // 设置初始值 // 超时时间单位设置为秒 ServerSetting.ReadTimeout = ServerSetting.ReadTimeout * time.Second ServerSetting.WriteTimeout = ServerSetting.WriteTimeout * time.Second&#125; 该类主要操作 读取配置文件并解析为实体 设置全局变量提供给其他类使用 设置初始值 Gorm 连接数据库 database.go 提供了初始化数据库连接的操作，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package databaseimport ( &quot;fmt&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot; &quot;gorm.io/gorm/logger&quot; &quot;log&quot; &quot;os&quot; &quot;star-im/src/main/config/settings&quot; &quot;time&quot;)// DBS 定义全局变量，提供给其他方法调用var DBS *gorm.DB// Setup 初始化数据库连接// https://gorm.io/zh_CN/func Setup() &#123; var err error //定义连接路径 dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;, settings.DatabaseSetting.User, settings.DatabaseSetting.Password, settings.DatabaseSetting.Host, settings.DatabaseSetting.Name) // 连接数据库，并设置基本的配置 // 日志 newLogger := logger.New( log.New(os.Stdout, &quot;\\r\\n&quot;, log.LstdFlags), // io writer（日志输出的目标，前缀和日志包含的内容） logger.Config&#123; // 慢 SQL 阈值 SlowThreshold: time.Second, // 日志级别 LogLevel: logger.Silent, // 忽略ErrRecordNotFound（记录未找到）错误 IgnoreRecordNotFoundError: true, // 彩色打印 Colorful: true, &#125;, ) DBS, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123; Logger: newLogger, &#125;) if err != nil &#123; panic(fmt.Errorf(&quot;初始化数据库异常: %w&quot;, err)) &#125; // 获取通用数据库对象 sql.DB ，然后使用其提供的功能 sqlDB, err := DBS.DB() // 用于设置连接池中空闲连接的最大数量。 sqlDB.SetMaxIdleConns(10) // 设置打开数据库连接的最大数量。 sqlDB.SetMaxOpenConns(100) // 设置了连接可复用的最大时间。 sqlDB.SetConnMaxLifetime(time.Hour)&#125; 该类主要操作 读取数据库连接配置 初始化数据库连接 定义了 慢 SQL 日志配置 设置了数据库连接池配置 返回全局变量DBS供其他类使用 Init 加载配置 在 项目根目录/src/main/config 目录下新建 init.go 文件，用于初始化上面两个配置项。 init.go 代码如下： 1234567891011121314151617package configimport ( &quot;star-im/src/main/config/database&quot; &quot;star-im/src/main/config/redis&quot; &quot;star-im/src/main/config/settings&quot;)// Initial 初始化func Initial() &#123; // 初始化配置 settings.Setup() // 初始化数据库连接 database.Setup() // 后续有其他配置项可以在下面添加……&#125; 该文件到时候放在main方法中执行即可 Main 程序入口 在 项目根目录 下新建一个 main.go 作为我们作为http程序主入口，参考 gin 章节初始化gin main.go 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;star-im/src/main/config&quot; &quot;star-im/src/main/config/settings&quot; &quot;star-im/src/main/routers&quot;)// init 初始化func init() &#123; // 初始化配置项 config.Initial()&#125;func main() &#123; // 路由 routersInit := routers.Setup() // 读取超时 readTimeout := settings.ServerSetting.ReadTimeout // 写入超时 writeTimeout := settings.ServerSetting.WriteTimeout // 端口 endPoint := fmt.Sprintf(&quot;:%d&quot;, settings.ServerSetting.Port) // 最大 header 数 maxHeaderBytes := 1 &lt;&lt; 20 // 配置 http Server server := &amp;http.Server&#123; Addr: endPoint, Handler: routersInit, ReadTimeout: readTimeout, WriteTimeout: writeTimeout, MaxHeaderBytes: maxHeaderBytes, &#125; log.Printf(&quot;[info] 启动http服务器侦听 %s&quot;, endPoint) // 启动服务 err := server.ListenAndServe() if err != nil &#123; // 启动异常 panic(fmt.Errorf(&quot;启动服务异常：%w&quot;, err)) &#125;&#125; 该类主要操作 初始化配置 初始化路由配置以及服务基础设置 routers.Setup() ，路由等信息单独放在另外一个目录 routers中来统一管理。 router 路由配置 在 项目根目录/src/main/ 目录下新建一个 routers 目录，并按照层级建立 api/v1 两个目录，用于存放路由接口。v1 表示接口版本号，方便后续迭代接口版本。 在 项目根目录/src/main/routers/api 目录下创建 health.go ，代码如下： 1234567891011121314package apiimport ( &quot;github.com/gin-gonic/gin&quot; &quot;star-im/src/main/common/app&quot;)// Ping 接口连通性测试func Ping(c *gin.Context) &#123; // 直接返回成功结果 c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;成功&quot;, &#125;)&#125; 该类主要做连通性测试，因此直接返回json成功数据 在 项目根目录/src/main/routers 目录下创建 router.go 文件用于初始化路由配置，代码如下 1234567891011121314151617181920212223242526package routersimport ( &quot;github.com/gin-gonic/gin&quot; &quot;io&quot; &quot;os&quot; &quot;star-im/src/main/handler&quot; &quot;star-im/src/main/routers/api&quot;)// Setup 初始化路由func Setup() *gin.Engine &#123; r := gin.Default() // 记录到文件 f, _ := os.Create(&quot;gin.log&quot;) gin.DefaultWriter = io.MultiWriter(f) // 使用中间件 // 统一日志 r.Use(gin.Logger()) // 不需要鉴权 r.GET(&quot;/ping&quot;, api.Ping) return r&#125; 该类主要操作 初始化路由设置 指定记录日志到文件 指定具体的路由地址以及请求方式和响应函数 这时候我们启动根目录下的 main函数即可启动服务，通过浏览器访问：http://localhost:8081/ping 可以得到返回值 1&#123;&quot;msg&quot;: &quot;成功&quot;&#125; 到这一步我们已经能够提供一个提供基础访问的应用，后续我们继续完善应用的内容。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"}]},{"title":"「Go」Go-搭建IM即时通讯系列文章2-统一返回值及异常处理","slug":"技术/go/「Go」Go-搭建IM即时通讯系列文章2-统一返回值及异常处理","date":"2022-11-27T15:06:20.000Z","updated":"2022-12-25T14:29:33.480Z","comments":true,"path":"2022/11/27/go-go---building-im-instant-messaging-series-2---unified-return-values-and-exception-handling.html","link":"","permalink":"http://blog.heyb.top/2022/11/27/go-go---building-im-instant-messaging-series-2---unified-return-values-and-exception-handling.html","excerpt":"","text":"在软件开发过程中，通过定义统一返回值还可以提高框架的可用性和可维护性，让开发人员更容易理解和使用框架中的各种功能。同时统一异常处理能够帮助我们更好地控制程序的流程，能够让我们更好地捕获异常并作出相应的处理。这样做可以帮助我们减少代码重复，提高代码的可读性和可维护性。 统一返回值 我们规范约定返回值参数有利于我们对数据进行管理以及提升前后端开发的效率。 在 项目根目录/src/main/ 目录下新建一个common/app 层级目录，并在 app 目录下分别建立 code.go、msg.go、 response.go 用于存放 返回值、返回消息、统一返回值的实体对象。 code.go 主要定义返回值常量，代码如下： 12345678910package appimport &quot;net/http&quot;const ( // 成功使用 200 SUCCESS = http.StatusOK // 异常使用 -1 ERROR = -1) msg.go 主要定义返回值常量对应的消息内容，代码如下： 123456789101112131415161718package app// MessageMap 返回值常量对应的消息内容，消息集合：&#123;消息码，消息内容&#125;var MessageMap = map[int]string&#123; SUCCESS: &quot;成功&quot;, ERROR: &quot;失败&quot;,&#125;// GetMsg 根据代码获取返回信息func GetMsg(code int) string &#123; msg, ok := MessageMap[code] if ok &#123; return msg &#125; return MessageMap[ERROR]&#125; response.go 主要定义返回值的对象，代码如下： 12345678910111213141516171819202122232425262728293031323334353637package appimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)// Response 响应对象type Response struct &#123; // 响应编码 Code int `json:&quot;code&quot;` // 返回消息 Msg string `json:&quot;msg&quot;` // 返回数据 Data interface&#123;&#125; `json:&quot;data&quot;`&#125;// Res 设置 gin.JSON 的内容func Res(c *gin.Context, httpCode, errCode int, data interface&#123;&#125;) &#123; c.JSON(httpCode, Response&#123; Code: errCode, Msg: GetMsg(errCode), Data: data, &#125;) return&#125;// Success 返回成功结果func Success(c *gin.Context, data interface&#123;&#125;) &#123; Res(c, http.StatusOK, SUCCESS, data)&#125;// Error 返回错误结果，异常结果放在统一异常处理 handler中func Error(c *gin.Context, data interface&#123;&#125;) &#123; Res(c, http.StatusOK, ERROR, data)&#125; 这时我们可以修改 src/main/routers/api/health.go 中返回的结果如下： 12345678910111213package apiimport ( &quot;github.com/gin-gonic/gin&quot; &quot;star-im/src/main/common/app&quot;)// Ping 接口连通性测试func Ping(c *gin.Context) &#123; // 直接返回成功结果 app.Success(c, nil)&#125; 这时候我们通过浏览器访问 http://localhost:8081/ping，得到如下返回： 12345&#123; &quot;code&quot;:200, &quot;msg&quot;:&quot;成功&quot;, &quot;data&quot;:null,&#125; 这时候我们就可以根据不同的返回值进行不同的业务处理了 统一异常处理 我们需要统一处理系统的异常信息并让异常结果也显示为统一的返回结果对象，那么需要进行统一异常处理。 在 项目根目录/src/main/ 目录下新建一个 handler 目录，并在目录下新建一个 exception.go 文件，用于处理异常信息 exception.go 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package handlerimport ( &quot;github.com/gin-gonic/gin&quot; &quot;log&quot; &quot;net/http&quot; &quot;runtime/debug&quot; &quot;star-im/src/main/common/app&quot;)// Recover 注意 Recover 要尽量放在router.User的第一个被加载// 如不是的话，在recover前的中间件或路由，将不能被拦截到// 程序的原理是：// 1.请求进来，执行recover// 2.程序异常，抛出panic// 3.panic被 recover捕获，返回异常信息，并Abort,终止这次请求func Recover(c *gin.Context) &#123; defer func() &#123; r := recover() if r != nil &#123; //打印错误堆栈信息 log.Printf(&quot;panic: %v\\n&quot;, r) debug.PrintStack() //封装通用json返回 c.JSON(http.StatusOK, app.Response&#123; Code: app.ERROR, Msg: ErrorToString(r), Data: nil, &#125;) //终止后续接口调用，不加的话recover到异常后，还会继续执行接口里后续代码 c.Abort() &#125; &#125;() //加载完 defer recover，继续后续接口调用 c.Next()&#125;// ErrorToString recover错误，转stringfunc ErrorToString(r interface&#123;&#125;) string &#123; switch v := r.(type) &#123; case error: return v.Error() default: return r.(string) &#125;&#125; 该类主要捕获panic异常，并返回 json 信息给客户端 在 src/main/routers/router.go 文件中添加如下代码即可。 12// 统一异常处理r.Use(handler.Recover) 此时我们可以修改router中 /ping 的方法来测试结果 将 src/main/routers/router.go 中如下代码 1r.GET(&quot;/ping&quot;, api.Ping) 修改为： 12345r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; // 无意抛出 panic var slice = []int&#123;1, 2, 3, 4, 5&#125; slice[6] = 6 &#125;) 然后重启项目，通过浏览器访问 http://localhost:8081/ping，得到如下返回： 12345&#123; &quot;code&quot;:-1, &quot;msg&quot;:&quot;runtime error: index out of range [6] with length 5&quot;, &quot;data&quot;:null,&#125; 现在我们得到的就是统一的异常返回值，这里的 msg 可以根据需要再进行修改。 在业务中我们可以通过判断业务逻辑，再进行抛出异常，如将刚才函数中的内容修改为如下代码： 123456r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; // 抛出 panic, true这里可以改为自己的业务处理逻辑 if true &#123; panic(&quot;抛出了指定的异常信息&quot;) &#125;&#125;) 通过浏览器访问 http://localhost:8081/ping，得到如下返回： 12345&#123; &quot;code&quot;:-1, &quot;msg&quot;:&quot;抛出了指定的异常信息&quot;, &quot;data&quot;:null,&#125; 可以看到成功捕获了 panic 抛出的异常信息，这可以很方便我们做业务逻辑的时候处理异常。（测试成功后记得把ping的函数恢复回之前的） gin router 中也提供了针对 NoRoute 和 NoMethod 的处理，在 router.go 中添加 123// 处理404r.NoRoute(handler.HandleNotFound)r.NoMethod(handler.HandleNotFound) 在 src/main/handler/exception.go 中添加处理方法，直接返回处理结果即可 1234567891011func HandleNotFound(c *gin.Context) &#123; // 我这里使用的是统一返回值 app.ErrorWithCode(c, app.NOT_FOUND, nil) // // 你们也可以直接使用普通的返回结果，如下 // c.JSON(http.StatusOK, gin.H&#123; // &quot;msg&quot;: &quot;找不到资源&quot;, // &quot;code&quot;: 404, // &quot;data&quot;: &quot;&quot; // &#125;) return&#125; swag 接口文档 Swagger是一种API框架，它可以为REST APIs定义、生成、测试和文档化。它使用一种名为Swagger元数据的特殊格式来描述API，并使用Swagger UI来展示API的定义。这使得开发人员可以在不离开API文档的情况下测试API，并且可以轻松地为API创建文档。 我们引入 Swagger 来生成接口文档，方便统一管理接口及调试。 相关链接： GitHub 安装 1go install github.com/swaggo/swag/cmd/swag@latest 使用 1swag init -o &quot;src/main/docs&quot; -o 为 output，指定输出目录，默认为“./docs” 其他更多文章参考 GitHub中文文档 在主程序入口 main.go 中可以添加如下注释： 123456// @title Star-IM// @version 1.0// @description 即时通讯接口文档func main() &#123; ……&#125; 在 src/main/routers/api/health.go 文件中添加如下注释 123456789// Ping// @Summary 健康检查// @Description 接口连通性测试// @Tags 测试// @Success 200 &#123;object&#125; app.Response// @Router /ping [get]func Ping(c *gin.Context) &#123; ……&#125; 在 src/main/routers/router.go 加入swagger接口文档的访问，并引入指定了目录的swagger文件 代码如下： 1234567891011121314151617181920212223242526272829303132package routersimport ( &quot;github.com/gin-gonic/gin&quot; swaggerFiles &quot;github.com/swaggo/files&quot; ginSwagger &quot;github.com/swaggo/gin-swagger&quot; &quot;io&quot; &quot;os&quot; _ &quot;star-im/src/main/docs&quot; &quot;star-im/src/main/handler&quot; &quot;star-im/src/main/routers/api&quot;)// Setup 初始化路由func Setup() *gin.Engine &#123; r := gin.Default() // 记录到文件 f, _ := os.Create(&quot;gin.log&quot;) gin.DefaultWriter = io.MultiWriter(f) // 使用中间件 // 统一异常处理 r.Use(handler.Recover) // 统一日志 r.Use(gin.Logger()) // 不需要鉴权 r.GET(&quot;/ping&quot;, api.Ping) r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler)) return r&#125; 主要变更内容为 import _ &quot;star-im/src/main/docs&quot; import swaggerFiles &quot;github.com/swaggo/files&quot; import ginSwagger &quot;github.com/swaggo/gin-swagger&quot; r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler)) 测试 通过浏览器访问 http://localhost:8081/swagger/index.html#/ 可以进入到swagger 接口文档的管理界面 至此，当前目录结构为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.├── LICENSE├── README.md├── doc│ └── build│ └── 1-framwork.md├── gin.log├── go.mod├── go.sum├── main.go└── src ├── main │ ├── common │ │ └── app │ │ ├── code.go │ │ ├── msg.go │ │ └── response.go │ ├── config │ │ ├── database │ │ │ └── database.go │ │ ├── init.go │ │ └── settings │ │ └── settings.go │ ├── docs │ │ ├── docs.go │ │ ├── swagger.json │ │ └── swagger.yaml │ ├── handler │ │ └── exception.go │ ├── models │ │ └── model.go │ ├── routers │ │ ├── api │ │ │ ├── health.go │ │ │ └── v1 │ │ └── router.go │ └── util ├── resource │ └── app.yml └── test └── pkg ├── test_gin.go ├── test_gorm.go ├── test_jwt.go ├── test_redis.go └── test_viper.go","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"}]},{"title":"「Windows」Windows “因为在此系统上禁止运行脚本”解决办法","slug":"技术/windows/「Windows」Windows “因为在此系统上禁止运行脚本”解决办法","date":"2022-11-26T09:11:21.000Z","updated":"2022-12-25T14:31:30.051Z","comments":true,"path":"2022/11/26/windows-windows-because-running-scripts-on-this-system-is-disabled-solution.html","link":"","permalink":"http://blog.heyb.top/2022/11/26/windows-windows-because-running-scripts-on-this-system-is-disabled-solution.html","excerpt":"","text":"背景 最近升级了windows11，然后在系统上安装一些常用工具，遇到了如下的问题。 nrm : 无法加载文件 C:\\Users\\用户名\\AppData\\Roaming\\npm\\nrm.ps1，因为在此系统上禁止运行脚本。 解决方法 处理方案在提示中有，可以通过访问链接查看：https://go.microsoft.com/fwlink/?LinkID=135170 核心是power shell的安全策略，将 nrm 命令视为了不安全脚本，不允许执行。只需要放开权限就行。 我们通过管理员权限运行power shell，然后输入命令 1set-ExecutionPolicy RemoteSigned 选择“是”，就OK了。 如果要恢复策略则设置则执行 1set-ExecutionPolicy Default 参考 https://zhuanlan.zhihu.com/p/493496089","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Windows","slug":"技术/Windows","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Windows/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.heyb.top/tags/Windows/"}]},{"title":"「Go」Go 组件系列文章4-gin","slug":"技术/go/「Go」Go 组件系列文章4-gin","date":"2022-11-23T09:54:20.000Z","updated":"2022-12-25T14:28:59.028Z","comments":true,"path":"2022/11/23/go-go-component-series-4-gin.html","link":"","permalink":"http://blog.heyb.top/2022/11/23/go-go-component-series-4-gin.html","excerpt":"","text":"简介 Go Gin是一个用Go语言编写的HTTP Web框架。它旨在提供一个简洁而强大的方式来构建Web应用程序。它因为 httprouter 的性能提高了40倍。具有良好的性能，并且提供了许多有用的功能，例如路由，中间件，模板渲染等。它还具有很好的扩展性，可以与其他Go库和框架集成使用。 相关链接： GitHub 安装 1go get github.com/gin-gonic/gin 测试 在 项目根目录/src/test/pkg 目录下新建 test_gin.go 测试文件 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; // 默认返回一个已连接日志记录器和恢复中间件的引擎实例。 r := gin.Default() // 绑定路由 /ping，访问后执行func的方法 r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; // 返回一个 json， 状态值为 200， H的内容为 map[string] c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;pong&quot;, &#125;) &#125;) // 在0.0.0.0：8080上侦听和服务(对于Windows“为 localhost：8080”) err := r.Run() if err != nil &#123; fmt.Println(&quot;启动服务异常：&quot;, err) &#125;&#125; 通过浏览器访问：http://localhost:8081/ping 得到如下信息： 123&#123; &quot;message&quot;: &quot;pong&quot;&#125; 此时我们就已经完成了http框架的测试，官方 GitHub 文档有提供不同请求方式、参数绑定、文件上传等示例，可以参考学习。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"gin","slug":"gin","permalink":"http://blog.heyb.top/tags/gin/"}]},{"title":"「Go」Go 组件系列文章3-gorm","slug":"技术/go/「Go」Go 组件系列文章3-gorm","date":"2022-11-22T09:22:20.000Z","updated":"2022-12-25T14:28:47.622Z","comments":true,"path":"2022/11/22/go-go-component-series-3-gorm.html","link":"","permalink":"http://blog.heyb.top/2022/11/22/go-go-component-series-3-gorm.html","excerpt":"","text":"简介 GORM 是一个用于构建 Go 语言应用程序的对象关系映射（ORM）库。它可以帮助开发人员在 Go 语言项目中更轻松地使用数据库。它支持多种数据库，包括 MySQL、PostgreSQL 和 SQLite，并提供了一组简单易用的 API，可以让开发人员使用 Go 语言的结构体来描述数据库表和字段，并通过这些结构体来执行数据库操作。并支持事务、批量操作等等。和Java的hibernate框架相似。 相关链接： GitHub GORM中文网 使用 安装 要使用 gorm.io/gorm，首先需要安装它。可以使用 Go 语言的包管理工具 go mod 来安装： 12go get gorm.io/gormgo get gorm.io/driver/mysql 安装完成后，在 Go 语言项目中就可以引入 gorm 包并使用它了。首先，需要创建一个 gorm.DB 类型的变量，用于表示与数据库的连接： 123import &quot;gorm.io/gorm&quot;var db *gorm.DB 然后，使用 gorm.Open() 函数来连接到数据库： 12345db, err := gorm.Open(&quot;mysql&quot;, &quot;user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;)if err != nil &#123; panic(&quot;failed to connect database&quot;)&#125;defer db.Close() 其中 user 和password 为连接数据库的用户和密码，dbname 为库名，后面设置根据自己需求设置。 以下为完整实例： 创建数据库的步骤忽略，我们约定数据库名称为star-im，用户名和密码均为root。 在 项目根目录/src/test/pkg 目录下新建 test_gorm.go 测试文件，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( &quot;fmt&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot;)// TestProduct 定义一个实体type TestProduct struct &#123; // gorm.Model 提供了基础实体的定义，包含了id, CreatedAt, UpdatedAt, DeletedAt 字段 gorm.Model // Name 商品名称 Name string // Price 商品价格 Price uint&#125;// 测试 ORM 框架 —— 连接 MySQL https://github.com/go-gorm/gormfunc main() &#123; // 连接信息，字符串中内容分别为：用户名:密码@连接方式(Host:Port)/数据库名?字符集&amp;解析时间&amp;默认时间 // 更多参数详见：https://github.com/go-sql-driver/mysql#parameters dsn := &quot;root:root@tcp(127.0.0.1:3306)/star-im?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot; // 连接数据库，并设置基本的配置 db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;) if err != nil &#123; // 如果连接有异常则打印 fmt.Println(&quot;连接数据库失败：&quot;, err) &#125; // 迁移 schema，如果数据库该表没有则创建表 err = db.AutoMigrate(&amp;TestProduct&#123;&#125;) if err != nil &#123; fmt.Println(&quot;创建数据库表异常：&quot;, err) &#125; // Create 创建记录 // 定义实体 product := &amp;TestProduct&#123;Name: &quot;奶茶&quot;, Price: 100&#125; // 创建记录 result := db.Create(product) // 创建成功后会返回插入数据的主键给实体赋值 ID fmt.Println(&quot;ID为：&quot;, product.ID) fmt.Println(&quot;如果有异常，则会输出：&quot;, result.Error) fmt.Println(&quot;返回插入记录的条数：&quot;, result.RowsAffected) // Find 查询 prod := db.First(&amp;product, &quot;name = ?&quot;, &quot;奶茶&quot;) fmt.Println(&quot;查询数:&quot;, prod.RowsAffected) // 查找后返回实体 prod2 := TestProduct&#123;&#125; db.Where(&quot;name = ?&quot;, &quot;奶茶&quot;).First(&amp;prod2) fmt.Println(&quot;实体：&quot;, prod2) // Update - 修改 // 将 product 的 price 更新为 200 db.Model(&amp;product).Update(&quot;Price&quot;, 200) // Update - 更新多个字段 db.Model(&amp;product).Updates(TestProduct&#123;Price: 200, Name: &quot;蛋糕&quot;&#125;) // 仅更新非零值字段 db.Model(&amp;product).Updates(map[string]interface&#123;&#125;&#123;&quot;Price&quot;: 200, &quot;Name&quot;: &quot;蛋糕&quot;&#125;) // Delete - 逻辑删除 product，会修改 deleted_at，标记为删除 db.Delete(&amp;product, 1)&#125; 执行程序后在控制台输出如下结果： 12345ID为： 1如果有异常，则会输出： &lt;nil&gt;返回插入记录的条数： 1查询数: 1实体： &#123;&#123;1 2022-11-22 16:53:58.969 +0800 CST 2022-11-22 16:53:58.969 +0800 CST &#123;0001-01-01 00:00:00 +0000 UTC false&#125;&#125; 奶茶 100&#125; 其他更多操作请参考 GORM中文网 ，以及 约束、连接池 、日志 等配置可根据自身需求学习设置。我在后续过程中也会讲解并设置。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"gorm","slug":"gorm","permalink":"http://blog.heyb.top/tags/gorm/"}]},{"title":"「Go」Go 组件系列文章2-viper","slug":"技术/go/「Go」Go 组件系列文章2-viper","date":"2022-11-21T11:41:20.000Z","updated":"2022-12-25T14:28:33.077Z","comments":true,"path":"2022/11/21/go-go-component-series-2-viper.html","link":"","permalink":"http://blog.heyb.top/2022/11/21/go-go-component-series-2-viper.html","excerpt":"","text":"简介 Viper是一个完整的Go应用程序配置解决方案，可以用于读取 JSON、TOML、YAML、HCL、env file和Java properties 配置文件。可以使用简单的方法来读取和设置配置值，并且可以设置默认值和类型转换器来确保程序始终能够读取到有效的配置值。 我们通常将一些配置信息，如数据库的访问路径，端口号等存放在配置文件中方便统一修改。 在 Java 中通常为 application.yml 或者 applicatiton.properties 文件，然后在 springboot 框架下使 用 @ConfigurationProperties(prefix=”setting_name”) 或者 @Value(“valueStr”) 的形式来读取。 Viper 就是 go 用于做这一部分的工作类库 相关链接： GitHub PKG 安装 在项目中打开命令行执行如下命令 1go get github.com/spf13/viper 使用 在 项目根目录/src/resource 资源目录下新建一个 app.yml 配置文件，并写入以下配置项 1234settings: server: url: localhost port: 8081 注：我们现在约定 settings 为配置项根节点，之后新增例如 settings:database之类的节点，则是在settings下新增一个 database 节点，而不是重复设置多一个 settings。 其他新增/修改项也遵循此说法。 如在settings下新增 database 内容， 并修改 server下的端口号为9999，示例如下： 正确示例为： 123456settings: server: url: localhost port: 9999 database: type: mysql 错误示例为： 12345678910settings: server: url: localhost port: 8081 server: port: 9999settings: database: type: mysql 测试 在 项目根目录/src/test 目录下新建一个 pkg 目录，用于测试引入的第三方类库。在目录下新建 test_viper.go 测试文件 12345678910111213141516171819202122232425262728293031323334// main 方法必须使用 main 包package main// 引入依赖import ( &quot;fmt&quot; &quot;github.com/spf13/viper&quot;)// 主要执行的方法func main() &#123; // 配置文件名(不带扩展名，即 app.yml 只需要app这部分) viper.SetConfigName(&quot;app&quot;) // 如果配置文件名称中没有扩展名，则为必填项 viper.SetConfigType(&quot;yaml&quot;) // 在其中查找配置文件的路径 viper.AddConfigPath(&quot;src/resource/&quot;) // 查找并读取配置文件 err := viper.ReadInConfig() if err != nil &#123; // 处理读取配置文件时出现的错误 panic(fmt.Errorf(&quot;读取配置异常，原因为: %w&quot;, err)) &#125; // 打印内容到控制台 fmt.Println(&quot;初始化 app 配置成功&quot;) // 获取配置文件中的参数 url := viper.GetString(&quot;settings.server.url&quot;) port := viper.GetString(&quot;settings.server.port&quot;) // 打印参数 fmt.Printf(&quot;配置中的服务器地址及端口号为：%s:%s&quot;, url, port)&#125; 执行程序后在控制台输出如下结果： 12初始化 app 配置成功配置中的服务器地址及端口号为：localhost:8081","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"viper","slug":"viper","permalink":"http://blog.heyb.top/tags/viper/"}]},{"title":"「Go」Go 组件系列文章1-modules","slug":"技术/go/「Go」Go 组件系列文章1-modules","date":"2022-11-21T11:28:20.000Z","updated":"2022-12-25T14:28:00.543Z","comments":true,"path":"2022/11/21/go-go-component-series-1-modules.html","link":"","permalink":"http://blog.heyb.top/2022/11/21/go-go-component-series-1-modules.html","excerpt":"","text":"简介 模块是一组发布和版本化为单个单元的 Go 包。modules是源代码交换和版本控制的单元。go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。 go mod 是 Go 编程语言中用于管理模块依赖关系的一个命令。 go mod 允许您轻松地在 Go 项目中添加、删除和更新依赖项，以及管理依赖项的版本，以确保兼容性和可重复性。 go modules 可以理解为 maven / gradle 等工具 官方文档及介绍 使用 在使用 go mod 前，需要在项目目录下执行 go mod init &lt;name&gt; 命令来初始化模块。 例如，我们以项目 star-im 为例进行初始化，在项目根目录（star-im/）中执行 1go mod init star-im 会在根目录生成一个 go.mod 的文件来进行包依赖的管理，其中会包含我们所需要的依赖及版本内容，此外某些依赖后面会有 indirect 字样，表示该依赖为传递依赖，也就是非直接依赖。 其他命令如： 123456789go mod &lt;command&gt;download download modules to local cache -- 将模块下载到本地缓存edit edit go.mod from tools or scripts -- 从工具或脚本编辑 go.mod 以编辑依赖关系graph print module requirement graph -- 查看依赖关系图init initialize new module in current directory -- 初始化当前目录中的新模块tidy add missing and remove unused modules -- 添加缺少的模块并删除未使用的模块vendor make vendored copy of dependencies -- 制作依赖项的供应商副本verify verify dependencies have expected content -- 验证依赖项是否具有预期内容why explain why packages or modules are needed -- 解释为什么需要包或模块 比较常用的是 init, tidy, edit ，当我们引入依赖包的之后，可以使用 go mod tidy 来命令来整理依赖模块。其他更多内容可参考：go mod使用 | 全网最详细 或者参考官方文档 可以使用命令 go list -m -u all 来检查可以升级的package 依赖包仓库地址：https://pkg.go.dev/（相当于maven的 https://mvnrepository.com/），搜索需要的依赖包可以访问此链接，里面也包含了依赖包的使用事项等。 目前 go web 似乎没有比较成型的 web 开发标准，因此我沿用了 Java 的习惯 在根目录中新增 src 目录，以及 main、resource、test 三个下级目录，用于存放主要程序文件、资源设置文件、测试文件。 12345star-im └── src ├── main ├── resource └── test","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"go mod","slug":"go-mod","permalink":"http://blog.heyb.top/tags/go-mod/"}]},{"title":"「Python」Mac 系统切换Python版本","slug":"技术/python/「Python」Mac 系统切换Python版本","date":"2022-11-21T02:23:00.000Z","updated":"2022-12-25T14:31:00.631Z","comments":true,"path":"2022/11/21/python-mac-system-switches-python-version.html","link":"","permalink":"http://blog.heyb.top/2022/11/21/python-mac-system-switches-python-version.html","excerpt":"","text":"从MacOS 12.4 Beta版(21F5048e) 开始，可以通过pyenv在intel和Apple芯片中安装python2。 例如在M1中安装 2.7.18 版本的 python2。 首先在系统上安装 pyenv 12# 下载 pyenvbrew install pyenv 接下来，使用 pyenv 安装您想要使用的 Python 版本。例如，要安装 Python 2.7.18 版本，可以在终端中输入以下命令： 12# 下载指定版本pyenv install 2.7.18 安装完成后，可以使用 pyenv 的 global 命令来设置当前系统的默认 Python 版本。例如，设置默认版本为 2.7.18，可以在终端中输入以下命令： 12# 切换指定版本pyenv global 2.7.18 如果执行pyenv不生效可以手动将其加入到系统环境变量（非必须） 12# 加入到环境变量export PATH=&quot;$(pyenv root)/shims:$&#123;PATH&#125;&quot; 最后，可以通过输入 python --version 命令来检查当前使用的 Python 版本是否已经切换成功。 12# 打印python版本python --version 如果一切顺利，将可以看到Python 2.8.18的输出。 此方法可以与brew install python3方式安装的python3共存。 如果想要临时切换到其他版本的 Python，可以在执行 Python 命令时，使用 pyenv run 命令来指定要使用的 Python 版本。 例如，要在当前终端会话中临时使用 Python 3.6.5 版本，可以在终端中输入以下命令： 1pyenv run python3.6.5 如果您想要在当前目录下的所有 Python 脚本中临时使用指定的 Python 版本，可以使用 pyenv local 命令来设置当前目录的 Python 版本。 如果遇到VS(Visual Studio Code)无法使用code命令，可以参阅博文：《MacOS 12.3 无法正常使用code命令的解决方法》。 参考 brew安装python2","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"}]},{"title":"「Java」macOS切换JDK版本","slug":"技术/java/「Java」macOS切换JDK版本","date":"2022-10-25T03:59:00.000Z","updated":"2022-12-25T14:30:41.977Z","comments":true,"path":"2022/10/25/java-macos-switches-jdk-version.html","link":"","permalink":"http://blog.heyb.top/2022/10/25/java-macos-switches-jdk-version.html","excerpt":"","text":"在 Mac 系统上切换 JDK 版本，可以使用以下步骤： 使用 Finder 或其他文件管理工具，打开系统根目录（通常是 /）。 找到 Library/Java/JavaVirtualMachines 目录，该目录下存放着系统安装的所有 JDK 版本。 找到您想要使用的 JDK 版本，例如 jdk1.8.0_261.jdk。 在该 JDK 版本目录下，找到 Contents/Home 目录，该目录下存放着 JDK 安装的核心文件。 将该目录的完整路径（例如 /Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home）复制到剪贴板。 也可以通过命令打印 Java home 1/usr/libexec/java_home -V 打印如下： 12345678910horustech@Horuss-MacBook-Pro booking % /usr/libexec/java_home -VMatching Java Virtual Machines (7): 17.0.1 (x86_64) &quot;Eclipse Temurin&quot; - &quot;Eclipse Temurin 17&quot; /Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home 16.0.2 (x86_64) &quot;Amazon.com Inc.&quot; - &quot;Amazon Corretto 16&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-16.0.2/Contents/Home 15.0.2 (x86_64) &quot;Amazon.com Inc.&quot; - &quot;Amazon Corretto 15&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-15.0.2/Contents/Home 1.8.321.07 (x86_64) &quot;Oracle Corporation&quot; - &quot;Java&quot; /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home 1.8.0_312 (x86_64) &quot;Amazon&quot; - &quot;Amazon Corretto 8&quot; /Users/horustech/Library/Java/JavaVirtualMachines/corretto-1.8.0_312/Contents/Home 1.8.0_312 (x86_64) &quot;Eclipse Temurin&quot; - &quot;Eclipse Temurin 8&quot; /Library/Java/JavaVirtualMachines/temurin-8.jdk/Contents/Home 1.8.0_311 (x86_64) &quot;Oracle Corporation&quot; - &quot;Java SE 8&quot; /Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home 使用终端（Terminal）工具，执行以下命令来修改 JDK 版本： 1$ export JAVA_HOME=&lt;JDK路径&gt; 例如： 1$ export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home 或者手动编辑文件添加： 打开bash_profile文件加入JAVA_HOME 1open ~/.bash_profile 添加最后一行， export JAVA_HOME=&quot;这里填刚才的路径&quot; 执行以下命令来使修改生效： 1$ source ~/.bash_profile 执行以下命令来检查 JDK 版本是否已成功切换： 1$ java -version 如果您更改了 .bashrc 或其他配置文件，请按照实际情况进行调整。 此外，您还可以使用 alternatives 命令来管理系统中安装的 JDK 版本。该命令可以让您方便地在多个 JDK 版本之间进行切换，并且可以保证系统中只有一个默认的 JDK 版本。如果您想要了解更多关于 alternatives 命令的信息，可以在终端中执行 man alternatives 命令查看相关帮助文档。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Java","slug":"技术/Java","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Java/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Java","slug":"Java","permalink":"http://blog.heyb.top/tags/Java/"}]},{"title":"「Python」PPT 转 Markdown","slug":"技术/python/「Python」PPT 转 Markdown","date":"2022-10-21T09:11:21.000Z","updated":"2022-12-25T14:31:13.060Z","comments":true,"path":"2022/10/21/[python]-ppt-to-markdown.html","link":"","permalink":"http://blog.heyb.top/2022/10/21/[python]-ppt-to-markdown.html","excerpt":"","text":"背景 最近在学习学科类课程，教师提供的课件都是PPT的形式。我自己想整理转成Markdown就需要一个个ppt去复制里面的文本，在洗澡的时候就想着能不能直接通过脚本来一键转换，然后搜了一下类库就开始操作。 开始 我检索到当前比较适合的类库——python-pptx 以下是相关网站 PYPI Github 官方文档 官方文档示例 从官方文档可以找到到获取文本的示例：官方文档 123456789101112131415161718192021222324252627# Extract all text from slides in presentation# 从演示文稿中的幻灯片中提取所有文本from pptx import Presentation# 打开 pptprs = Presentation(path_to_presentation)# text_runs will be populated with a list of strings,# one for each text run in presentationtext_runs = []# 获取 Slide 幻灯片for slide in prs.slides: # 获取形状 Shape for shape in slide.shapes: # 判断是否有文字框 text_frame if not shape.has_text_frame: continue # 获取文字框中的段落 paragraphs for paragraph in shape.text_frame.paragraphs: # 文字块 run for run in paragraph.runs: # 获取文字并加到字符串数组中 text_runs.append(run.text) # 打印测试结果 print(text_runs) 思路 创建 result 结果列表，最后我们会将全部信息存储到 result 列表中，并写入一个 md 文档当中。 ppt这个库的逻辑是逐页（page）读取每个形状（shape） 我们的程序是首先判断遇到的形状是否是文本框，如果是文本框的话，直接将全部文本信息写入results。 如果不是文本框的话再判断这个形状是不是图片对象。如果是的话，新建一个文件夹，将这个图片存储到这个文件夹中。最后将存储到本地的图片的存储路径标准化为markdown格式写入results内。 完整代码 单ppt文件转换markdown 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import collections.abc# 此处是用的是python-pptx 包# pip3 install python-pptxfrom pptx import Presentation# 操作系统（用于生产文件）import os# 正则匹配import re# PPT 文件相对路径 filepathfilepath = &quot;这里写入 ppt 的路径名称.pptx&quot;# 文件名（截取文件名开头至文件名末尾倒数 5 位）file_name = filepath[:-5]# 实例化ppt对象prs = Presentation(filepath)# 结果文本数组results = []# 获取 Slide 幻灯片for slide in prs.slides: # 获取形状 Shape for shape in slide.shapes: # 判断是否有文字框 text_frame if shape.has_text_frame: # 获取文字框中的段落 paragraphs for paragraph in shape.text_frame.paragraphs: part = [] # 文字块 run for run in paragraph.runs: text = run.text # 如果匹配 第x章，则设置为主标题 # 第一章 if re.search(&#x27;第.+章&#x27;, text): text = &#x27;# &#x27; + text # 如果匹配 一、二、三、之类的，则设置为副标题 # 一、 elif re.search(&#x27;[一二三四五六七八九十]+、&#x27;, text): text = &#x27;## &#x27; + text # 如果匹配格式为数字+小数点，类似 1.1.1 elif re.search(&#x27;\\d\\.&#x27;, text): # 则设置副标题 例如 #### 1.1.1 text = (&#x27;#&#x27; * (text.count(&#x27;.&#x27;) + 2)) + &#x27; &#x27; + text # 获取文字块并加到字符串数组中 part.append(text) results.append(&#x27;&#x27;.join(part)) # 否则判断是否为图片 else: try: imdata = shape.image.blob # 判断文件后缀类型 imagetype = shape.image.content_type typekey = imagetype.find(&#x27;/&#x27;) + 1 imtype = imagetype[typekey:] # 创建image文件夹保存抽出图片 path = &quot;图片文件夹/&#123;&#125;_image/&quot;.format(file_name) if not os.path.exists(path): os.makedirs(path) # 图片生成 image_file = path + shape.name + &quot;.&quot; + imtype name = shape.name file_str = open(image_file, &#x27;wb&#x27;) file_str.write(imdata) file_str.close() # 标准化为markdown图片格式 results.append(&#x27;![&#123;&#125;](&#123;&#125;)&#x27;.format(name, image_file)) except: pass# 去掉多余空格results = [line for line in results if line.strip()]# 写入全部results信息with open(&#x27;&#123;&#125;.md&#x27;.format(file_name), &#x27;w&#x27;) as f: f.write(&#x27;\\n&#x27;.join(results)) 如果批量操作，只需要循环目录下的文件进行操作即可 指定目录下面所有ppt转换markdown 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import collections.abc# 此处是用的是python-pptx 包# pip3 install python-pptxfrom pptx import Presentation# 操作系统（用于生产文件）import os# 正则匹配import re# 目录dir = &#x27;./课件&#x27;# 遍历目录下面的文件item = os.listdir(dir)# 遍历文件for file in item: # 如果文件名包含.pptx 则执行转换代码 if &#x27;.pptx&#x27; in file: # PPT 文件相对路径 filepath filepath = dir + &#x27;/&#x27; + file # 文件名（截取文件名开头至文件名末尾倒数 5 位） file_name = filepath[:-5] # 实例化ppt对象 prs = Presentation(filepath) # 结果文本数组 results = [] # 获取 Slide 幻灯片 for slide in prs.slides: # 获取形状 Shape for shape in slide.shapes: # 判断是否有文字框 text_frame if shape.has_text_frame: # 获取文字框中的段落 paragraphs for paragraph in shape.text_frame.paragraphs: part = [] # 文字块 run for run in paragraph.runs: text = run.text # 如果匹配 第x章，则设置为主标题 # 第一章 if re.search(&#x27;第.+章&#x27;, text): text = &#x27;# &#x27; + text # 如果匹配 一、二、三、之类的，则设置为副标题 # 一、 elif re.search(&#x27;[一二三四五六七八九十]+、&#x27;, text): text = &#x27;## &#x27; + text # 如果匹配格式为数字+小数点，类似 1.1.1 elif re.search(&#x27;\\d\\.&#x27;, text): # 则设置副标题 例如 #### 1.1.1 text = (&#x27;#&#x27; * (text.count(&#x27;.&#x27;) + 2)) + &#x27; &#x27; + text # 获取文字块并加到字符串数组中 part.append(text) results.append(&#x27;&#x27;.join(part)) # 否则判断是否为图片 else: try: imdata = shape.image.blob # 判断文件后缀类型 imagetype = shape.image.content_type typekey = imagetype.find(&#x27;/&#x27;) + 1 imtype = imagetype[typekey:] # 创建image文件夹保存抽出图片 path = &quot;图片文件夹/&#123;&#125;_image/&quot;.format(file_name) if not os.path.exists(path): os.makedirs(path) # 图片生成 image_file = path + shape.name + &quot;.&quot; + imtype name = shape.name file_str = open(image_file, &#x27;wb&#x27;) file_str.write(imdata) file_str.close() # 标准化为markdown图片格式 results.append(&#x27;![&#123;&#125;](&#123;&#125;)&#x27;.format(name, image_file)) except: pass # 去掉多余空格 results = [line for line in results if line.strip()] # 写入全部results信息 with open(&#x27;&#123;&#125;.md&#x27;.format(file_name), &#x27;w&#x27;) as f: f.write(&#x27;\\n&#x27;.join(results)) 更好的做法是将转换的代码抽离成一个函数，提供调用，这里不做展开，欢迎自己探索。 异常 如果运行代码出现 AttributeError: module 'collections' has no attribute 'abc’ 异常 123456789101112131415161718192021Traceback (most recent call last): File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/compat/__init__.py&quot;, line 10, in &lt;module&gt; Container = collections.abc.ContainerAttributeError: module &#x27;collections&#x27; has no attribute &#x27;abc&#x27;During handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;/Users/用户名/workspace/python/smallScript/office/ppt2markdown.py&quot;, line 3, in &lt;module&gt; from pptx import Presentation File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/__init__.py&quot;, line 14, in &lt;module&gt; from pptx.api import Presentation # noqa File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/api.py&quot;, line 15, in &lt;module&gt; from .package import Package File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/package.py&quot;, line 6, in &lt;module&gt; from pptx.opc.package import OpcPackage File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/opc/package.py&quot;, line 11, in &lt;module&gt; from pptx.compat import is_string, Mapping File &quot;/Users/用户名/.local/share/virtualenvs/smallScript-RtozSf8y/lib/python3.10/site-packages/pptx/compat/__init__.py&quot;, line 14, in &lt;module&gt; Container = collections.ContainerAttributeError: module &#x27;collections&#x27; has no attribute &#x27;Container&#x27; 则在python文件前引入依赖 import collections.abc 即可 参考 官方文档 看完这篇Python操作PPT总结，从此使用Python玩转Office全家桶就没有压力了！ 【python自动化】读取ppt内全部文本和图片信息并导出markdown文档","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"},{"name":"PPT","slug":"PPT","permalink":"http://blog.heyb.top/tags/PPT/"}]},{"title":"「Docker」Docker 安装 SQL Server2019","slug":"技术/容器/docker/「Docker」Docker 安装 SQL Server2019","date":"2022-10-20T15:18:10.000Z","updated":"2022-12-25T14:32:18.874Z","comments":true,"path":"2022/10/20/[docker]-docker-installation-sql-server-2019.html","link":"","permalink":"http://blog.heyb.top/2022/10/20/[docker]-docker-installation-sql-server-2019.html","excerpt":"","text":"安装 在其他分发 Docker Hub 上的 Linux 容器映像 中可以参考更多的Docker安装的内容 当前稳定版本为 2019， 预览版为 2022，这里我们使用稳定版本。 可以在 Docker 命令行界面中输入以下命令来拉取 SQL Server 2019 的镜像 1docker pull mcr.microsoft.com/mssql/server:2019-latest 这条命令会从 Microsoft 的官方镜像仓库中拉取最新版本的 SQL Server 2019 镜像 启动 拉取完成后，您可以使用以下命令来创建运行 SQL Server 2019 容器，这里密码必须为复杂密码（建议大小写英文+数字+特殊符号，这里举例为 @Password），否则无法启动。 -p 为映射端口，这里默认为 1433，可以自行修改 1docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=@Password&quot; -p 1433:1433 -d mcr.microsoft.com/mssql/server:2019-latest 这条命令会在 Docker 中运行一个 SQL Server 2019 容器，并且会把容器的 1433 端口映射到主机的 1433 端口上。然后你就可以使用预设的用户名sa，密码@Password 进行登录 此外，还有一些额外的步骤，你可以在 SQL Server 的 Docker 容器中执行。例如，你可以使用 Docker 命令行工具来进入容器，并在其中执行各种 SQL 脚本。有关更多信息，建议你参阅 Docker 官方文档。 参考 官方文档：https://www.microsoft.com/zh-cn/evalcenter/evaluate-sql-server-2019?filetype=EXE","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"技术/容器","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"技术/容器/Docker","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"容器","slug":"容器","permalink":"http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.heyb.top/tags/Docker/"}]},{"title":"「Hexo」1-使用Hexo搭建个人博客","slug":"写作/hexo/「Hexo」1-使用Hexo搭建个人博客","date":"2022-09-09T16:00:00.000Z","updated":"2022-12-06T05:11:40.626Z","comments":true,"path":"2022/09/10/hexo-1---use-hexo-to-build-a-personal-blog.html","link":"","permalink":"http://blog.heyb.top/2022/09/10/hexo-1---use-hexo-to-build-a-personal-blog.html","excerpt":"","text":"前言 如首篇文章所说的，在很久之前我就想搭建自己的个人博客网站，以前在 csdn 的博客不知道为啥就被封禁了，懒得去申诉了。我也有想过自己开发一个，但是奈何审美水平不高，做一个好的前端页面自觉要花费很多功夫，搭建完成之后还要购买服务器来进行维护，都是比较耗费尽力的，后来找了一轮相关的资料，就找到 Hexo 这个博客的框架。觉得各方面都比较符合我的期望，下面会做一些入门的介绍。 什么是Hexo Hexo 是是一个快速、简洁且高效的静态博客框架，基于 Node.js 渲染，支持 Markdown 语法且能通过命令行一键部署到 github、heroku、coding 等网站。拥有免费且丰富的主题和插件，可以让你轻松定制你的博客网站。还阿提供了方便的命令行工具，可以帮助你快速搭建、生成和部署你的博客网站。此外文章的本体可以留存在本地备份随时修改。这一点是我比较喜欢的。 官方网站：https://hexo.io/zh-cn/ Github: https://github.com/hexojs/hexo 优点和不足 Hexo 的优点如下： 免费；轻量 基于 Node.js，易于安装和使用。 支持 Markdown 语法，使写作更加简单。 提供丰富的插件和主题，让你可以轻松定制你的博客。 提供方便的命令行工具，可以快速搭建、生成和部署你的博客网站。 原文内容在本地，迁移方便； Hexo 的缺点如下： 依赖本地环境，不太适用于不同设备上随心发布； 只支持静态网站，不支持动态网站。 对于复杂的网站，可能不太适用。 在某些情况下，它的性能可能不如其他静态网站生成器。 相对于其他类似工具，它的社区支持可能不太完善。 安装前置环境 安装前提： Github | Gitee| Coding ：资源/代码存放的仓库，目前他们均提供了相关的 pages —— 一种免费的静态站点托管服务，让我们可以在仓库里托管和发布自己的静态网站页面。 Nodejs ：Hexo 是基于 Node.js 平台开发的，所以你需要先安装 Node.js。（Node 各系统安装教程：【NODE】NODE.JS 安装配置(转)） ，建议使用 Node.js 12.0 及以上版本 Git：Hexo 使用 Git 来管理项目，将本地的 Hexo 内容提交到 Github 上去 如果你没有安装这些前置环境，建议你参阅官方文档，了解如何在你的系统上安装这些软件。 准备 Github Pages 仓库 注册Github帐号 已经有Github帐号跳过此步，首先进入Github进行注册，用户名、邮箱和密码之后都需要用到，自己记好。 在 Shell 中本地全局设置用户名和邮箱 12git config --global user.name &quot;GitHub 用户名&quot;git config --global user.email &quot;GitHub 邮箱&quot; 创建 SSH 密钥 在 Shell 中运行以下命令并多次回车 1ssh-keygen -t rsa -C &quot;Github 邮箱&quot; 然后键入以下指令： 1ssh-agent -s 出现echo Agent pid xxxxx; 继续输入指令： 1ssh-add ~/.ssh/id_rsa 如果提示错误：Could not open a connection to your authentication agent.则输入以下指令： 12eval &#x27;ssh-agent -s&#x27;ssh-add 会出现如：Identity added: /c/Users/用户/.ssh/id_rsa (/c/users/用户/.ssh/id_rsa) 到了这一步，就可以添加SSH key到你的Github账户了。输入以下指令，拷贝Key（或者进入 [C:\\Users\\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。)： 1clip &lt; ~/.ssh/id_rsa.pub 然后到Github里面，点击右上角个人头像——Settings，在左边菜单栏找到SSH and GPG keys，点击New SSH key，Title 随便命名，Key就粘贴上刚才复制的key，然后点Add SSH key，最后会让你重新输入下gitHub的密码即可 添加完成之后在自己电脑上执行 shell 命令进行测试 1ssh -T git@github.com 可能会看到有警告，没事，输入“yes”就好 出现类似：Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.就表示SSH配置好了 创建repository repository相当于一个仓库，用来放置你的代码文件。首先，登陆进入Github，并进入个人页面——右上角自己的头像 —— Your repositories，然后选择Repositories，点击New，新建一个repository 创建时，只需要填写Repository name即可，这个名字的格式必须为 [你的github名称].github.io，例如我的为biuhe.github.io，点击Create repository 即可创建 安装 Hexo 安装好 Node 之后，输入安装 hexo 命令： 1npm install -g hexo 安装完成后，在自己选定的文件夹下（如 D:\\Hexo），执行以下指令 1hexo init &lt;blog-name&gt; Hexo 会进行初始化，在目标文件夹建立博客所需要的文件，随后我们安装依赖包： 1npm install 就已经安装好了，我们可以通过 hexo help (或者 hexo h )来查看 hexo 支持的命令 以下为常用命令： 12345678hexo help # 帮助hexo new &quot;文章名称&quot; # 新建文章hexo new page &quot;页面名称&quot; # 新建页面hexo g # 完整命令为 hexo generate，用于生成静态文件hexo d # 完整命令为 hexo deploy，用于将本地文件发布到 github 上hexo s # 完整命令为 hexo server，用于启动服务器，主要用来本地预览hexo n # 完整命令为 hexo new，用于新建一篇文章hexo clean # 清楚缓存文件等 你可以使用以下命令启动本地服务器，浏览并预览你的博客： 1hexo s 然后用浏览器访问 http://localhost:4000 就可以在本地预览到博客内容了，hexo3.0使用的默认主题是landscape。 如果页面无法加载可能是端口被占用了，可以先在刚才命令窗口Ctrl+C 关闭服务器，使用 hexo server -p 端口号 ，如hexo server -p 5000 指定运行端口为 5000， 然后通过 http://localhost:5000进行访问 Hexo 博客目录文件结构如下： 12345678910.├── _config.yml # 网站配置信息├── db.json # 数据├── node_modules # node下载的依赖模块（npm install生成的）├── package-lock.json # 锁定 node 安装模块的版本号├── package.json # node 依赖模块信息├── public # 网站文件├── scaffolds # 模板文件├── source # 用户资源（存放markdown文档）└── themes # 主题 部署github 编辑刚才创建的hexo目录下的 _config.yml 文件，在 _config.yml 最下方，添加如下配置(命令中的第一个biuhe为Github的用户名，第二个biuhe为之前New的Repository的名字，记得改成自己的。另外记得一点，hexo的配置文件中任何冒号后面都是带一个空格的，否则会出现异常：ERROR Deployer not found : github） 详细可参考：https://hexo.io/docs/one-command-deployment 1234deploy: type: git repo: github: git@github.com:biuhe/biuhe.github.io.git,master 配置 _config.yml 并保存，执行以下命令部署到Github上。 首选生成静态网页。如果你想要将你的博客部署到网站上，你需要生成静态网页。你可以使用以下命令生成静态网页 1hexo g 在通过 deploy 命令部署到网站 1hexo d 如果执行hexo d命令报下名错：ERROR Deployer not found: git 就需要安装一下 hexo-deployer-git 这个模块： 1npm install hexo-deployer-git --save 安装好了继续执行hexo d部署命令，输入 github 的账号密码，就可以访问了。我的是： biuhe.github.io 发表一篇文章 1.在Git Bash执行命令： 1hexo new &quot;my new post&quot; 2.在创建的hexo目录下source/_posts 文件中打开 my-new-post.md 1234567title: my new post #可以改成中文的，如“新文章”date: 2016-02-21 16:04:09 #发表日期，一般不改动categories: blog #文章文类tags: [文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上&lt;!--more--&gt;，在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，你可以使用 hexo g 生成静态文件。 hexo s 在本地预览效果 hexo d 同步到 github，然后使用http://github用户名.github.io 进行访问 总结 到这里，就算初步搭好了一个属于自己的独立博客，后续就是本地写文章然后部署最后发布就行。当然这只是最基本的流程，hexo提供了许多好看的主题，后续会进行讲解。 参考 本文摘自：嘟嘟独立 官方中文文档：https://hexo.io/zh-cn/docs/","categories":[{"name":"写作","slug":"写作","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/"},{"name":"博客","slug":"写作/博客","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"写作/博客/Hexo","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://blog.heyb.top/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.heyb.top/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.heyb.top/tags/Hexo/"}]},{"title":"「Node」Node.js 版本管理升降级","slug":"技术/node/「Node」Node.js 版本管理升降级","date":"2022-08-19T10:04:23.000Z","updated":"2023-06-23T23:58:25.881Z","comments":true,"path":"2022/08/19/node.-js-version-management-upgrade.html","link":"","permalink":"http://blog.heyb.top/2022/08/19/node.-js-version-management-upgrade.html","excerpt":"","text":"背景 因为 Node 版本不兼容，导致 npm install 或者 npm run dev 等操作报错。因此我们需要降级或者使用指定版本的 Node。 版本管理模块 N N 是一个轻量级的 Node.js 版本管理工具。它可以让开发人员快速地安装、切换和卸载不同版本的 Node.js。 安装 Node 版本管理模块 1npm install -g n 安装完成后，可以使用以下命令来查看可用的 Node.js 版本： 1n ls 要安装指定版本的 Node.js，可以使用以下命令： 1n &lt;version&gt; 其中，&lt;version&gt; 是要安装的 Node.js 版本。例如，要安装最新的 LTS 版本的 Node.js，可以使用以下命令： 1n lts 安装完成后，可以使用以下命令来切换到指定版本的 Node.js： 1n use &lt;version&gt; 其中，&lt;version&gt; 是要切换到的 Node.js 版本。 需要注意的是，N 工具并不会自动切换到新安装的 Node.js 版本，需要手动运行 n use 命令来切换到新版本。 此外，N 还提供了其他实用的命令，例如可以使用 n rm 命令来卸载指定版本的 Node.js，使用 n latest 命令来安装最新版本的 Node.js 等。可以使用 n --help 命令来查看所有可用的命令。 版本管理工具 NVM （推荐） nvm （Node Version Manager）是 Node.js 版本管理器，允许通过命令行快速安装和使用不同版本的节点 github: https://github.com/nvm-sh/nvm 详细内容建议通过官方 readme.md 文档来进行学习 Windows github: https://github.com/coreybutler/nvm-windows 下载地址到发布页进行下载 exe 结尾的安装程序进行安装：https://github.com/coreybutler/nvm-windows/releases macOS 推荐使用 brew 进行下载管理 安装 1brew install nvm 在安装完成后，可以使用以下命令来安装指定版本的 Node.js： 1nvm install &lt;version&gt; 其中，&lt;version&gt; 是要安装的 Node.js 版本。 如果安装成功仍然无法执行，则配置环境变量 1echo &quot;source $(brew --prefix nvm)/nvm.sh&quot; &gt;&gt; .bash_profile; 使环境变量生效 1~/.bash_profile 要安装最新的 LTS 版本的 Node.js，可以使用以下命令： 1nvm install --lts 安装完成后，可以使用以下命令来切换到指定版本的 Node.js： 1nvm use &lt;version&gt; 其中，&lt;version&gt; 是要切换到的 Node.js 版本。如 nvm use 12.13.0 即可安装指定版本 需要注意的是，在使用 nvm 安装的某个版本的 Node.js 时，需要在终端中运行 nvm 命令来切换到该版本。如果不运行 nvm 命令，则终端默认使用系统中默认安装的 Node.js 版本。 NVM 其他命令 123456789101112131415161718192021nvm list 是查找本电脑上所有的node版本 - nvm list 查看已经安装的版本 - nvm list installed 查看已经安装的版本 - nvm list available 查看网络可以安装的版本nvm install &lt;version&gt; 安装指定版本nodenvm use &lt;version&gt; 切换使用指定的版本nodenvm ls 列出所有版本nvm current显示当前版本nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包nvm on 打开nodejs控制nvm off 关闭nodejs控制nvm proxy 查看设置与代理nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.nvm uninstall &lt;version&gt; 卸载制定的版本nvm use [version] [arch] 切换制定的node版本和位数nvm root [path] 设置和查看root路径nvm version 查看当前的版本 把nvm下载配置成国内镜像 打开终端输入以下代码，根据你的终端选择 ~/.bash_profile 或 ~/.zshrc 输入以下环境配置，修改镜像为淘宝源 1echo &#x27;export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node&#x27; &gt;&gt; ~/.zshrc 执行以下命令，使其生效 source ~/.bash_profile或 source ~/.zshrc","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"技术/前端/Node","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Node/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.heyb.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"Node","permalink":"http://blog.heyb.top/tags/Node/"},{"name":"NVM","slug":"NVM","permalink":"http://blog.heyb.top/tags/NVM/"}]},{"title":"「Go」解决go编译出现timeout的问题","slug":"技术/go/「Go」解决go编译出现timeout的问题","date":"2022-08-15T15:12:31.000Z","updated":"2022-12-25T14:27:44.003Z","comments":true,"path":"2022/08/15/go-solves-the-timeout-problem-in-go-compilation.html","link":"","permalink":"http://blog.heyb.top/2022/08/15/go-solves-the-timeout-problem-in-go-compilation.html","excerpt":"","text":"背景 Go 编译时无法连接其网站，有如以下报错： Windows的报错 12go: downloading github.com/xiecat/xhttp v0.0.0-20220117022559-2545617efd91main.go:8:2: github.com/kataras/golog@v0.1.7: Get &quot;https://proxy.golang.org/github.com/kataras/golog/@v/v0.1.7.zip&quot;: dial tcp 172.217.163.49:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond Linux的报错 1main.go:8:2: github.com/kataras/golog@v0.1.7: Get &quot;https://proxy.golang.org/github.com/kataras/golog/@v/v0.1.7.zip&quot;: dial tcp 172.217.160.113:443: i/o timeout 解决办法 Windows 10 设置国内代理地址 12set GOPROXY=https://goproxy.cnset GO111MODULE=on Linux &amp; ubuntu 设置代理 1go env -w GOPROXY=https://goproxy.cn 先执行上面的命令，然后再重新执行编译命令就行了。 参考 https://www.sssins.com/2022/08/14/37991.html","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"}]},{"title":"「Go」Golang","slug":"技术/go/「Go」Golang","date":"2022-08-14T09:11:21.000Z","updated":"2022-12-25T14:35:39.965Z","comments":true,"path":"2022/08/14/「go」golang.html","link":"","permalink":"http://blog.heyb.top/2022/08/14/%E3%80%8Cgo%E3%80%8Dgolang.html","excerpt":"","text":"简介 Go 是一种开源的编程语言，它由 Google 公司的工程师们在 2007 年提出，并在 2009 年开源。Go 是一种静态类型、编译型、并发型的语言。 Go 的主要目标是提供一种简单、可扩展、快速、可靠的编程语言，它既适用于大型项目，也适用于小型项目。Go 语言的设计目标是让程序员快速开发出高质量的程序，同时也能使这些程序运行得更快。 Go 语言提供了丰富的内置类型、结构体、接口、函数等 如果你想学习 Go 语言，下面是一些建议： 首先，你应该去 Go 语言官网（https://golang.org/）下载并安装 Go 语言的开发工具。Go 语言官网还提供了完整的 Go 语言文档，可以作为参考手册。 然后，你可以通过学习 Go 语言的官方教程（https://tour.golang.org/）来了解 Go 语言的基本语法和用法。这个教程提供了许多在线实例，可以让你在线实时编写和执行 Go 代码。 在学习完基本语法后，你可以阅读 Go 语言官方文档（https://golang.org/doc/）中的“Effective Go”一章，了解 Go 语言的设计哲学和编码规范。 随后，你可以阅读 Go 语言官方文档中的其他章节，了解 Go 语言的标准库、工具和其他特性。 最后，你可以在网上搜索 Go 语言的相关书籍和教程，找到适合你的学习方式 特点 静态类型：Go 语言是一种静态类型语言，它的类型系统严格，能够检查出许多类型错误。 并发型：Go 语言提供了丰富的并发模型，原生支持并发编程，提供了 goroutine 和 channel，可以方便地编写多核、高并发的程序。 简单易学：Go 语言的语法简单易懂，可以轻松上手，适合初学者。 编译速度快：Go 语言的编译速度快，生成的可执行文件体积小，可以提高开发效率。 内存管理好：Go 语言内置了垃圾回收机制，可以自动管理内存，避免内存泄漏问题。 功能强大的标准库：Go 语言拥有丰富的标准库，可以方便地实现常见的功能。 支持多种操作系统：Go 语言可以运行在多种操作系统上，包括 Windows、Mac OS、Linux 等。 缺点 异常处理不够完善：Go 语言的异常处理机制不够完善，不能像其他语言那样抛出和捕获异常。 运行速度不够快：Go 语言的运行速度不如 C++ 和 Java 等其他语言。 编译速度慢：Go 的编译速度相对于其他语言比较慢，这对于快速迭代和开发来说不太方便。 文档与社区支持不足：Go 的文档和社区支持相对于其他流行的语言来说还不够完善，第三方函数库暂时没有主流编程语言多 单进程限制：Go 语言默认的是单进程，如果需要多进程的话，需要手动编写代码来实现。 数据类型与类型转换限制：Go 语言在数据类型和类型转换方面比较严格，不太适合大型项目开发。 静态类型语言限制：Go 语言是一门静态类型语言，这对于一些动态语言的程序员来说不太习惯。 对于并发编程的限制：Go 语言的并发模型相对于其他语言来说比较特殊，不太适合熟悉其他语言的程序员。 安装与下载 其他系统版本参考官方链接进行下载安装：https://go.dev/doc/install 无法访问的用户可以通过中文网的下载地址进行安装：https://studygolang.com/dl Linux 下需要设置 4 个环境变量：GoRoot、GoPath、GoBin及Path 到profile文件中（~/.bash_profile（单一用户）或/etc/profile（所有用户）） GOROOT：该环境变量的值应该为Go语言的当前安装目录,例如: export GOROOT =/usr/local/go GOPATH：该环境变量的值应该为Go语言的工作区的集合，例如： export GOPATH=~/golib:~/goproject GOBIN：它的值应该是你想存放Go程序的可执行文件的目录，例如： export GOBIN=~/gobin PATH：为了方便使用Go语言命令和Go程序的可执行文件，需要追加其值，如： export PATH=$PATH:$GOROOT/bin:$GOBIN 然后通过source 命令使文件生效，如source ~/.bash_profile macOS 下可使用brew 安装 超找 go 1brew search go 下载安装指定版本 1brew install go@1.19 查看安装版本验证安装结果 1go version 设置模块代理 参考 https://goproxy.cn/ macOS 或 Linux 12export GO111MODULE=onexport GOPROXY=https://goproxy.cn Windows 打开你的 PowerShell 并执行 12$env:GO111MODULE = &quot;on&quot;$env:GOPROXY = &quot;https://goproxy.cn&quot; 编写 新建一个 .go 结尾的文件 写入一下内容 helloworld.go 1234567891011121314// 声明文件所在包，每个 go 文件必须有归属的包package main// 引入程序中需要用到的包，以使用包中的函数/方法，例如 Println()import ( &quot;fmt&quot;)// 主函数 程序入口func main() &#123; // 含有格式化输出、接收输入的函数 // 在控制台中输出一句话，双引号中的内容（字符串）会原样输出 fmt.Println(&quot;Hello World&quot;) &#125; 编译 &amp; 执行 在go文件目录下打开命令行执行以下命令即可编译成可执行的二进制文件 1go build 此外，在不同平台环境中编译其他平台命令如下： macOS Mac下编译Linux, Windows平台的64位可执行程序 Linux 1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build helloworld.go Windows 1CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build helloworld.go Linux Linux下编译Mac, Windows平台的64位可执行程序 macOS 1CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build helloworld.go Windows 1CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build helloworld.go Windows Windows下编译Mac, Linux平台的64位可执行程序 macOS 1234SET CGO_ENABLED=0SET GOOS=darwin3SET GOARCH=amd64go build helloworld.go Linux 1234SET CGO_ENABLED=0SET GOOS=linuxSET GOARCH=amd64go build helloworld.go 语义如下： GOOS：目标可执行程序运行操作系统，支持 darwin，freebsd，linux，windows GOARCH：目标可执行程序操作系统构架，包括 386，amd64，arm 执行 也可以通过 go run helloworld.go 来直接编译运行 基本语法 变量定义：在 Go 语言中，变量需要在使用前进行定义。变量定义的语法格式为：var variable_name type。例如： 123Copy codevar name stringvar age int 常量定义：Go 语言支持常量定义，常量的值在程序运行期间不能被改变。常量定义的语法格式为：const constant_name = value。例如： 12Copy codeconst Pi = 3.14 运算符：Go 语言支持常见的算数、关系和逻辑运算符。例如，加法运算符为 +，减法运算符为 -，小于运算符为 &lt; 等。 控制语句：Go 语言支持常见的控制语句，包括 if、else、for、switch 等。例如，if 语句的语法格式为： 1234Copy codeif condition &#123; // code to be executed if condition is true&#125; 函数：Go 语言支持函数定义和调用。函数定义的语法格式为： 12345Copy codefunc function_name(parameter1 type1, parameter2 type2) return_type &#123; // code to be executed return value&#125; 函数调用的语法格式为： 12Copy codefunction_name(parameter1, parameter2) 下面是一个简单的Go语言程序，它演示了一些基础语法的用法： 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; // 定义一个变量 var a int = 10 var b int = 20 // 使用if语句 if a &lt; b &#123; // 使用fmt包的Println函数 fmt.Println(&quot;a is less than b&quot;) &#125; // 使用for循环 for i := 0; i &lt; 5; i++ &#123; fmt.Println(i) &#125; // 定义一个函数 func add(x int, y int) int &#123; return x + y &#125; // 调用函数 result := add(a, b) fmt.Println(result)&#125; 上面的程序定义了两个变量a和b，并使用if语句来比较它们的值。它还使用了for循环来打印一些数字，定义了一个函数来计算两个数的和，并调用了这个函数。 其他更多内容请参考网站进行扩展学习 参考 官网 Go语言中文网 Go语言圣经 Go语言高级编程 菜鸟教程网（推荐）","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"}]},{"title":"「Node」Node.js 安装配置","slug":"技术/node/「Node」Node.js 安装配置","date":"2022-08-11T16:00:00.000Z","updated":"2022-12-25T14:23:03.746Z","comments":true,"path":"2022/08/12/node-node.js-installation-configuration.html","link":"","permalink":"http://blog.heyb.top/2022/08/12/node-node.js-installation-configuration.html","excerpt":"","text":"本文摘自：https://www.runoob.com/nodejs/nodejs-install-setup.html 本章节我们将向大家介绍在 Windows 和 Linux 上安装 Node.js 的方法。 本安装教程以 Node.js v4.4.3 LTS(长期支持版本)版本为例。 Node.js 安装包及源码下载地址为：https://nodejs.org/en/download/。 你可以根据不同平台系统选择你需要的 Node.js 安装包。 Node.js 历史版本下载地址：https://nodejs.org/dist/ **注意：**Linux 上安装 Node.js 需要安装 Python 2.6 或 2.7 ，不建议安装 Python 3.0 以上版本。 Windows 上安装 Node.js 你可以采用以下两种方式来安装。 1、Windows 安装包(.msi) 32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi 64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi 本文实例以 v0.10.26 版本为例，其他版本类似， 安装步骤： 步骤 1 : 双击下载后的安装包 v0.10.26，如下所示： 步骤 2 : 点击以上的Run(运行)，将出现如下界面： 步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮 : 步骤 4 : Node.js默认安装目录为 &quot;C:\\Program Files\\nodejs&quot; , 你可以修改目录，并点击 next（下一步）： 步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步） 步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）： 安装过程： 点击 Finish（完成）按钮退出安装向导。 检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入&quot;cmd&quot; =&gt; 输入命令&quot;path&quot;，输出如下结果： 12345PATH=C:\\oraclexe\\app\\oracle\\product\\10.2.0\\server\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;c:\\python32\\python;C:\\MinGW\\bin;C:\\Program Files\\GTK2-Runtime\\lib;C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin;C:\\Program Files\\nodejs\\;C:\\Users\\rg\\AppData\\Roaming\\npm 我们可以看到环境变量中已经包含了C:\\Program Files\\nodejs\\ 检查Node.js版本，执行node --version 得到版本号如： v0.10.26 如果你获得以上输出结果，说明你已经成功安装了Node.js 2、Windows 二进制文件 (.exe)安装 32 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/node.exe 64 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/x64/node.exe 安装步骤 步骤 1 : 双击下载的安装包 Node.exe ，将出现如下界面 : 点击 Run（运行）按钮将出现命令行窗口： 版本测试 进入 node.exe 所在的目录，如下所示： 执行node --version 得到版本号如： v0.10.26 如果你获得以上输出结果，说明你已经成功安装了Node.js Linux 上安装 Node.js 直接使用已编译好的包 Node 官网已经把 linux 下载版本更改为已编译好的版本了，我们可以直接下载解压后使用： 12345# wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz // 下载# tar xf node-v10.9.0-linux-x64.tar.xz // 解压# cd node-v10.9.0-linux-x64/ // 进入解压目录# ./bin/node -v // 执行node命令 查看版本v10.9.0 解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接： 12ln -s /usr/software/nodejs/bin/npm /usr/local/bin/ ln -s /usr/software/nodejs/bin/node /usr/local/bin/ Ubuntu 源码安装 Node.js 以下部分我们将介绍在 Ubuntu Linux 下使用源码安装 Node.js 。 其他的 Linux 系统，如 Centos 等类似如下安装步骤。 在 Github 上获取 Node.js 源码： 12$ sudo git clone https://github.com/nodejs/node.gitCloning into &#x27;node&#x27;... 修改目录权限： 1$ sudo chmod -R 755 node 使用 ./configure 创建编译文件，并按照： 1234$ cd node$ sudo ./configure$ sudo make$ sudo make install 查看 node 版本： 12$ node --versionv0.10.25 Ubuntu apt-get命令安装 使用命令行工具打开终端，输入以下命令： 1curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash - 输入以下命令安装 Node.js： 12sudo apt-get install nodejssudo apt-get install npm 输入以下命令安装 build-essential 包： 1sudo apt-get install -y build-essential 输入以下命令检查 Node.js 是否安装成功： node -v 如果输出的版本号表明 Node.js 已经安装成功，则表示安装成功。 CentOS 下源码安装 Node.js 下载源码，你需要在 https://nodejs.org/en/download/ 下载最新的Nodejs版本，本文以v0.10.24为例: 12cd /usr/local/src/wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz 解压源码 1tar zxvf node-v0.10.24.tar.gz 编译安装 1234cd node-v0.10.24./configure --prefix=/usr/local/node/0.10.24makemake install 配置NODE_HOME，进入profile编辑环境变量 1vim /etc/profile 设置 nodejs 环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: 123#set for nodejsexport NODE_HOME=/usr/local/node/0.10.24export PATH=$NODE_HOME/bin:$PATH :wq保存并退出，编译/etc/profile 使配置生效 1source /etc/profile 验证是否安装配置成功 1node -v 输出 v0.10.24 表示配置成功 npm模块安装路径 1/usr/local/node/0.10.24/lib/node_modules/ **注：**Nodejs 官网提供了编译好的 Linux 二进制包，你也可以下载下来直接应用。 Mac OS 上安装 你可以通过以下两种方式在 Mac OS 上来安装 node： pkg 安装 在官方下载网站下载 pkg 安装包，直接点击安装即可。 卸载 1sudo rm -rf /usr/local/&#123;bin/&#123;node,npm&#125;,lib/node_modules/npm,lib/node,share/man/*/node.*&#125; brew 安装 1brew install node 验证是否安装配置成功 1node -v 卸载 1brew uninstall node --ignore-dependencies 如果提示异常 Error: No such keg: /usr/local/Cellar/node 则执行 1brew uninstall node --force 配置镜像 1234# 查看当前镜像npm config get registry# 设置镜像为 淘宝镜像npm config set registry http://registry.npm.taobao.org/","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"技术/前端/Node","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Node/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.heyb.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"Node","permalink":"http://blog.heyb.top/tags/Node/"}]},{"title":"hello hexo","slug":"个人/hello hexo","date":"2022-08-10T14:32:54.000Z","updated":"2022-08-12T07:05:12.018Z","comments":true,"path":"2022/08/10/hello-hexo.html","link":"","permalink":"http://blog.heyb.top/2022/08/10/hello-hexo.html","excerpt":"","text":"我刚洗好澡坐下来写下这一开篇文章，似乎已经很久很久没有这样安静下来的写一些东西了。 自工作以来，我总是不断的在吸收摄入知识，已经很久没有像以前初高中时候玩qq空间那样，写一些感想，输出一些内容了。这个时代不断的飞速发展，节奏越来越快，到处都是微博、短视频，甚至教学内容也都逐渐碎片化。我想是时候该慢一些，拾回当初的自己，也检视这十年的自己。 生活 毕业后什么都想尝试，买了很多杂七杂八的电子产品。到最近已经「没有那种世俗欲望了.jpg」，趋向于寻求稳定、适己的事物以及状态。 一直以来都想着自己从零开始开发一个博客系统。但是现实很骨感，一是除去了工作和睡觉并没有留给我太多的时间。二是学艺不精，想要实现前端的界面好的效果实在是太麻烦，总是想着要做就做到最好。但往往一个好的东西是需要时间去雕琢的，开发项目也是如此，现在知名的应用大多最初版本都不是尽善尽美的。现在安定下来，在自己的笔记本电脑上码字，让我有一种归属感，也重新拾起了搭建自己的小天地的想法。这博客可能更多的记录生活中的一些琐事，对生活的思考，和朋友的一些故事等等，也会整理和收纳在工作中遇到的一些技术上的问题以及一些有趣的文章。 可能文章内容没有别人的那么有趣，文笔流畅。但总算是个好的开始，写多了，慢慢拓展，总会比什么都不做得到的进步更多，是吧？ 感情 最近我常常有一种觉得自己处在一个舒适满意的环境中，我常和小环说我好舒服呀。 我觉得我们似乎开始步入了「长期稳定的亲密关系」之中。在一起近两年的时间了，除了逢年过节回老家，几乎每天都是面对面的在一起，我仍然想着每天下班第一时间见到她，每天仍然还有很多事情叭叭叭的想和她分享。大部分的时候我们的想法出奇的一致，喜好也大抵相同，所以不用特别花心思去磨合、迁就对方。 我自觉成长了很多，抱着学习、经营的心态，去维护我们这段感情。期望我们能步入下一个阶段 :) 学习 有些东西真的不去面对的话就会变成心结，甚至多年以后做梦还是会觉得遗憾当初没有好好把握。所以我现在仍要花费比之前在学校更多的努力才觉得能弥补自己一些。去年底开始报一些班课学习，等课程完结之后我再说出来吧。 不过我感觉毕业之后学习东西才开始快起来，对于一些新鲜的东西接纳远比之前在校的时候更快一些，我想也可能跟自己工作了这几年的经验有关系，能对于事物理解得更深刻。 今年更多的是学习学科方向，把以前落下的数学、英语知识补一补。今年比较混乱，忙着找工作（算是借口吧），技术上反而没有太多的长进。计划今年考取PMP资格认证。最近开始写博客后，打算把之前的知识点给整理一下，再查漏补缺。 感觉自己学的东西越多，就越觉得自己渺小。所以想把自己知道的东西整理下来，让别人少走一些弯路。 工作 今年是奔波的一年。去年离开了邮政从广州回到了南宁，期望在南宁能够长远发展。去了小环所在的教育集团当技术主管，本想着能施展自己所长，却因为双减政策导致集团转型，整个部门都被裁剪。后来经过总监介绍去了他朋友的一家电力外包公司，但是公司各方面都存在问题，恶性循环，到后面已经拖欠三四个月工资，已经不是凭我一己之力能够做出改变的，加之南宁的互联网大环境还是有待发展，所以考虑了还是先继续回到广州工作。 回广州面试了近一个半月，十几家公司，几经波折，最后找到一个在外企做服务支撑的公司。也感谢盛斌、陈鑫他们几个好友对我的鼓励，毕竟多年前我都未曾敢想象自己现在能拿到这个工资，从国企几年再出来已经不太清楚自己的市场定位了，是他们一直都跟我说可以再开高一些工资，让我觉得我的能力是值得的。 外国团队的领导对我们也很照顾，团队小伙伴的氛围也很好。各方面的工作安排都很合理，不像国内团队那么内卷，能留给自己的时间很充裕，这一点是让我最喜欢的地方。这能让我在业余时间做很多自己想要做的事情。甚至可以常态化 WFH（work for home居家办公）。 当然凡事是有两面性的，不好的地方就是和外国团队有时差，花费在沟通的时间比较多。整体而言做事效率比以前低了许多。开会聊天和文档也都是用英语，对自己英语考验还是挺大的。还有就是我们组缺少Tech Lead，很多问题只能去其他各组大佬来支持，很多流程不太熟悉，明明很简单的东西还要去咨询别人（很多时候只是需要别人确定是或者否），所以自己会有一种挫败感。 现在也知道，工作嘛，总是有开心和不如意的地方，调整好心态再继续努力了。自己觉得开心的一点是已经开始能够听得懂一些带口音的英语了，也开始逐渐尝试摆脱翻译工具，觉得学习英语也是一件不错的事情。 结束语 今年是一个平凡又不普通的一年，经历过这些才越觉得平凡的可贵。今年只剩一个季度，希望以后的日子自己和身边的人都能够健健康康快快乐乐的就足够了，不求风骚惊天下，但求猥琐动世人。","categories":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/tags/%E4%B8%AA%E4%BA%BA/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"AI","slug":"技术/AI","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/AI/"},{"name":"Stable Diffusion","slug":"技术/AI/Stable-Diffusion","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/AI/Stable-Diffusion/"},{"name":"Python","slug":"技术/Python","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Python/"},{"name":"OCR","slug":"技术/OCR","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/OCR/"},{"name":"写作","slug":"写作","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/"},{"name":"Markdown","slug":"写作/Markdown","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/Markdown/"},{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/categories/%E4%B8%AA%E4%BA%BA/"},{"name":"容器","slug":"技术/容器","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"技术/容器/Docker","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%AE%B9%E5%99%A8/Docker/"},{"name":"其他","slug":"技术/其他","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/"},{"name":"AI","slug":"技术/其他/AI","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/"},{"name":"ChatGPT","slug":"技术/其他/AI/ChatGPT","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96/AI/ChatGPT/"},{"name":"RDS","slug":"技术/RDS","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/"},{"name":"华为云","slug":"技术/RDS/华为云","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/RDS/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"Golang","slug":"技术/Golang","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Golang/"},{"name":"Windows","slug":"技术/Windows","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Windows/"},{"name":"Java","slug":"技术/Java","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/Java/"},{"name":"博客","slug":"写作/博客","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"写作/博客/Hexo","permalink":"http://blog.heyb.top/categories/%E5%86%99%E4%BD%9C/%E5%8D%9A%E5%AE%A2/Hexo/"},{"name":"前端","slug":"技术/前端","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"技术/前端/Node","permalink":"http://blog.heyb.top/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Node/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.heyb.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"AI","slug":"AI","permalink":"http://blog.heyb.top/tags/AI/"},{"name":"Stable Diffusion","slug":"Stable-Diffusion","permalink":"http://blog.heyb.top/tags/Stable-Diffusion/"},{"name":"Python","slug":"Python","permalink":"http://blog.heyb.top/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://blog.heyb.top/tags/OpenCV/"},{"name":"OpenPose","slug":"OpenPose","permalink":"http://blog.heyb.top/tags/OpenPose/"},{"name":"人体姿态识别","slug":"人体姿态识别","permalink":"http://blog.heyb.top/tags/%E4%BA%BA%E4%BD%93%E5%A7%BF%E6%80%81%E8%AF%86%E5%88%AB/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://blog.heyb.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"name":"Haishoku","slug":"Haishoku","permalink":"http://blog.heyb.top/tags/Haishoku/"},{"name":"配色方案","slug":"配色方案","permalink":"http://blog.heyb.top/tags/%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/"},{"name":"Word","slug":"Word","permalink":"http://blog.heyb.top/tags/Word/"},{"name":"OCR","slug":"OCR","permalink":"http://blog.heyb.top/tags/OCR/"},{"name":"Markdown","slug":"Markdown","permalink":"http://blog.heyb.top/tags/Markdown/"},{"name":"数学","slug":"数学","permalink":"http://blog.heyb.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"个人","slug":"个人","permalink":"http://blog.heyb.top/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"容器","slug":"容器","permalink":"http://blog.heyb.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.heyb.top/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://blog.heyb.top/tags/Dockerfile/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://blog.heyb.top/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"http://blog.heyb.top/tags/OpenAI/"},{"name":"华为云","slug":"华为云","permalink":"http://blog.heyb.top/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"RDS","slug":"RDS","permalink":"http://blog.heyb.top/tags/RDS/"},{"name":"Golang","slug":"Golang","permalink":"http://blog.heyb.top/tags/Golang/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.heyb.top/tags/Windows/"},{"name":"gin","slug":"gin","permalink":"http://blog.heyb.top/tags/gin/"},{"name":"gorm","slug":"gorm","permalink":"http://blog.heyb.top/tags/gorm/"},{"name":"viper","slug":"viper","permalink":"http://blog.heyb.top/tags/viper/"},{"name":"go mod","slug":"go-mod","permalink":"http://blog.heyb.top/tags/go-mod/"},{"name":"Java","slug":"Java","permalink":"http://blog.heyb.top/tags/Java/"},{"name":"PPT","slug":"PPT","permalink":"http://blog.heyb.top/tags/PPT/"},{"name":"博客","slug":"博客","permalink":"http://blog.heyb.top/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.heyb.top/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.heyb.top/tags/Hexo/"},{"name":"前端","slug":"前端","permalink":"http://blog.heyb.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Node","slug":"Node","permalink":"http://blog.heyb.top/tags/Node/"},{"name":"NVM","slug":"NVM","permalink":"http://blog.heyb.top/tags/NVM/"}]}