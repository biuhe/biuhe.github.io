{"title":"「Docker」Docker 系列文章2 - Dockerfile","slug":"技术/容器/docker/「Docker」Docker 系列文章2 - Dockerfile","date":"2022-12-15T15:35:33.000Z","updated":"2022-12-25T14:32:51.782Z","comments":true,"path":"api/articles/技术/容器/docker/「Docker」Docker 系列文章2 - Dockerfile.json","excerpt":null,"covers":null,"content":"<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>Dockerfile是一个文本文件，其中包含创建 Docker 镜像所需的步骤和指令。主要分为<strong>基础镜像信息、维护者信息、镜像操作指令和容器启动时指令</strong>四个部分，并支持以 <code>#</code> 开头的注释行。这些指令告诉 Docker 如何设置应用程序的运行环境，通常包括安装软件包、复制文件和设置环境变量的命令。</p>\n<p>用户可以使用 Dockerfile 与 <code>docker build</code> 命令一起使用，用于创建 Docker 自定义镜像，然后可以用该镜像创建 Docker 容器。</p>\n<h2 id=\"构建镜像\"><a class=\"markdownIt-Anchor\" href=\"#构建镜像\"></a> 构建镜像</h2>\n<p>例如，假设我们想要创建一个基于 go-gin 的应用程序，并使用 Docker 运行它。可以使用 Dockerfile 来指定应用程序所需的依赖项、工作目录和启动命令。</p>\n<p>以下是执行步骤</p>\n<ol>\n<li>\n<p>初始化 go 项目：在 Go 项目目录中初始化 <code>go.mod</code> 文件。在终端中输入 <code>go mod init</code> 并回车，这将创建 <code>go.mod</code> 文件。</p>\n</li>\n<li>\n<p>安装 go-gin 框架：在项目中安装 Gin 框架。在终端中输入 <code>go get github.com/gin-gonic/gin</code> 并回车，这将安装 Gin 框架。</p>\n</li>\n<li>\n<p>编写使用 Gin 框架的 Go 代码，<code>gin.go</code> 文件代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试 http 框架 https://github.com/gin-gonic/gin</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 默认返回一个已连接日志记录器和恢复中间件的引擎实例。</span></span><br><span class=\"line\">\tr := gin.Default()</span><br><span class=\"line\">\t<span class=\"comment\">// 绑定路由 /ping，访问后执行func的方法</span></span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/ping&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 返回一个 json， 状态值为 200， H的内容为 map[string]</span></span><br><span class=\"line\">\t\tc.JSON(http.StatusOK, gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;pong&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在0.0.0.0：8080上侦听和服务(对于Windows“为 localhost：8080”)</span></span><br><span class=\"line\">\terr := r.Run()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;启动服务异常：&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>创建一个 <code>Dockerfile</code> 文件，并编写文件。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用安装了Go的基本映像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 维护者信息</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> docker_user wsxc_0617@sina.cn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像的操作指令</span></span><br><span class=\"line\"><span class=\"comment\"># 将工作目录设置为项目根目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将Go代码复制到容器的工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 go module 模式，并设置代理服务</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GO111MODULE=on</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GOPROXY=https://goproxy.cn,direct</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建Go代码</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">env</span> GOOS=linux GOARCH=amd64  go build -o go-gin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暴露应用程序的端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当容器启动时运行Go代码</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;./go-gin&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在这个文件中，第一行必须需要使用 <code>FROM</code> 命令来指定要使用的基础镜像</li>\n<li>使用 <code>COPY</code> 命令将 Go 代码复制到镜像中</li>\n<li>使用 <code>ENV</code> 设置环境变量，这里设置 <code>go module</code> 的代理服务，避免 Go 依赖包下载失败</li>\n<li>使用 <code>RUN go build</code> 命令来构建 Go 代码，<code>-o</code> 表示指定打包后输出的文件名称</li>\n<li>在 <code>Dockerfile</code> 中运行的 Go 代码。可以使用 <code>CMD</code> 或 <code>ENTRYPOINT</code> 命令来运行 Go 代码，一般是执行 <code>go build</code> 构建好的程序名</li>\n</ul>\n</li>\n<li>\n<p>使用 <code>docker build</code> 命令来构建你的 Docker 镜像。在终端中输入 <code>docker build -t &lt;image-name&gt; .</code> 并回车，其中 <code>&lt;image-name&gt;</code> 是我们要为镜像指定的名称</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t go-gin .</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>在命令中 <code>-t</code> 指定镜像的名称和标记， 格式为 <code>name:tag</code>，如 <code>go-gin:latest</code></p>\n</li>\n<li>\n<p>命令末尾的 <code>.</code> 表示构建上下文，即 Dockerfile 和需要包含在镜像中的文件的位置。也可以通过将 <code>.</code> 替换为包含Dockerfile的目录路径来指定不同的目录作为上下文。例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t myimage:latest /path/to/dir</span><br></pre></td></tr></table></figure>\n<p>这将使用 <code>/path/to/dir</code> 目录中的 Dockerfile 和所需文件构建镜像。</p>\n<p>重要的是，上下文必须包括 Dockerfile 和构建镜像所需的所有文件。Docker 守护程序将使用上下文构建镜像，并为 Dockerfile 中的每条指令创建一个新层。<br>\n命令参考：<a href=\"https://docs.docker.com/engine/reference/commandline/build/\">https://docs.docker.com/engine/reference/commandline/build/</a></p>\n</li>\n</ul>\n<p>构建完成后，我们可以通过 <code>docker images</code> 查看构建好的镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>可以看到如下信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY                       TAG           IMAGE ID       CREATED          SIZE</span><br><span class=\"line\">go-gin                           latest        d82303fc77be   34 seconds ago   1.13GB</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用 <code>docker run</code> 命令来运行你的 Docker 镜像。在终端中输入 <code>docker run -p 8080:8080 &lt;image-name&gt;</code> 并回车，其中 <code>8080</code> 是你希望运行应用程序的端口。<br>\n我们运行 <code>docker run -p 8080:8080 go-gin</code> 来运行镜像。可以看到如下结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class=\"line\"></span><br><span class=\"line\">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class=\"line\"> - using env:\texport GIN_MODE=release</span><br><span class=\"line\"> - using code:\tgin.SetMode(gin.ReleaseMode)</span><br><span class=\"line\"></span><br><span class=\"line\">[GIN-debug] GET    /ping                     --&gt; main.main.func1 (3 handlers)</span><br><span class=\"line\">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.</span><br><span class=\"line\">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.</span><br><span class=\"line\">[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default</span><br><span class=\"line\">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure>\n<p>命令参考文档：<a href=\"https://docs.docker.com/engine/reference/run/\">https://docs.docker.com/engine/reference/run/</a></p>\n<p>通过浏览器访问 <code>http://localhost:8080/ping</code>  可以看到返回了信息 <code>&#123;&quot;message&quot;:&quot;pong&quot;&#125;</code></p>\n</li>\n</ol>\n<h2 id=\"分段构建\"><a class=\"markdownIt-Anchor\" href=\"#分段构建\"></a> 分段构建</h2>\n<p>「Dockerfile 构建镜像太大了怎么处理」</p>\n<p>在 Dockerfile 中，可以使用多个构建阶段来进行分段构建。分段构建的目的是为了在构建 Docker 镜像的过程中，更加高效地使用资源。</p>\n<p>在 Dockerfile 中，每个构建阶段都是一个单独的上下文，在每个构建阶段中执行的操作都是独立的。在每个构建阶段结束时，Docker 会将其上下文打包成一个新的镜像层，并将其与前面的镜像层合并。</p>\n<p>我们在上一步操作中可以看到我们的代码量很小，但是构建出来的镜像却有 1GB 大小。主要是因为依赖包等内容也一并打包到构建的镜像中去了，实际上我们仅需编译好 Go 的二进制文件即可运行。因此可以通过 Dockerfile 的分段构建来进行镜像的瘦身。</p>\n<p>代码如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ---------- 构建 ---------- #</span></span><br><span class=\"line\"><span class=\"comment\"># 使用安装了Go的基本映像【并且设置别名】</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:latest as go_app_build</span><br><span class=\"line\"><span class=\"comment\"># 维护者信息</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> docker_user wsxc_0617@sina.cn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像的操作指令</span></span><br><span class=\"line\"><span class=\"comment\"># 将工作目录设置为项目根目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将Go代码复制到容器</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 go module的代理服务</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GO111MODULE=on</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GOPROXY=https://goproxy.cn,direct</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建Go代码</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">env</span> GOOS=linux GOARCH=amd64 go build -o go-gin .</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ---------- 运行 ---------- #</span></span><br><span class=\"line\"><span class=\"comment\"># 运行环境设置为 alpine</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine:latest as go_app_run</span><br><span class=\"line\"><span class=\"comment\"># 【采用相同的目录为工作目录】</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 【将构建镜像中编译好的二进制文件复制到运行镜像中】</span></span><br><span class=\"line\"><span class=\"comment\">#COPY --from=go_app_build /app .</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=0 /app .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示应用程序的端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当容器启动时运行Go代码</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;./go-gin&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>在修改后的 Dockerfile 中，我们可以看到有两个构建阶段：“go_app_build” 和 “go_app_run”。</p>\n<p>在 “go_app_build” 构建阶段中，我们执行了将 Go 代码复制到容器、设置 Go module 的代理服务以及构建 Go 代码的操作。</p>\n<p>在 “go_app_run” 构建阶段中，我们执行了将编译好的二进制文件复制到运行镜像中的操作。</p>\n<p>COPY 指令的 --from 选项允许你从其他构建阶段复制文件。可以使用 FROM 指令的名称来标识构建阶段，也可以使用数字来标识构建阶段。当使用数字标识构建阶段时，0 表示第一个构建阶段，1 表示第二个构建阶段，以此类推。</p>\n<p>例如，在本例中，0 表示名为 “go_app_build” 的构建阶段，即在修改后的 Dockerfile 中的第一个构建阶段。</p>\n<p>使用数字标识构建阶段的好处是，当我们添加、删除或重新排制构建阶段时，只需要更新相应的数字即可，而不需要更新所有的构建阶段名称。</p>\n<p>例如，假设你在修改后的 Dockerfile 中再添加了一个构建阶段，那么只需要将这个新的构建阶段的标识符设置为 2，其他的构建阶段的标识符都不需要更改。这样可以避免出现因为构建阶段名称的更改而导致的潜在问题</p>\n<p>我们使用 <code>docker build -t go-gin2 .</code> 命令，来构建名为 <code>go-gin2</code> 的镜像，并通过 <code>docker images</code> 查看构建好的镜像，结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY                       TAG           IMAGE ID       CREATED          SIZE</span><br><span class=\"line\">go-gin2                          latest        ddbe692c0268   56 minutes ago   36.1MB</span><br></pre></td></tr></table></figure>\n<p>可以看到我们构建出来的镜像比之前小了很多，主要因为</p>\n<blockquote>\n<ol>\n<li>\n<p>同一个 Dockerfile 文件的多个 FROM 是多个不同的image，不同的 image 之间数据隔离，包括环境变量，但是不同的 image 之间可以通过 <code>--from</code> 来传递数据</p>\n</li>\n<li>\n<p>同一个 Dockerfile 的多个 FROM 只有最后一个FROM 才会生成最终的镜像，因此编译阶段的环境没有在第二阶段中，第二阶段只是引用了第一阶段的生成物：二进制文件，所以最终生成的镜像文件比写一个 FROM 要小得多</p>\n</li>\n</ol>\n</blockquote>\n<p>分段构建的优点是，当构建过程中的某个操作失败时，Docker 只需要重新构建失败的构建阶段，而不需要重新构建整个镜像。这样可以提高构建效率，并减少构建失败的风险。</p>\n<p>总的来说，分段构建是一种非常有用的技术，可以帮助我们提高 Docker 镜像的构建效率，并减少构建失败的风险。建议在编写 Dockerfile 时尽量使用分段构建，以便更好地利用 Docker 的构建功能。</p>\n<h2 id=\"指令\"><a class=\"markdownIt-Anchor\" href=\"#指令\"></a> 指令</h2>\n<p>Dockerfile 指令的一般格式为<code>INSTRUCTION &lt;arguments&gt;</code>，下面分别做详细介绍。</p>\n<h3 id=\"from\"><a class=\"markdownIt-Anchor\" href=\"#from\"></a> FROM</h3>\n<p>格式为<code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code>。第一条指令必须为<code>FROM</code>指令，在同一个Dockerfile中创建多个镜像时可以使用多个<code>FROM</code>指令（每个镜像一次）。</p>\n<h3 id=\"maintainer\"><a class=\"markdownIt-Anchor\" href=\"#maintainer\"></a> MAINTAINER</h3>\n<p>格式为<code>MAINTAINER &lt;name&gt;</code>，指定维护者信息。</p>\n<h3 id=\"run\"><a class=\"markdownIt-Anchor\" href=\"#run\"></a> RUN</h3>\n<p>格式为<code>RUN &lt;command&gt;</code>或<code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>。前者将在shell终端中运行命令，即<code>/bin/sh -c</code>；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</span><br></pre></td></tr></table></figure>\n<p>每条<code>RUN</code>指令将在当前镜像基础上执行指定命令，并提交为新的镜像，当命令较长时可使用<code>\\</code>来换行。</p>\n<h3 id=\"cmd\"><a class=\"markdownIt-Anchor\" href=\"#cmd\"></a> CMD</h3>\n<p>支持三种格式：</p>\n<ul>\n<li><code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>，使用<code>exec</code>执行，推荐方式。</li>\n<li><code>CMD command param1 param2</code>，在<code>/bin/sh</code>中执行，提供给需要交互的应用。</li>\n<li><code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code>，提供给<code>ENTRYPOINT</code>的默认参数</li>\n</ul>\n<p>指定启动容器时执行的命令，每个Dockerfile只能有一条<code>CMD</code>命令，如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时指定了运行的命令则会覆盖掉<code>CMD</code>指定的命令。</p>\n<h3 id=\"expose\"><a class=\"markdownIt-Anchor\" href=\"#expose\"></a> EXPOSE</h3>\n<p>格式为<code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>，告诉Docker服务端容器暴露的端口号，供互联系统使用。</p>\n<p>在启动容器时需要通过<code>-P</code>，Docker主机会自动分配一个端口转发到指定的端口；使用<code>-p</code>则可以具体指定哪个本地端口映射过来。</p>\n<h3 id=\"env\"><a class=\"markdownIt-Anchor\" href=\"#env\"></a> ENV</h3>\n<p>格式<code>ENV &lt;key&gt; &lt;value&gt;</code>，指定一个环境变量，会被后续<code>RUN</code>指令使用，并在容器运行时保持。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV PG_MAJOR    9.3</span><br><span class=\"line\">ENV PG_VERSION  9.3.4</span><br><span class=\"line\">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgres &amp;&amp; ...</span><br><span class=\"line\">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>\n<h3 id=\"add\"><a class=\"markdownIt-Anchor\" href=\"#add\"></a> ADD</h3>\n<p>格式<code>ADD &lt;src&gt; &lt;dest&gt;</code>，复制指定的<code>&lt;src&gt;</code>到容器中的<code>&lt;dest&gt;</code>，其中<code>&lt;src&gt;</code>可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。</p>\n<h3 id=\"copy\"><a class=\"markdownIt-Anchor\" href=\"#copy\"></a> COPY</h3>\n<p>格式<code>COPY &lt;src&gt; &lt;dest&gt;</code>，复制本地主机的<code>&lt;src&gt;</code>（为Dockerfile所在目录的相对路径，文件或目录）为容器中的<code>&lt;dest&gt;</code>，目标路径不存在时会自动创建。</p>\n<h3 id=\"entrypoint\"><a class=\"markdownIt-Anchor\" href=\"#entrypoint\"></a> ENTRYPOINT</h3>\n<p>配置容器启动后执行的命令，且不可被<code>docker run</code>提供的参数覆盖。有两种格式：</p>\n<ul>\n<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>\n<li><code>ENTRYPOINT command param1 param2</code>，shell中执行。</li>\n</ul>\n<p>每个Dockerfile中只能有一个<code>ENTRYPOINT</code>，当指定多个<code>ENTRYPOINT时</code>，只有最后一个生效。</p>\n<h3 id=\"volume\"><a class=\"markdownIt-Anchor\" href=\"#volume\"></a> VOLUME</h3>\n<p>格式<code>VOLUME [&quot;/data&quot;]</code>，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>\n<h3 id=\"user\"><a class=\"markdownIt-Anchor\" href=\"#user\"></a> USER</h3>\n<p>格式<code>USER daemon</code>，指定运行容器时的用户名或UID，后续的<code>RUN</code>也会使用指定用户。</p>\n<p>当服务不需要管理员权限时，可通过该命令指定运行用户，并可在之前创建所需要的用户。要临时获取管理员权限可使用<code>gosu</code>，而不推荐<code>sudo</code>。</p>\n<h3 id=\"workdir\"><a class=\"markdownIt-Anchor\" href=\"#workdir\"></a> WORKDIR</h3>\n<p>格式<code>WORKDIR /path/to/workdir</code>，为后续的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>指令配置工作目录。</p>\n<p>可以使用多个<code>WORKDIR</code>指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /a</span><br><span class=\"line\">WORKDIR b</span><br><span class=\"line\">WORKDIR c</span><br><span class=\"line\">RUN pwd</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">最终路径为/a/b/c</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"onbuild\"><a class=\"markdownIt-Anchor\" href=\"#onbuild\"></a> ONBUILD</h3>\n<p>格式<code>ONBUILD [INSTRUCTION]</code>，配置当前所创建的镜像作为其他新创建的基础镜像时所执行的操作指令。</p>\n<p>镜像image-A Dockerfile</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]</span><br><span class=\"line\">ONBUILD ADD . /app/src</span><br><span class=\"line\">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class=\"line\">[...]</span><br></pre></td></tr></table></figure>\n<p>基于image-A创建新镜像，新的Dockerfile中使用<code>FROM images-A</code>指定基础镜像时，会自动执行<code>ONBUILD</code>指令内容，等价于在后面添加了两条指令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM images-A</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Automatically run the following 等价于自动运行以下命令</span></span><br><span class=\"line\">ADD . /app/src</span><br><span class=\"line\">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure>\n<p>使用<code>ONBUILD</code>指令的镜像推荐在标签中注明。例如<code>ruby:1.9-onbuild</code>。</p>\n<blockquote>\n<p>实用技巧：</p>\n<p>如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。</p>\n<p>例如上面的底是<code>golang:latest</code>，我们可以运行<code>docker run -it -d golang:latest bash</code>，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。</p>\n<p>掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。</p>\n</blockquote>\n<h2 id=\"扩展\"><a class=\"markdownIt-Anchor\" href=\"#扩展\"></a> 扩展</h2>\n<p>怎样上传到阿里云私有仓库？</p>\n<h2 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\"></a> 参考</h2>\n<blockquote>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/#run\">官方文档</a></p>\n<p><a href=\"https://www.jianshu.com/p/f272726db9c5\">Docker安装与基本操作</a></p>\n<p><a href=\"https://docker.easydoc.net/doc/81170005/cCewZWoN/N9VtYIIi\">Docker 快速入门-制作自己的镜像</a></p>\n<p><a href=\"https://www.jianshu.com/p/678b751d14ae\">go 构建最小的镜像</a></p>\n</blockquote>\n","more":"<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>Dockerfile是一个文本文件，其中包含创建 Docker 镜像所需的步骤和指令。主要分为<strong>基础镜像信息、维护者信息、镜像操作指令和容器启动时指令</strong>四个部分，并支持以 <code>#</code> 开头的注释行。这些指令告诉 Docker 如何设置应用程序的运行环境，通常包括安装软件包、复制文件和设置环境变量的命令。</p>\n<p>用户可以使用 Dockerfile 与 <code>docker build</code> 命令一起使用，用于创建 Docker 自定义镜像，然后可以用该镜像创建 Docker 容器。</p>\n<h2 id=\"构建镜像\"><a class=\"markdownIt-Anchor\" href=\"#构建镜像\"></a> 构建镜像</h2>\n<p>例如，假设我们想要创建一个基于 go-gin 的应用程序，并使用 Docker 运行它。可以使用 Dockerfile 来指定应用程序所需的依赖项、工作目录和启动命令。</p>\n<p>以下是执行步骤</p>\n<ol>\n<li>\n<p>初始化 go 项目：在 Go 项目目录中初始化 <code>go.mod</code> 文件。在终端中输入 <code>go mod init</code> 并回车，这将创建 <code>go.mod</code> 文件。</p>\n</li>\n<li>\n<p>安装 go-gin 框架：在项目中安装 Gin 框架。在终端中输入 <code>go get github.com/gin-gonic/gin</code> 并回车，这将安装 Gin 框架。</p>\n</li>\n<li>\n<p>编写使用 Gin 框架的 Go 代码，<code>gin.go</code> 文件代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试 http 框架 https://github.com/gin-gonic/gin</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 默认返回一个已连接日志记录器和恢复中间件的引擎实例。</span></span><br><span class=\"line\">\tr := gin.Default()</span><br><span class=\"line\">\t<span class=\"comment\">// 绑定路由 /ping，访问后执行func的方法</span></span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/ping&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 返回一个 json， 状态值为 200， H的内容为 map[string]</span></span><br><span class=\"line\">\t\tc.JSON(http.StatusOK, gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;pong&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在0.0.0.0：8080上侦听和服务(对于Windows“为 localhost：8080”)</span></span><br><span class=\"line\">\terr := r.Run()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;启动服务异常：&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>创建一个 <code>Dockerfile</code> 文件，并编写文件。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用安装了Go的基本映像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 维护者信息</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> docker_user wsxc_0617@sina.cn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像的操作指令</span></span><br><span class=\"line\"><span class=\"comment\"># 将工作目录设置为项目根目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将Go代码复制到容器的工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 go module 模式，并设置代理服务</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GO111MODULE=on</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GOPROXY=https://goproxy.cn,direct</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建Go代码</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">env</span> GOOS=linux GOARCH=amd64  go build -o go-gin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暴露应用程序的端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当容器启动时运行Go代码</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;./go-gin&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在这个文件中，第一行必须需要使用 <code>FROM</code> 命令来指定要使用的基础镜像</li>\n<li>使用 <code>COPY</code> 命令将 Go 代码复制到镜像中</li>\n<li>使用 <code>ENV</code> 设置环境变量，这里设置 <code>go module</code> 的代理服务，避免 Go 依赖包下载失败</li>\n<li>使用 <code>RUN go build</code> 命令来构建 Go 代码，<code>-o</code> 表示指定打包后输出的文件名称</li>\n<li>在 <code>Dockerfile</code> 中运行的 Go 代码。可以使用 <code>CMD</code> 或 <code>ENTRYPOINT</code> 命令来运行 Go 代码，一般是执行 <code>go build</code> 构建好的程序名</li>\n</ul>\n</li>\n<li>\n<p>使用 <code>docker build</code> 命令来构建你的 Docker 镜像。在终端中输入 <code>docker build -t &lt;image-name&gt; .</code> 并回车，其中 <code>&lt;image-name&gt;</code> 是我们要为镜像指定的名称</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t go-gin .</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>在命令中 <code>-t</code> 指定镜像的名称和标记， 格式为 <code>name:tag</code>，如 <code>go-gin:latest</code></p>\n</li>\n<li>\n<p>命令末尾的 <code>.</code> 表示构建上下文，即 Dockerfile 和需要包含在镜像中的文件的位置。也可以通过将 <code>.</code> 替换为包含Dockerfile的目录路径来指定不同的目录作为上下文。例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t myimage:latest /path/to/dir</span><br></pre></td></tr></table></figure>\n<p>这将使用 <code>/path/to/dir</code> 目录中的 Dockerfile 和所需文件构建镜像。</p>\n<p>重要的是，上下文必须包括 Dockerfile 和构建镜像所需的所有文件。Docker 守护程序将使用上下文构建镜像，并为 Dockerfile 中的每条指令创建一个新层。<br>\n命令参考：<a href=\"https://docs.docker.com/engine/reference/commandline/build/\">https://docs.docker.com/engine/reference/commandline/build/</a></p>\n</li>\n</ul>\n<p>构建完成后，我们可以通过 <code>docker images</code> 查看构建好的镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>可以看到如下信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY                       TAG           IMAGE ID       CREATED          SIZE</span><br><span class=\"line\">go-gin                           latest        d82303fc77be   34 seconds ago   1.13GB</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用 <code>docker run</code> 命令来运行你的 Docker 镜像。在终端中输入 <code>docker run -p 8080:8080 &lt;image-name&gt;</code> 并回车，其中 <code>8080</code> 是你希望运行应用程序的端口。<br>\n我们运行 <code>docker run -p 8080:8080 go-gin</code> 来运行镜像。可以看到如下结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class=\"line\"></span><br><span class=\"line\">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class=\"line\"> - using env:\texport GIN_MODE=release</span><br><span class=\"line\"> - using code:\tgin.SetMode(gin.ReleaseMode)</span><br><span class=\"line\"></span><br><span class=\"line\">[GIN-debug] GET    /ping                     --&gt; main.main.func1 (3 handlers)</span><br><span class=\"line\">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.</span><br><span class=\"line\">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.</span><br><span class=\"line\">[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default</span><br><span class=\"line\">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure>\n<p>命令参考文档：<a href=\"https://docs.docker.com/engine/reference/run/\">https://docs.docker.com/engine/reference/run/</a></p>\n<p>通过浏览器访问 <code>http://localhost:8080/ping</code>  可以看到返回了信息 <code>&#123;&quot;message&quot;:&quot;pong&quot;&#125;</code></p>\n</li>\n</ol>\n<h2 id=\"分段构建\"><a class=\"markdownIt-Anchor\" href=\"#分段构建\"></a> 分段构建</h2>\n<p>「Dockerfile 构建镜像太大了怎么处理」</p>\n<p>在 Dockerfile 中，可以使用多个构建阶段来进行分段构建。分段构建的目的是为了在构建 Docker 镜像的过程中，更加高效地使用资源。</p>\n<p>在 Dockerfile 中，每个构建阶段都是一个单独的上下文，在每个构建阶段中执行的操作都是独立的。在每个构建阶段结束时，Docker 会将其上下文打包成一个新的镜像层，并将其与前面的镜像层合并。</p>\n<p>我们在上一步操作中可以看到我们的代码量很小，但是构建出来的镜像却有 1GB 大小。主要是因为依赖包等内容也一并打包到构建的镜像中去了，实际上我们仅需编译好 Go 的二进制文件即可运行。因此可以通过 Dockerfile 的分段构建来进行镜像的瘦身。</p>\n<p>代码如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ---------- 构建 ---------- #</span></span><br><span class=\"line\"><span class=\"comment\"># 使用安装了Go的基本映像【并且设置别名】</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> golang:latest as go_app_build</span><br><span class=\"line\"><span class=\"comment\"># 维护者信息</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> docker_user wsxc_0617@sina.cn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 镜像的操作指令</span></span><br><span class=\"line\"><span class=\"comment\"># 将工作目录设置为项目根目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将Go代码复制到容器</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 go module的代理服务</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GO111MODULE=on</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> GOPROXY=https://goproxy.cn,direct</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建Go代码</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">env</span> GOOS=linux GOARCH=amd64 go build -o go-gin .</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ---------- 运行 ---------- #</span></span><br><span class=\"line\"><span class=\"comment\"># 运行环境设置为 alpine</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine:latest as go_app_run</span><br><span class=\"line\"><span class=\"comment\"># 【采用相同的目录为工作目录】</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 【将构建镜像中编译好的二进制文件复制到运行镜像中】</span></span><br><span class=\"line\"><span class=\"comment\">#COPY --from=go_app_build /app .</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=0 /app .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示应用程序的端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当容器启动时运行Go代码</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;./go-gin&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>在修改后的 Dockerfile 中，我们可以看到有两个构建阶段：“go_app_build” 和 “go_app_run”。</p>\n<p>在 “go_app_build” 构建阶段中，我们执行了将 Go 代码复制到容器、设置 Go module 的代理服务以及构建 Go 代码的操作。</p>\n<p>在 “go_app_run” 构建阶段中，我们执行了将编译好的二进制文件复制到运行镜像中的操作。</p>\n<p>COPY 指令的 --from 选项允许你从其他构建阶段复制文件。可以使用 FROM 指令的名称来标识构建阶段，也可以使用数字来标识构建阶段。当使用数字标识构建阶段时，0 表示第一个构建阶段，1 表示第二个构建阶段，以此类推。</p>\n<p>例如，在本例中，0 表示名为 “go_app_build” 的构建阶段，即在修改后的 Dockerfile 中的第一个构建阶段。</p>\n<p>使用数字标识构建阶段的好处是，当我们添加、删除或重新排制构建阶段时，只需要更新相应的数字即可，而不需要更新所有的构建阶段名称。</p>\n<p>例如，假设你在修改后的 Dockerfile 中再添加了一个构建阶段，那么只需要将这个新的构建阶段的标识符设置为 2，其他的构建阶段的标识符都不需要更改。这样可以避免出现因为构建阶段名称的更改而导致的潜在问题</p>\n<p>我们使用 <code>docker build -t go-gin2 .</code> 命令，来构建名为 <code>go-gin2</code> 的镜像，并通过 <code>docker images</code> 查看构建好的镜像，结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY                       TAG           IMAGE ID       CREATED          SIZE</span><br><span class=\"line\">go-gin2                          latest        ddbe692c0268   56 minutes ago   36.1MB</span><br></pre></td></tr></table></figure>\n<p>可以看到我们构建出来的镜像比之前小了很多，主要因为</p>\n<blockquote>\n<ol>\n<li>\n<p>同一个 Dockerfile 文件的多个 FROM 是多个不同的image，不同的 image 之间数据隔离，包括环境变量，但是不同的 image 之间可以通过 <code>--from</code> 来传递数据</p>\n</li>\n<li>\n<p>同一个 Dockerfile 的多个 FROM 只有最后一个FROM 才会生成最终的镜像，因此编译阶段的环境没有在第二阶段中，第二阶段只是引用了第一阶段的生成物：二进制文件，所以最终生成的镜像文件比写一个 FROM 要小得多</p>\n</li>\n</ol>\n</blockquote>\n<p>分段构建的优点是，当构建过程中的某个操作失败时，Docker 只需要重新构建失败的构建阶段，而不需要重新构建整个镜像。这样可以提高构建效率，并减少构建失败的风险。</p>\n<p>总的来说，分段构建是一种非常有用的技术，可以帮助我们提高 Docker 镜像的构建效率，并减少构建失败的风险。建议在编写 Dockerfile 时尽量使用分段构建，以便更好地利用 Docker 的构建功能。</p>\n<h2 id=\"指令\"><a class=\"markdownIt-Anchor\" href=\"#指令\"></a> 指令</h2>\n<p>Dockerfile 指令的一般格式为<code>INSTRUCTION &lt;arguments&gt;</code>，下面分别做详细介绍。</p>\n<h3 id=\"from\"><a class=\"markdownIt-Anchor\" href=\"#from\"></a> FROM</h3>\n<p>格式为<code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code>。第一条指令必须为<code>FROM</code>指令，在同一个Dockerfile中创建多个镜像时可以使用多个<code>FROM</code>指令（每个镜像一次）。</p>\n<h3 id=\"maintainer\"><a class=\"markdownIt-Anchor\" href=\"#maintainer\"></a> MAINTAINER</h3>\n<p>格式为<code>MAINTAINER &lt;name&gt;</code>，指定维护者信息。</p>\n<h3 id=\"run\"><a class=\"markdownIt-Anchor\" href=\"#run\"></a> RUN</h3>\n<p>格式为<code>RUN &lt;command&gt;</code>或<code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>。前者将在shell终端中运行命令，即<code>/bin/sh -c</code>；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</span><br></pre></td></tr></table></figure>\n<p>每条<code>RUN</code>指令将在当前镜像基础上执行指定命令，并提交为新的镜像，当命令较长时可使用<code>\\</code>来换行。</p>\n<h3 id=\"cmd\"><a class=\"markdownIt-Anchor\" href=\"#cmd\"></a> CMD</h3>\n<p>支持三种格式：</p>\n<ul>\n<li><code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>，使用<code>exec</code>执行，推荐方式。</li>\n<li><code>CMD command param1 param2</code>，在<code>/bin/sh</code>中执行，提供给需要交互的应用。</li>\n<li><code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code>，提供给<code>ENTRYPOINT</code>的默认参数</li>\n</ul>\n<p>指定启动容器时执行的命令，每个Dockerfile只能有一条<code>CMD</code>命令，如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时指定了运行的命令则会覆盖掉<code>CMD</code>指定的命令。</p>\n<h3 id=\"expose\"><a class=\"markdownIt-Anchor\" href=\"#expose\"></a> EXPOSE</h3>\n<p>格式为<code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>，告诉Docker服务端容器暴露的端口号，供互联系统使用。</p>\n<p>在启动容器时需要通过<code>-P</code>，Docker主机会自动分配一个端口转发到指定的端口；使用<code>-p</code>则可以具体指定哪个本地端口映射过来。</p>\n<h3 id=\"env\"><a class=\"markdownIt-Anchor\" href=\"#env\"></a> ENV</h3>\n<p>格式<code>ENV &lt;key&gt; &lt;value&gt;</code>，指定一个环境变量，会被后续<code>RUN</code>指令使用，并在容器运行时保持。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV PG_MAJOR    9.3</span><br><span class=\"line\">ENV PG_VERSION  9.3.4</span><br><span class=\"line\">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgres &amp;&amp; ...</span><br><span class=\"line\">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>\n<h3 id=\"add\"><a class=\"markdownIt-Anchor\" href=\"#add\"></a> ADD</h3>\n<p>格式<code>ADD &lt;src&gt; &lt;dest&gt;</code>，复制指定的<code>&lt;src&gt;</code>到容器中的<code>&lt;dest&gt;</code>，其中<code>&lt;src&gt;</code>可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。</p>\n<h3 id=\"copy\"><a class=\"markdownIt-Anchor\" href=\"#copy\"></a> COPY</h3>\n<p>格式<code>COPY &lt;src&gt; &lt;dest&gt;</code>，复制本地主机的<code>&lt;src&gt;</code>（为Dockerfile所在目录的相对路径，文件或目录）为容器中的<code>&lt;dest&gt;</code>，目标路径不存在时会自动创建。</p>\n<h3 id=\"entrypoint\"><a class=\"markdownIt-Anchor\" href=\"#entrypoint\"></a> ENTRYPOINT</h3>\n<p>配置容器启动后执行的命令，且不可被<code>docker run</code>提供的参数覆盖。有两种格式：</p>\n<ul>\n<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>\n<li><code>ENTRYPOINT command param1 param2</code>，shell中执行。</li>\n</ul>\n<p>每个Dockerfile中只能有一个<code>ENTRYPOINT</code>，当指定多个<code>ENTRYPOINT时</code>，只有最后一个生效。</p>\n<h3 id=\"volume\"><a class=\"markdownIt-Anchor\" href=\"#volume\"></a> VOLUME</h3>\n<p>格式<code>VOLUME [&quot;/data&quot;]</code>，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>\n<h3 id=\"user\"><a class=\"markdownIt-Anchor\" href=\"#user\"></a> USER</h3>\n<p>格式<code>USER daemon</code>，指定运行容器时的用户名或UID，后续的<code>RUN</code>也会使用指定用户。</p>\n<p>当服务不需要管理员权限时，可通过该命令指定运行用户，并可在之前创建所需要的用户。要临时获取管理员权限可使用<code>gosu</code>，而不推荐<code>sudo</code>。</p>\n<h3 id=\"workdir\"><a class=\"markdownIt-Anchor\" href=\"#workdir\"></a> WORKDIR</h3>\n<p>格式<code>WORKDIR /path/to/workdir</code>，为后续的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>指令配置工作目录。</p>\n<p>可以使用多个<code>WORKDIR</code>指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /a</span><br><span class=\"line\">WORKDIR b</span><br><span class=\"line\">WORKDIR c</span><br><span class=\"line\">RUN pwd</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">最终路径为/a/b/c</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"onbuild\"><a class=\"markdownIt-Anchor\" href=\"#onbuild\"></a> ONBUILD</h3>\n<p>格式<code>ONBUILD [INSTRUCTION]</code>，配置当前所创建的镜像作为其他新创建的基础镜像时所执行的操作指令。</p>\n<p>镜像image-A Dockerfile</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]</span><br><span class=\"line\">ONBUILD ADD . /app/src</span><br><span class=\"line\">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class=\"line\">[...]</span><br></pre></td></tr></table></figure>\n<p>基于image-A创建新镜像，新的Dockerfile中使用<code>FROM images-A</code>指定基础镜像时，会自动执行<code>ONBUILD</code>指令内容，等价于在后面添加了两条指令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM images-A</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Automatically run the following 等价于自动运行以下命令</span></span><br><span class=\"line\">ADD . /app/src</span><br><span class=\"line\">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure>\n<p>使用<code>ONBUILD</code>指令的镜像推荐在标签中注明。例如<code>ruby:1.9-onbuild</code>。</p>\n<blockquote>\n<p>实用技巧：</p>\n<p>如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。</p>\n<p>例如上面的底是<code>golang:latest</code>，我们可以运行<code>docker run -it -d golang:latest bash</code>，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。</p>\n<p>掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。</p>\n</blockquote>\n<h2 id=\"扩展\"><a class=\"markdownIt-Anchor\" href=\"#扩展\"></a> 扩展</h2>\n<p>怎样上传到阿里云私有仓库？</p>\n<h2 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\"></a> 参考</h2>\n<blockquote>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/#run\">官方文档</a></p>\n<p><a href=\"https://www.jianshu.com/p/f272726db9c5\">Docker安装与基本操作</a></p>\n<p><a href=\"https://docker.easydoc.net/doc/81170005/cCewZWoN/N9VtYIIi\">Docker 快速入门-制作自己的镜像</a></p>\n<p><a href=\"https://www.jianshu.com/p/678b751d14ae\">go 构建最小的镜像</a></p>\n</blockquote>\n","categories":[{"name":"技术","path":"api/categories/技术.json"},{"name":"容器","path":"api/categories/容器.json"},{"name":"Docker","path":"api/categories/Docker.json"}],"tags":[{"name":"技术","path":"api/tags/技术.json"},{"name":"容器","path":"api/tags/容器.json"},{"name":"Docker","path":"api/tags/Docker.json"},{"name":"Dockerfile","path":"api/tags/Dockerfile.json"}]}